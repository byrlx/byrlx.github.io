<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
"http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en">
<head>
<!-- 2017-03-02 Thu 11:03 -->
<meta  http-equiv="Content-Type" content="text/html;charset=utf-8" />
<meta  name="viewport" content="width=device-width, initial-scale=1" />
<title></title>
<meta  name="generator" content="Org-mode" />
<meta  name="author" content="Luis Xu" />
<link rel="stylesheet" title="Standard" href="/style/worg.css" type="text/css" />
<link rel="alternate stylesheet" title="Zenburn" href="/style/worg-zenburn.css" type="text/css" />
<link rel="alternate stylesheet" title="Classic" href="/style/worg-classic.css" type="text/css" />
<link rel="SHORTCUT ICON" href="/org-mode-unicorn.ico" type="image/x-icon" />
<link rel="icon" href="/org-mode-unicorn.ico" type="image/ico" />
<script type="text/javascript">
/*
@licstart  The following is the entire license notice for the
JavaScript code in this tag.

Copyright (C) 2012-2013 Free Software Foundation, Inc.

The JavaScript code in this tag is free software: you can
redistribute it and/or modify it under the terms of the GNU
General Public License (GNU GPL) as published by the Free Software
Foundation, either version 3 of the License, or (at your option)
any later version.  The code is distributed WITHOUT ANY WARRANTY;
without even the implied warranty of MERCHANTABILITY or FITNESS
FOR A PARTICULAR PURPOSE.  See the GNU GPL for more details.

As additional permission under GNU GPL version 3 section 7, you
may distribute non-source (e.g., minimized or compacted) forms of
that code without the copy of the GNU GPL normally required by
section 4, provided you include this license notice and a URL
through which recipients can access the Corresponding Source.


@licend  The above is the entire license notice
for the JavaScript code in this tag.
*/
<!--/*--><![CDATA[/*><!--*/
 function CodeHighlightOn(elem, id)
 {
   var target = document.getElementById(id);
   if(null != target) {
     elem.cacheClassElem = elem.className;
     elem.cacheClassTarget = target.className;
     target.className = "code-highlighted";
     elem.className   = "code-highlighted";
   }
 }
 function CodeHighlightOff(elem, id)
 {
   var target = document.getElementById(id);
   if(elem.cacheClassElem)
     elem.className = elem.cacheClassElem;
   if(elem.cacheClassTarget)
     target.className = elem.cacheClassTarget;
 }
/*]]>*///-->
</script>
</head>
<body>
<div id="preamble" class="status">
<script type="text/javascript">

  var _gaq = _gaq || [];
  _gaq.push(['_setAccount', 'UA-7691209-1']);
  _gaq.push(['_trackPageview']);

  (function() {
    var ga = document.createElement('script'); ga.type = 'text/javascript'; ga.async = true;
    ga.src = ('https:' == document.location.protocol ? 'https://ssl' : 'http://www') + '.google-analytics.com/ga.js';
    var s = document.getElementsByTagName('script')[0]; s.parentNode.insertBefore(ga, s);
  })();

  document.addEventListener('DOMContentLoaded',function() {
      document.getElementById("table-of-contents").onclick = function() {
          var elem = document.getElementById("text-table-of-contents");
          elem.style.display = elem.style.display == "block" ? "none" : "block";
      }
  });
</script>
</div>
<div id="content">
<div id="table-of-contents">
<h2>Table of Contents</h2>
<div id="text-table-of-contents">
<ul>
<li><a href="#orgheadline1">通过反射获取toolbar的title view</a></li>
<li><a href="#orgheadline3">AppBarLayout</a>
<ul>
<li><a href="#orgheadline2">Behavior</a></li>
<li><a href="#orgheadline4">ScrollingViewBehavior</a></li>
<li><a href="#orgheadline5">ViewOffsetHelper</a></li>
</ul>
</li>
<li><a href="#orgheadline6">umeng和okhttp报错: okio的duplicated file</a></li>
<li><a href="#orgheadline35">RecyclerView</a>
<ul>
<li><a href="#orgheadline7">note</a></li>
<li><a href="#orgheadline8">Adapter</a>
<ul>
<li><a href="#orgheadline9">note</a></li>
</ul>
</li>
<li><a href="#orgheadline10">ViewHolder</a></li>
<li><a href="#orgheadline11">AdapterDataObserver</a></li>
<li><a href="#orgheadline12">AdapterDataObservable</a></li>
<li><a href="#orgheadline13">LayoutManager</a>
<ul>
<li><a href="#orgheadline14">setMeasuredDimensionFromChildren</a></li>
<li><a href="#orgheadline15">mAutoMeasure</a></li>
<li><a href="#orgheadline16">onLayoutChildren</a></li>
</ul>
</li>
<li><a href="#orgheadline17">ChildHelper</a></li>
<li><a href="#orgheadline18">State</a></li>
<li><a href="#orgheadline19">LinearLayoutManager</a></li>
<li><a href="#orgheadline20">Recycler</a></li>
<li><a href="#orgheadline21">RecycledViewPool</a></li>
<li><a href="#orgheadline22">AdapterHelper</a></li>
<li><a href="#orgheadline23">UpdateOp</a></li>
<li><a href="#orgheadline24">OpRecorderer</a></li>
<li><a href="#orgheadline25">RecyclerViewAccessibilityDelegate</a></li>
<li><a href="#orgheadline26">DefaultItemAnimator</a></li>
<li><a href="#orgheadline27">ItemAnimator</a></li>
<li><a href="#orgheadline28">RV</a></li>
<li><a href="#orgheadline29">ItemDecoration</a></li>
<li><a href="#orgheadline33">Home页"卡片"源码学习笔记</a>
<ul>
<li><a href="#orgheadline31">自定义控件TwoWayView</a></li>
<li><a href="#orgheadline30">TwoWayLayoutManager</a></li>
<li><a href="#orgheadline32">DividerItemDecoration</a></li>
</ul>
</li>
<li><a href="#orgheadline34">文章阅读笔记</a></li>
</ul>
</li>
<li><a href="#orgheadline40">View</a>
<ul>
<li><a href="#orgheadline36">view的坐标系</a></li>
<li><a href="#orgheadline37">在竖直方向移动view</a></li>
<li><a href="#orgheadline38">给当前window添加view:</a></li>
<li><a href="#orgheadline39">设置view在不同状态下的UI展示</a></li>
</ul>
</li>
<li><a href="#orgheadline41">事件分发</a></li>
<li><a href="#orgheadline42">数据库</a></li>
<li><a href="#orgheadline43">ormlite库操作数据库</a></li>
<li><a href="#orgheadline52">app 常用库</a>
<ul>
<li><a href="#orgheadline44">gson操作json字符串</a></li>
<li><a href="#orgheadline45">okhttp进行网络操作</a></li>
<li><a href="#orgheadline46">fresco网络图片加载</a></li>
<li><a href="#orgheadline47">umeng进行统计分析和反馈</a></li>
<li><a href="#orgheadline48">sharesdk进行统一分享</a></li>
<li><a href="#orgheadline49">阿里聚安全进行加密</a></li>
<li><a href="#orgheadline50">广点通和百度的广告进行广告投放</a></li>
<li><a href="#orgheadline51">小米push和umengpush来推送消息</a></li>
</ul>
</li>
<li><a href="#orgheadline53">设置多进程</a></li>
<li><a href="#orgheadline54">四种启动模式</a></li>
<li><a href="#orgheadline55">让activity支持scheme</a></li>
<li><a href="#orgheadline56">home页蒙版指导图</a></li>
<li><a href="#orgheadline57">在别人的页面(例如系统页面)显示指导</a></li>
<li><a href="#orgheadline58">设置应用可以获取通知权限保持应用不被杀死</a></li>
<li><a href="#orgheadline59">通常可以放在Application类的动作</a></li>
<li><a href="#orgheadline62">可替换库对比</a>
<ul>
<li><a href="#orgheadline60">recyclerView VS listView</a></li>
<li><a href="#orgheadline61">startService VS bindService</a></li>
</ul>
</li>
<li><a href="#orgheadline65">thread with looper and handler</a>
<ul>
<li><a href="#orgheadline63">在其他线程中创建handler</a></li>
<li><a href="#orgheadline64">在其他线程中使用UI线程的looper.</a></li>
</ul>
</li>
<li><a href="#orgheadline66">how to resolve ANR</a></li>
<li><a href="#orgheadline68">touch事件传递机制</a>
<ul>
<li><a href="#orgheadline67">实验</a></li>
</ul>
</li>
<li><a href="#orgheadline69">使用 Resource 类来获取 resource 资源</a></li>
<li><a href="#orgheadline70">辅助功能</a>
<ul>
<li><a href="#orgheadline71">开启步骤</a></li>
<li><a href="#orgheadline72">自动控制逻辑</a></li>
</ul>
</li>
<li><a href="#orgheadline73">系统的"最近任务"中不现实activity</a></li>
<li><a href="#orgheadline74">打开"最近任务"窗口</a></li>
<li><a href="#orgheadline76">不同机型特殊配置</a>
<ul>
<li><a href="#orgheadline75">判断是否为小米及获取小米版本</a></li>
</ul>
</li>
<li><a href="#orgheadline77">获取当前正在运行的应用</a>
<ul>
<li><a href="#orgheadline78">getRunningAppProcess()</a></li>
<li><a href="#orgheadline79">queryUsageStats()</a></li>
<li><a href="#orgheadline80">getRunningTasks()</a></li>
</ul>
</li>
<li><a href="#orgheadline81">使用 native 程序保持进程不死</a></li>
<li><a href="#orgheadline82">版本更新</a></li>
<li><a href="#orgheadline83">与服务器数据传输的加密</a></li>
<li><a href="#orgheadline84">通过 intentservice 来执行后台任务</a></li>
<li><a href="#orgheadline86">JobScheduler</a>
<ul>
<li><a href="#orgheadline85">一般使用流程</a></li>
</ul>
</li>
<li><a href="#orgheadline90">ch</a>
<ul>
<li><a href="#orgheadline87">常见的主页展示方式</a></li>
<li><a href="#orgheadline88">锁屏上的滑动解锁 view</a>
<ul>
<li><a href="#orgheadline89">通过 view 学习的思考自定义 view 的实现</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#orgheadline95">Handler</a>
<ul>
<li><a href="#orgheadline91">消息分发流程 dispatchMessage()</a></li>
<li><a href="#orgheadline92">Handler创建</a></li>
<li><a href="#orgheadline93">通过Handler获取消息</a></li>
<li><a href="#orgheadline94">会导致内存泄漏的原因?</a></li>
</ul>
</li>
<li><a href="#orgheadline98">jni</a>
<ul>
<li><a href="#orgheadline96">jni里分配的内存会算到OOM内存上吗?</a></li>
<li><a href="#orgheadline97">jni原理</a></li>
</ul>
</li>
<li><a href="#orgheadline99">AsyncTask支持多任务提交吗?</a></li>
<li><a href="#orgheadline100">如何设计网络框架?</a></li>
<li><a href="#orgheadline101">前台service的好处?</a></li>
<li><a href="#orgheadline102">ImageLoader如何同步</a></li>
<li><a href="#orgheadline103">单例模式使用volatile</a></li>
<li><a href="#orgheadline104">thread vs asynctask</a></li>
</ul>
</div>
</div>
<div id="outline-container-orgheadline1" class="outline-2">
<h2 id="orgheadline1">通过反射获取toolbar的title view&#xa0;&#xa0;&#xa0;<span class="tag"><span class="view">view</span></span></h2>
<div class="outline-text-2" id="text-orgheadline1">
<pre class="example">
  private TextView getActionBarTextView() {
    TextView titleTextView = null;

    try {
        Field f = mToolBar.getClass().getDeclaredField("mTitleTextView");
        f.setAccessible(true);
        titleTextView = (TextView) f.get(mToolBar);
    } catch (NoSuchFieldException e) {
    } catch (IllegalAccessException e) {
    }
    return titleTextView;
}
</pre>
</div>
</div>
<div id="outline-container-orgheadline3" class="outline-2">
<h2 id="orgheadline3">AppBarLayout&#xa0;&#xa0;&#xa0;<span class="tag"><span class="coordinatorlayout">coordinatorlayout</span></span></h2>
<div class="outline-text-2" id="text-orgheadline3">
<ol class="org-ol">
<li>该类的默认behavior是<a href="#orgheadline2">Behavior</a>, 是用标注修饰的.</li>
<li>定义了OnOffsetChangedListener接口. 可以将该view
offset的变化传递给子view.</li>
<li>getTotalScrollRange()
获取appbar的scroll的范围, 因为appbar是linearlayout,
所以从上向下遍历, 直到遇到没有设置sroll flag的子view,
其range是所有该设置flag的子view的高度和, 如果碰到设置了
scroll flag的子view同时设置了SCROLL_FLAG_EXIT_UNTIL_COLLAPSED,
则值等于前面相加的和减去该子view的最小高度.</li>
<li>调用checkAppCompatTheme()检查有没有用AppCompat主题.</li>
<li>获取xml配置中的elevation属性</li>
<li>设置xml定义的drawable</li>
<li>如果xml中定义了expand属性(boolean值), 获取并调用expand()设置.</li>
<li>ViewCompat的isLaidOut()函数返回true如果view至少经历过一次layout.</li>
<li>recycle()函数会回收typedarray, 调用只有不能再使用typearray.</li>
<li>设置elevation 阴影.</li>
<li>调用ViewCompat的setOnApplyWindowIInsetsListener()函数设置
使用window insets的策略.
策略为: 设置变量mLastInsets的值为得到的insets.然后
遍历子view, 用该insets调用每个child的dispatchApplyWindowInsets函数.</li>
<li>在layout阶段会检查子view是否设置了interpolator.</li>
</ol>
</div>
<div id="outline-container-orgheadline2" class="outline-3">
<h3 id="orgheadline2">Behavior</h3>
<div class="outline-text-3" id="text-orgheadline2">
<ol class="org-ol">
<li>scroll()函数
<ol class="org-ol">
<li>调用setAppBarTopBottomOffset()函数
<ol class="org-ol">
<li>判断当前的offset是否在合理区间
如果是, 计算新的offset值.</li>
<li>调用setTopAndBottomOffset移动view.</li>
<li>通知依赖appbarlayout的兄弟view appbarlayout的移动事件.</li>
<li>通知注册了OffsetChange Listener的listenerview的变化.
将新的offset通知给listeners.</li>
</ol></li>
</ol></li>
<li>interpolateOffset()</li>
<li>可以给appbarlayout的子view设置interpolator.</li>
<li>在onStartNestedScroll()中, 检查子view是否设置了scroll参数, 是则返回true.</li>
<li>在onNestPreScroll()中, 检查y方向移动参数是否不为0, 
如果是
<ul class="org-ul">
<li>dy&lt;0. 向下滚动, 最小高度getTotalScrollRange()的值, 该值
代表的是移动的最大的高度. 因为appbarlayout是向上移动, 所以
该值是一个负值. max也是一个负值. 
最大高度是该值加上getDownNestedPreScrollRange()的值
(当设置了ENTER_ALWAYS时该函数的返回值不为0).
向下滚动时, 其实该behavior实际没有做任何移动的动作.
移动此时min=max, 而appbar的offset一般&gt;min, 所以不满足
min&lt;=curoffset&lt;=max的判断条件.</li>
<li>dy&gt;0. 向上滚动. 最小值跟上面一样. 最大值为0.</li>
<li>调用scroll()函数. 只有向上滚动的时候这个函数才起左右.
此时将修改appbar的offsettop的值, 并将其与之前值的差值
返回.</li>
</ul></li>
<li>onNestScroll(). 该函数有四个坐标参数, 其中dxConsumed/dyConsumed
是在scroll过程中生成scroll动作的view本身消耗的距离, 然后剩下的
才通过该函数传递给appbarlayout, 以协调两个函数之间的ui动画.
<ul class="org-ul">
<li>首先判断未消耗的y方向参数是否小于0, 如果是, 则调用scroll()函数
移动appbar. 并设置mSkipNNestedPreScroll的值为true.</li>
</ul></li>
<li>在onStopNestedScroll()函数中会调用snapToChildIfNeed()
对snap标志进行检查. 如果设置该参数, 则会计算子view的位移量, 
(不是该view的top就是bottom), 然后在移动子view到新的offset.</li>
<li>如果侦测到这次scroll是一此fling动作(速度比较快), 则会调用
onNestedFling()函数, 该函数有一个参数consumed, 代表这次fling
是否已被被发出scroll动作的view消耗.
<ul class="org-ul">
<li>如果否, 则appbar调用fling()函数自己做fling动画.
对于appbar来说, 向上滚动时, consumed总是是true.所以
只对向下滚动有效.</li>
</ul></li>
<li>如果子view设置了interpolator, 计算interpolator offset.</li>
<li>如果在behavior中设置了layoutDependsOn()函数(即该函数返回true), 
则代表该behavior依附的view有依赖view, 则CoL在每次对依赖view昨晚laid out
之后, 都会对该view做layout. 如果依赖view的位置改变了, 则
会调用该view的onDependentViewChanged()函数.</li>
<li></li>
</ol>
</div>
</div>
<div id="outline-container-orgheadline4" class="outline-3">
<h3 id="orgheadline4">ScrollingViewBehavior</h3>
<div class="outline-text-3" id="text-orgheadline4">
<ol class="org-ol">
<li>updateOffset()函数, 该函数会获取依赖view的behavior,
如果依赖view是appbar, 那么会调用appbar(及behavior)的相关
函数获取offset, 然后基于appbar的offset来移动自己.</li>
<li></li>
</ol>
</div>
</div>
<div id="outline-container-orgheadline5" class="outline-3">
<h3 id="orgheadline5">ViewOffsetHelper</h3>
<div class="outline-text-3" id="text-orgheadline5">
<ul class="org-ul">
<li>getTopAndBottomOffset</li>
</ul>
</div>
</div>
</div>

<div id="outline-container-orgheadline6" class="outline-2">
<h2 id="orgheadline6">umeng和okhttp报错: okio的duplicated file</h2>
<div class="outline-text-2" id="text-orgheadline6">
<pre class="example">
packagingOptions {
    exclude 'META-INF/maven/com.squareup.okio/okio/pom.xml'
    exclude 'META-INF/maven/com.squareup.okio/okio/pom.properties'
}
</pre>
</div>
</div>
<div id="outline-container-orgheadline35" class="outline-2">
<h2 id="orgheadline35">RecyclerView&#xa0;&#xa0;&#xa0;<span class="tag"><span class="recyclerview">recyclerview</span></span></h2>
<div class="outline-text-2" id="text-orgheadline35">
</div><div id="outline-container-orgheadline7" class="outline-3">
<h3 id="orgheadline7">note</h3>
<div class="outline-text-3" id="text-orgheadline7">
<ol class="org-ol">
<li>Scrap</li>
<li>Recycle</li>
<li>Dirty</li>
<li>在RV进行layout或scroll的过程中不能修改adapter的内容,
否则会报异常.</li>
</ol>
</div>
</div>

<div id="outline-container-orgheadline8" class="outline-3">
<h3 id="orgheadline8">Adapter</h3>
<div class="outline-text-3" id="text-orgheadline8">
<ol class="org-ol">
<li>onCreateViewHolder() 
创建一个VH. 客户端实现.</li>
<li>createViewHolder(RV, type)
创建一个VH. RV内部在getViewForPosition中调用.
通过type,可以为RV创建不同的item view.</li>
<li>bindViewHolder(VH, pos)
将adapter里pos位置的数据跟一个VH绑定起来.</li>
<li>getItemId(pos)
返回adapter里pos位置的元素的id. 需要客户端实现.</li>
<li>viewAttach/viewDetach</li>
<li>adapter数据改变函数.</li>
</ol>
</div>
<div id="outline-container-orgheadline9" class="outline-4">
<h4 id="orgheadline9">note</h4>
<div class="outline-text-4" id="text-orgheadline9">
<ol class="org-ol">
<li>把stableIds设为true显示效果跟false不一样.</li>
</ol>
</div>
</div>
</div>
<div id="outline-container-orgheadline10" class="outline-3">
<h3 id="orgheadline10">ViewHolder</h3>
<div class="outline-text-3" id="text-orgheadline10">
<p>
该类用来存放view及其相关属性.
</p>
<ol class="org-ol">
<li>通过getLayoutPosition获取item在adapter的位置.</li>
<li>可以设置一个view的标志为ignore. 这样不会被回收.</li>
</ol>
</div>
</div>
<div id="outline-container-orgheadline11" class="outline-3">
<h3 id="orgheadline11">AdapterDataObserver</h3>
<div class="outline-text-3" id="text-orgheadline11">
<p>
用来监测Adapter的数据变化, 提供的API:
</p>
<ol class="org-ol">
<li>onChanged()</li>
<li>onItemRangeChanged()</li>
<li>onItemRangeInserted()</li>
<li>onItemRangeRemoved()</li>
<li>onItemRangeMoved()</li>
</ol>
</div>
</div>
<div id="outline-container-orgheadline12" class="outline-3">
<h3 id="orgheadline12">AdapterDataObservable</h3>
<div class="outline-text-3" id="text-orgheadline12">
<p>
该类继承自Observable&lt;T&gt;, 所以天然自带一个arraylist, 
该arraylist的元素类型为 AdapterDataObserver. 
该类提供了一些api, 在api的实现上, 基本都是迭代调用
arraylsit里的<a href="#orgheadline11">AdapterDataObserver</a>的对应api. 
</p>
</div>
</div>
<div id="outline-container-orgheadline13" class="outline-3">
<h3 id="orgheadline13">LayoutManager</h3>
<div class="outline-text-3" id="text-orgheadline13">
<ol class="org-ol">
<li>该类用于测量和放置RV里的子View.</li>
<li>可以在RV的xml中设置一个layoutmanager.</li>
<li></li>
</ol>
</div>
<div id="outline-container-orgheadline14" class="outline-4">
<h4 id="orgheadline14">setMeasuredDimensionFromChildren</h4>
<div class="outline-text-4" id="text-orgheadline14">
<p>
该函数用于根据RV的子view来测量RV的边界. 会遍历
所有的子view, 找到"最边上"的子view的"上下左右"边界.
然后跟onMeasure()传入的spec作比较后生成最终的width和height.
</p>

<p>
比较规则: 
</p>
<ol class="org-ol">
<li>如果mode是EXACTLY, 使用spec的size.</li>
<li>如果是AT_MOST, 选择spec的size和子view中size中的小值.</li>
</ol>
</div>
</div>
<div id="outline-container-orgheadline15" class="outline-4">
<h4 id="orgheadline15">mAutoMeasure</h4>
<div class="outline-text-4" id="text-orgheadline15">
<p>
这个变量标志measure过程由谁完成.
</p>
<ol class="org-ol">
<li>true, measure过程由RV完成.</li>
<li>false, 由LayoutManager完成.</li>
</ol>
</div>
</div>
<div id="outline-container-orgheadline16" class="outline-4">
<h4 id="orgheadline16">onLayoutChildren</h4>
<div class="outline-text-4" id="text-orgheadline16">
<p>
代码注释笔记:
</p>
<ol class="org-ol">
<li>如果mAutoMeasure为true. 该函数会被调用两次:
<ol class="org-ol">
<li>第一次确认items的位置.</li>
<li>第二次做实际的layout.</li>
</ol></li>
</ol>
</div>
</div>
</div>
<div id="outline-container-orgheadline17" class="outline-3">
<h3 id="orgheadline17">ChildHelper</h3>
<div class="outline-text-3" id="text-orgheadline17">
<ol class="org-ol">
<li>该类用于管理子view, 它使用一个bitmap来表示目前的
view, bitmap的长度表示子view的数量. 如果某个bit被
设为 <b>1</b>, 则表示该view不可见.</li>
<li>addView(index)
添加一个view, 传入的index参数是"视觉"上的要添加
的位置(从0开始), 但是因为可能存在"隐藏"的view, 所以
真实的添加位置是大于等于index的.</li>
<li><a id="orgtarget1"></a>
<ol class="org-ol">
<li>重置bucket.</li>
<li>清空mHiddenViews列表. 并对每个要清除的view调用
callback的onLeftHiddenState()函数. 这里的callback是
在RV里实现的. 他的onLeftHiddenState()接口实现为调用
<a href="#orgheadline10">ViewHolder</a>的onLeftHiddenState()函数.</li>
<li>调用callback的removeAllViews()函数. 在RV中, 这个
函数被定义为.
<ol class="org-ol">
<li>对每个子view调用dispatchChildDetached.</li>
<li>调用RV的removeAllViews().</li>
</ol></li>
</ol></li>
</ol>
</div>
</div>
<div id="outline-container-orgheadline18" class="outline-3">
<h3 id="orgheadline18">State</h3>
<div class="outline-text-3" id="text-orgheadline18">
<p>
记录RV的一些信息, 例如
</p>
<ol class="org-ol">
<li>可以被layout的item数量.
该值可能不等于adapter的size.</li>
</ol>
</div>
</div>
<div id="outline-container-orgheadline19" class="outline-3">
<h3 id="orgheadline19">LinearLayoutManager</h3>
</div>
<div id="outline-container-orgheadline20" class="outline-3">
<h3 id="orgheadline20">Recycler</h3>
<div class="outline-text-3" id="text-orgheadline20">
<ol class="org-ol">
<li>"scrapped" view值被标记了的view. 可能会被移除或复用.</li>
<li>Recycler包含两层缓存, "缓存"view和RVP, 如果缓存满的话
会将其放入到RVP中.</li>
<li><a id="orgtarget2"></a>
<ol class="org-ol">
<li>清空mAttachedScrap.</li>
<li>将mCachedViews里的元素移到RVP中.</li>
</ol></li>
</ol>
</div>
</div>
<div id="outline-container-orgheadline21" class="outline-3">
<h3 id="orgheadline21">RecycledViewPool</h3>
<div class="outline-text-3" id="text-orgheadline21">
<ol class="org-ol">
<li>提供了在多个RV之间共享view的功能.</li>
<li>如果不为RV设置一个Pool, RV会自己创建一个.</li>
</ol>
</div>
</div>
<div id="outline-container-orgheadline22" class="outline-3">
<h3 id="orgheadline22">AdapterHelper</h3>
<div class="outline-text-3" id="text-orgheadline22">
<ol class="org-ol">
<li></li>
</ol>
</div>
</div>
<div id="outline-container-orgheadline23" class="outline-3">
<h3 id="orgheadline23">UpdateOp</h3>
<div class="outline-text-3" id="text-orgheadline23">
<p>
一直操作的命令类.
</p>
</div>
</div>
<div id="outline-container-orgheadline24" class="outline-3">
<h3 id="orgheadline24">OpRecorderer</h3>
<div class="outline-text-3" id="text-orgheadline24">
<ol class="org-ol">
<li>reorderOps
操作重排序.
<ol class="org-ol">
<li>MOVE后面是REMOVE:
<ul class="org-ul">
<li>MOVE可能分两种情况: 前面的元素移动到后面, 或者
后面的元素移动到前面.</li>
<li>如果MOVE的元素最后落到了REMOVE的区间内, 则表示
这个元素最终会被REMOVE掉, 则可以将MOVE命令改为
REMOVE命令. 之前的REMOVE命令可以少remove一个元素.
如果减少之后之前的REMOVE命令要remove的数量为0, 
怎直接从这个list中把其删除即可.</li>
</ul></li>
</ol></li>
</ol>
</div>
</div>
<div id="outline-container-orgheadline25" class="outline-3">
<h3 id="orgheadline25">RecyclerViewAccessibilityDelegate</h3>
</div>
<div id="outline-container-orgheadline26" class="outline-3">
<h3 id="orgheadline26">DefaultItemAnimator</h3>
</div>
<div id="outline-container-orgheadline27" class="outline-3">
<h3 id="orgheadline27">ItemAnimator</h3>
</div>
<div id="outline-container-orgheadline28" class="outline-3">
<h3 id="orgheadline28">RV</h3>
<div class="outline-text-3" id="text-orgheadline28">
<ol class="org-ol">
<li>mTouchSlop表示多长的距离就可以认为是scroll.</li>
<li>mMinFlingVelocity和mMax&#x2026;是滑动的最大/最小速度.</li>
<li>构造函数流程:
<ol class="org-ol">
<li>设置scroll和focus配置.</li>
<li>判断SDK是不是大于等于16, 16及以上版本才支持post animation.</li>
<li>获取系统的ViewConfiguration, 通过vc获取
被认为是scrolling的一些参数. 例如初始化一个fling的
最大/最小速度.</li>
<li>设置mItemAnimator的listener为mItemAnimatorListener.
<ol class="org-ol">
<li>mItemAnimator被初始化为<a href="#orgheadline26">DefaultItemAnimator</a>对象.
DefaultItemAnimator继承自SimpleItemAnimator, 后者继承自
<a href="#orgheadline27">ItemAnimator</a>.</li>
</ol></li>
<li>初始化AdapterManager, 生成一个新的<a href="#orgheadline22">AdapterHelper</a>类.</li>
<li>初始化ChildHelper, 生成一个新的<a href="#orgheadline17">ChildHelper</a>对象.</li>
<li>获取AccessibilityMananger.</li>
<li>如果在xml里设置了layoutManager, 则创建LayoutManager.</li>
<li>创建一个NestedScrollingChildHelper实例.</li>
<li>设置上一步的helper的nested scroll为true.</li>
</ol></li>
<li>onMeasure.
<ol class="org-ol">
<li>如果mLayout为Null, 调用 defaultOnMeasure().
该函数没有设置layoutmanager的默认"测量"函数.</li>
<li>如果mLayout不为null,即为RV设置了LayoutManager.
<ol class="org-ol">
<li>如果mLayout的mAutoMeasure被设置.
(LinearLayoutManager里设置了该变量为true).
<ol class="org-ol">
<li>如果是EXACTLY, 那么设置skipMeasure为true.</li>
<li>调用mLayout的onMeasure函数.该函数就是调用defaultMeasure()函数.
该函数只会处理 EXACTLY 的mode.</li>
</ol></li>
<li>否则.</li>
</ol></li>
</ol></li>
<li>onLayout.
<ol class="org-ol">
<li>直接调用dispatchLayout().
<ol class="org-ol">
<li>如果adapter和layoutMananger有任何一个没有设置
返回.</li>
</ol></li>
</ol></li>
<li>onDraw.
调用父类的onDraw, 如果mItemDecorations不为空,
调用每个元素的onDraw.</li>
<li>setLayoutManager. 设置RV的layoutManager.
<ol class="org-ol">
<li>调用<a href="#orgtarget3">8</a>函数停止当前的scroll.</li>
<li>如果之前有layoutmanager, 调用其dispatchDetachedFromWindow()函数.</li>
<li>调用recycler的<a href="#orgtarget2">3</a>函数.</li>
<li>调用childHelper的<a href="#orgtarget1">3</a>函数.</li>
<li>将RV的mLayout设置为传入的参数.并调用其dispatchAttachedToWindow()函数.</li>
<li>调用requestLayout()函数.</li>
</ol></li>
<li><a id="orgtarget3"></a>
   停止当前的scroll. 
<ol class="org-ol">
<li>将当前的setScrollState()设置当前state为为SCROLL_STATE_IDLE.
<ol class="org-ol">
<li>调用stopScrollersInternal().
<ol class="org-ol">
<li>调用mViewFlinger的stop()函数. 该函数会调用
removeCallbacks()将mViewFlinger从RV中删除.
并调用mScroller的abortAnimation()函数.</li>
<li>如果mLayout不为null, 调用其stopSmoothScroller()函数.
(第一次初始化LM时不会走到这里.)</li>
</ol></li>
<li>调用dispatchOnScrollStateChanged()函数.
<ol class="org-ol">
<li>如果mLayout不为null,调用其onScrollStateChanged()函数.</li>
<li>调用onScrollStateChanged()函数, 这个函数在RV中为空, 
RV的子view可以重写这个函数.</li>
<li>如果有scrollListener, 调用其`onScrollStateChanged()</li>
<li>如果mScrollListeners不为空, 对每个listener调用onScrollStateChanged()</li>
</ol></li>
</ol></li>
</ol></li>
<li>setAdapter. 设置Adapter.
<ol class="org-ol">
<li>调用setLayoutFrozen(), 参数为false. 
即重新enable layout跟scroll.
<ol class="org-ol">
<li>调用setAdapterInternal()设置adapter.
<ol class="org-ol">
<li>如果之前有adpater, 调用相关的unregister函数.</li>
<li>如果与之前的不兼容, 或者需要recycle view.
<ol class="org-ol">
<li>如果有animator, 调用endAnimation.</li>
<li>如果layoutManager不为null, 调用其相关的remove函数.</li>
<li>调用recycler的clear函数.</li>
</ol></li>
<li>调用新adapter的注册函数.</li>
<li>调用layoutmanager的onAdapterChange函数.</li>
<li>调用markKnowViewsInvalid()函数标记所有view invalid.</li>
</ol></li>
</ol></li>
</ol></li>
<li>setHasFixedSize()设为true表示RV的size不会受adapter内容的影响.</li>
<li></li>
</ol>
</div>
</div>
<div id="outline-container-orgheadline29" class="outline-3">
<h3 id="orgheadline29">ItemDecoration</h3>
</div>
<div id="outline-container-orgheadline33" class="outline-3">
<h3 id="orgheadline33">Home页"卡片"源码学习笔记</h3>
<div class="outline-text-3" id="text-orgheadline33">
</div><div id="outline-container-orgheadline31" class="outline-4">
<h4 id="orgheadline31">自定义控件TwoWayView</h4>
<div class="outline-text-4" id="text-orgheadline31">
<ol class="org-ol">
<li>继承自RecyclerView.</li>
<li>构造函数默认使用了<a href="#orgheadline28">RV</a>的构造函数.</li>
<li>重写setLayoutManager()函数, 必须为<a href="#orgheadline30">TwoWayLayoutManager</a>的子类.</li>
</ol>
</div>
</div>
<div id="outline-container-orgheadline30" class="outline-4">
<h4 id="orgheadline30">TwoWayLayoutManager</h4>
<div class="outline-text-4" id="text-orgheadline30">
<ol class="org-ol">
<li>继承自LayoutManager.</li>
<li>可以设置orientation, 即横还是竖.</li>
<li>可以设置direction. 即从前向后还是从后向前.</li>
<li><p>
getTotalSpace()
获取RV的"有效空间", 有效空间指:
</p>
<ol class="org-ol">
<li>高度 - paddingTop - paddingBottom. (vertical)</li>
<li>宽度- pR - pL (horizontal)</li>
</ol>
<p>
LayoutManager提供了一系列的API来获取RV的参数.
</p></li>
<li>getChildStart(child)
获取child的"开始"位置. 这个位置包含的内容部分: 
开始margin &#x2013;&gt; 修饰 &#x2013;&gt; child的实际开始位置(getTop()返回值)</li>
<li>recycleChildrenFromStart()
当RV向底部滚动时, "前面"的view有可能就不在"视线"之内,
这时候可以调用该函数移除"前面"的view. 移除原则:
<ol class="org-ol">
<li>记录在RV的paddingTop之前的子view的数量.</li>
<li>对所有的子view调用removeAndRecyleView()函数.</li>
<li>每做一次第2步就更新一下mLayoutStart值,该值用于记录layout的起始位置.</li>
</ol></li>
</ol>
</div>
</div>
<div id="outline-container-orgheadline32" class="outline-4">
<h4 id="orgheadline32">DividerItemDecoration</h4>
<div class="outline-text-4" id="text-orgheadline32">
<p>
该类继承自<a href="#orgheadline29">ItemDecoration</a>, 用于修饰每个view. 
支持水平和竖直方向的分割drawable设置.
</p>
<ol class="org-ol">
<li>该类实现了onDrawOver(), 用于在item之后draw "修饰".
<ol class="org-ol">
<li></li>
</ol></li>
</ol>
</div>
</div>
</div>
<div id="outline-container-orgheadline34" class="outline-3">
<h3 id="orgheadline34">文章阅读笔记</h3>
<div class="outline-text-3" id="text-orgheadline34">
<ol class="org-ol">
<li><a href="http://www.birbit.com/recyclerview-animations-part-1-how-animations-work/">RV动画详解</a>
<ol class="org-ol">
<li>LayoutTransition是Framework用于进行动画转化的.由于根据
layout之前和之后的状态进行动画. 但不适用于RV.</li>
<li>prelayout阶段, RV会让layoutManager layout之前的状态, 但是
会提供一些信息. 请求类似这样: layout, 但是, C已经被删除.
这样, layoutmanager会layout一个新的view(例如G)来补充C留下的空间.
但是:
<ol class="org-ol">
<li>RV仍然表现的好想C仍然存在于adapter. 例如调用getViewForPosition(2)
仍然返回C.</li>
</ol></li>
<li>postLayout阶段. layoutmanager重新layout, 这时候,'C'不存在.
getViewForPosition()返回正确的</li>
<li>每次调用layoutManager的onLayoutChildren()函数. 所有的view都会
暂时detach并重新layout, 但是由于未变化的view其"测量数据"不变, 所以
不会被重新测量. 这样使整个layout并不复杂.</li>
<li>LinearLayout在postLayout的完成阶段, layoutManager会调用getScrapList()函数获取
没有被layout但仍然在adapter中的数据, 然后layout这些.</li>
<li>可以在onLayoutChildren()里调用 addDisappearing() 函数来告知RV这些view
可以在动画完成之后删除掉. RV也会把该view加入到 hidden 列表中.
这样它就不在layoutmanager的children中了.</li>
<li>当child被layoutmananger移除时, RV仍然将其保留, 但是
对layoutmanager隐藏.
<ol class="org-ol">
<li>当LM调用其getChildCount()函数时, RV返回的是其children
数量减去隐藏的children数量.</li>
<li>当LM调用getChildAt()函数时, RV也会跳过隐藏的view,返回
正确的child.</li>
<li>当LM调用addView(view,index), RV同样也会插入到正确的位置.</li>
<li>动画完成时, RV会移除并回收隐藏的view.</li>
</ol></li>
</ol></li>
</ol>
</div>
</div>
</div>
<div id="outline-container-orgheadline40" class="outline-2">
<h2 id="orgheadline40">View</h2>
<div class="outline-text-2" id="text-orgheadline40">
</div><div id="outline-container-orgheadline36" class="outline-3">
<h3 id="orgheadline36">view的坐标系</h3>
<div class="outline-text-3" id="text-orgheadline36">
<ol class="org-ol">
<li>left, right, top, bottom</li>
<li>x, y, translationX, translationY.
x = translationX + left; y = top + translationY.</li>
<li>scrollX, scrollY.
view的左上边缘和view"内容"的左上边缘的距离.
scrollX &gt; 0, view的内容在其位置的左边. &lt; 0, view的内容在其位置的右边.</li>
</ol>
</div>
</div>
<div id="outline-container-orgheadline37" class="outline-3">
<h3 id="orgheadline37">在竖直方向移动view&#xa0;&#xa0;&#xa0;<span class="tag"><span class="view">view</span></span></h3>
<div class="outline-text-3" id="text-orgheadline37">
<p>
offsetTopAndBottom(offset),offset&gt;0, 向下移动. 否则向上移动.
</p>
</div>
</div>
<div id="outline-container-orgheadline38" class="outline-3">
<h3 id="orgheadline38">给当前window添加view:&#xa0;&#xa0;&#xa0;<span class="tag"><span class="view">view</span></span></h3>
<div class="outline-text-3" id="text-orgheadline38">
<p>
getWindow().getDecorView().addView(); 会添加到最上层.
</p>
</div>
</div>
<div id="outline-container-orgheadline39" class="outline-3">
<h3 id="orgheadline39">设置view在不同状态下的UI展示&#xa0;&#xa0;&#xa0;<span class="tag"><span class="view">view</span></span></h3>
<div class="outline-text-3" id="text-orgheadline39">
<p>
  例如设置在点击或可用状态下的背景图片，背景颜色等。
通过设置一个xml文件来实现，使用 <b>selector</b> 标签来设置
在不同状态下的UI展示。然后在View的设置中引用这个drawable。
</p>
<div class="org-src-container">

<pre class="src src-xml">&lt;?<span style="color: #F0DFAF; font-weight: bold;">xml</span> <span style="color: #DFAF8F;">version</span>=<span style="color: #CC9393;">"</span><span style="color: #CC9393;">1.0</span><span style="color: #CC9393;">"</span> <span style="color: #DFAF8F;">encoding</span>=<span style="color: #CC9393;">"</span><span style="color: #CC9393;">utf-8</span><span style="color: #CC9393;">"</span>?&gt;
&lt;<span style="color: #93E0E3;">selector</span> <span style="color: #DCDCCC; font-weight: bold;">xmlns</span>:<span style="color: #DFAF8F;">android</span>=<span style="color: #CC9393;">"</span><span style="color: #CC9393;">http://schemas.android.com/apk/res/android</span><span style="color: #CC9393;">"</span>&gt;
    &lt;<span style="color: #93E0E3;">item</span> <span style="color: #DCDCCC; font-weight: bold;">android</span>:<span style="color: #DFAF8F;">drawable</span>=<span style="color: #CC9393;">"</span><span style="color: #CC9393;">@drawable/ic_apk_delete_clicked</span><span style="color: #CC9393;">"</span> <span style="color: #DCDCCC; font-weight: bold;">android</span>:<span style="color: #DFAF8F;">state_selected</span>=<span style="color: #CC9393;">"</span><span style="color: #CC9393;">true</span><span style="color: #CC9393;">"</span>/&gt;
    &lt;<span style="color: #93E0E3;">item</span> <span style="color: #DCDCCC; font-weight: bold;">android</span>:<span style="color: #DFAF8F;">drawable</span>=<span style="color: #CC9393;">"</span><span style="color: #CC9393;">@drawable/ic_apk_delete_clicked</span><span style="color: #CC9393;">"</span> <span style="color: #DCDCCC; font-weight: bold;">android</span>:<span style="color: #DFAF8F;">state_focused</span>=<span style="color: #CC9393;">"</span><span style="color: #CC9393;">true</span><span style="color: #CC9393;">"</span>/&gt;
    &lt;<span style="color: #93E0E3;">item</span> <span style="color: #DCDCCC; font-weight: bold;">android</span>:<span style="color: #DFAF8F;">drawable</span>=<span style="color: #CC9393;">"</span><span style="color: #CC9393;">@drawable/ic_apk_delete_clicked</span><span style="color: #CC9393;">"</span> <span style="color: #DCDCCC; font-weight: bold;">android</span>:<span style="color: #DFAF8F;">state_pressed</span>=<span style="color: #CC9393;">"</span><span style="color: #CC9393;">true</span><span style="color: #CC9393;">"</span>/&gt;
    &lt;<span style="color: #93E0E3;">item</span> <span style="color: #DCDCCC; font-weight: bold;">android</span>:<span style="color: #DFAF8F;">drawable</span>=<span style="color: #CC9393;">"</span><span style="color: #CC9393;">@drawable/ic_apk_delete_nor</span><span style="color: #CC9393;">"</span>/&gt;
&lt;/<span style="color: #93E0E3;">selector</span>&gt;

//layout file
    &lt;<span style="color: #93E0E3;">ImageView</span>
        ...
        android:src="@drawable/bg_apk_delete_selector"
        ...
        /&gt;
</pre>
</div>
</div>
</div>
</div>
<div id="outline-container-orgheadline41" class="outline-2">
<h2 id="orgheadline41">事件分发</h2>
<div class="outline-text-2" id="text-orgheadline41">
<ol class="org-ol">
<li>当一个事件过来时, view 的 dispatchTouchEvent(ev)函数会
调用, 该函数做以下判断:
<ol class="org-ol">
<li>调用viewgroup 的 onInterceptTouchEvent(ev). 如果返回true, 调用
onTouchEvent(ev). 否则, 调用子view的dispatchTouchEvent(ev).
重复这个过程.</li>
</ol></li>
<li>如果设置了OnTouchListener, 那么先去判断OnTouchListener是否消耗
事件, 如果是则其消耗. 否则再调用onTouchEvent.</li>
<li>事件传递顺序: Activity -&gt; Window -&gt; View.
收到事件会调用Activity的dispatchTouchEvent():
<ol class="org-ol">
<li>分发给Window, 通过window传给所有的子view. 即函数 superDispatchTouchEvent().
<ol class="org-ol">
<li>调用decorView的superDispatchTouchEvent(). decorView是layout的顶层view.
通过 <code>((ViewGroup)decorView.findViewById(android.R.id.content)).getChildAt(0)</code> 
可以获得activity通过setContentView()所设置的view.</li>
</ol></li>
<li>如果没有view处理事件, 调用activity的onTouchEvent.</li>
</ol></li>
<li>如果子view的 onTouchEvent()返回false, 则会调用父view的onTouchEvent.
直到传给Activity的onTouchEvent().</li>
<li>如果onTouchEvent()对于ACTION_DOWN返回false, 那么后续所有事件都不会再
传递给他. 而是交给父view.</li>
<li>view没有onInterceptTouchEvent()方法, 事件过来直接调用onTouchEvent.</li>
</ol>
</div>
</div>
<div id="outline-container-orgheadline42" class="outline-2">
<h2 id="orgheadline42">数据库&#xa0;&#xa0;&#xa0;<span class="tag"><span class="sqlite">sqlite</span></span></h2>
<div class="outline-text-2" id="text-orgheadline42">
<ol class="org-ol">
<li>在 android 中使用 SQLiteOpenHelper 实现数据库的创建和版本管理.</li>
<li>数据库升级需要将升级版本号传递给 SQLiteHelper,  这样会触发对该类的
onUpgrade()函数的调用</li>
</ol>
</div>
</div>
<div id="outline-container-orgheadline43" class="outline-2">
<h2 id="orgheadline43">ormlite库操作数据库&#xa0;&#xa0;&#xa0;<span class="tag"><span class="sqlite">sqlite</span></span></h2>
<div class="outline-text-2" id="text-orgheadline43">
<p>
ormlite 对比 android 自带数据库 api 的好处是可以基于类创建一个表, 及表中数据和类的映射.
</p>

<p>
常见用法:
</p>
<ol class="org-ol">
<li>实现一个类 继承 OrmLiteSqliteOpenHelper(后者继承自 SQLiteOpenHelper), 
实现onCreate 和 onUpgrade 逻辑.</li>
<li>在调用 Orgmlite 的 api 时,传入这个 子类的调用.</li>
<li>在想要建表的类上,用注解  @DatabaseTable 和 @DatabaseField 类设置表的
名称和表项.</li>
<li>通过 Ormlite 的 api 获取上面类的一个 DAO(Ormlite 会给每个类创建一个 DAO 实例)
,然后使用 DAO 来进行 CRUD 操作.</li>
</ol>
</div>
</div>
<div id="outline-container-orgheadline52" class="outline-2">
<h2 id="orgheadline52">app 常用库</h2>
<div class="outline-text-2" id="text-orgheadline52">
</div><div id="outline-container-orgheadline44" class="outline-3">
<h3 id="orgheadline44">gson操作json字符串</h3>
</div>
<div id="outline-container-orgheadline45" class="outline-3">
<h3 id="orgheadline45">okhttp进行网络操作</h3>
</div>
<div id="outline-container-orgheadline46" class="outline-3">
<h3 id="orgheadline46">fresco网络图片加载</h3>
</div>
<div id="outline-container-orgheadline47" class="outline-3">
<h3 id="orgheadline47">umeng进行统计分析和反馈</h3>
</div>
<div id="outline-container-orgheadline48" class="outline-3">
<h3 id="orgheadline48">sharesdk进行统一分享</h3>
</div>
<div id="outline-container-orgheadline49" class="outline-3">
<h3 id="orgheadline49">阿里聚安全进行加密</h3>
</div>
<div id="outline-container-orgheadline50" class="outline-3">
<h3 id="orgheadline50">广点通和百度的广告进行广告投放</h3>
</div>
<div id="outline-container-orgheadline51" class="outline-3">
<h3 id="orgheadline51">小米push和umengpush来推送消息</h3>
</div>
</div>
<div id="outline-container-orgheadline53" class="outline-2">
<h2 id="orgheadline53">设置多进程</h2>
<div class="outline-text-2" id="text-orgheadline53">
<ol class="org-ol">
<li>方法: 设置 taskAffinity</li>
<li>保持锁屏占用的资源变少. 避免被系统应用杀死.</li>
<li>加快应用的相应速度.</li>
</ol>
</div>
</div>
<div id="outline-container-orgheadline54" class="outline-2">
<h2 id="orgheadline54">四种启动模式</h2>
<div class="outline-text-2" id="text-orgheadline54">
<ol class="org-ol">
<li>standard: 标准模式, 建立一个新的栈放入task中, 什么都不判断.</li>
<li>singleTop: 如果当前页面已经是栈顶, 则不新建, 否则新建.</li>
<li>singleTask: 如果当前页面不是栈顶, 弹出所有.</li>
<li>singleInstance: 给当前页面建立一个全新的task, 只有一个实例.</li>
</ol>
</div>
</div>
<div id="outline-container-orgheadline55" class="outline-2">
<h2 id="orgheadline55">让activity支持scheme</h2>
<div class="outline-text-2" id="text-orgheadline55">
<p>
通过在activity节点中设置 intent-filter 节点. 里面的内容
</p>
<ol class="org-ol">
<li>设置scheme格式, 包括 host 和 scheme</li>
<li>设置action为 VIEW.</li>
<li>设置category为 DEFAULT. 
也可以设置browsable, 这样可以通过浏览器打开activity.</li>
</ol>
</div>
</div>
<div id="outline-container-orgheadline56" class="outline-2">
<h2 id="orgheadline56">home页蒙版指导图</h2>
<div class="outline-text-2" id="text-orgheadline56">
<ol class="org-ol">
<li>通过在MainFragment里添加了一个MainFragmentManager.</li>
<li>在mainfragmet的oncreate里调用该manager的showGuide()函数.</li>
<li>showGuide()函数一次检查是否需要显示权限, 如果需要的话, 
依次显示, 所以这几个view是层层网上叠加的.</li>
</ol>
</div>
</div>
<div id="outline-container-orgheadline57" class="outline-2">
<h2 id="orgheadline57">在别人的页面(例如系统页面)显示指导</h2>
<div class="outline-text-2" id="text-orgheadline57">
<p>
可以有两种方法:
</p>
<ol class="org-ol">
<li>先把别人页面调起, 同时设置一个 postDelay 操作推迟一段时间后再启动一个 activity.
activity 的背景可以设置为透明, 这样方便看到下面的内容.</li>
<li>在一个 service 里,通过 WindowManager 给当前的 window(其他页面) 添加 view.</li>
</ol>
</div>
</div>
<div id="outline-container-orgheadline58" class="outline-2">
<h2 id="orgheadline58">设置应用可以获取通知权限保持应用不被杀死</h2>
</div>
<div id="outline-container-orgheadline59" class="outline-2">
<h2 id="orgheadline59">通常可以放在Application类的动作</h2>
<div class="outline-text-2" id="text-orgheadline59">
<ol class="org-ol">
<li>设置自定义异常捕获类.</li>
<li>统计, 注册, 反馈, 更新.</li>
<li>数据库.</li>
</ol>
</div>
</div>
<div id="outline-container-orgheadline62" class="outline-2">
<h2 id="orgheadline62">可替换库对比</h2>
<div class="outline-text-2" id="text-orgheadline62">
</div><div id="outline-container-orgheadline60" class="outline-3">
<h3 id="orgheadline60">recyclerView VS listView</h3>
<div class="outline-text-3" id="text-orgheadline60">
<p>
使用RecyclerView的一些好处:
</p>
<ol class="org-ol">
<li>支持添加/删除的动画</li>
<li>支持item的装饰</li>
<li>支持layoutManager实现多重布局.</li>
</ol>

<p>
<a href="http://www.truiton.com/2015/03/android-recyclerview-vs-listview-comparison/">这篇文章</a> 比较了这两个控件, 主要包括:
总体来说就是RecyclerView提供了更多的客制化的功能, 尤其是对于
复杂的布局或者list实现. 
具体来说:
</p>
<ol class="org-ol">
<li>RecyclerView强制使用ViewHolder, 其ViewHolder与Adapter绑定. 
因为ListView并没有强制使用ViewHolder,如果不用时, 查找View会变得
麻烦, 可能导致性能下降.</li>
<li>RecyclerView通过LayoutManager的方式提供布局的多样化.
ListView默认只支持竖直方向(可以通过重写代码实现水平方向, 但是麻烦).</li>
<li>ItemDecoration 支持对每个项目进行修饰.</li>
</ol>
</div>
</div>
<div id="outline-container-orgheadline61" class="outline-3">
<h3 id="orgheadline61">startService VS bindService&#xa0;&#xa0;&#xa0;<span class="tag"><span class="service">service</span></span></h3>
<div class="outline-text-3" id="text-orgheadline61">
<p>
<a href="http://codetheory.in/understanding-android-started-bound-services/">http://codetheory.in/understanding-android-started-bound-services/</a>
</p>
<ol class="org-ol">
<li>如果需要和service进行交互,可以使用bindService.</li>
<li>startService的service可以一直运行, 即使创建他的组件挂掉.
而bindService不行, 跟组件的生命周期一样.</li>
</ol>
</div>
</div>
</div>
<div id="outline-container-orgheadline65" class="outline-2">
<h2 id="orgheadline65">thread with looper and handler&#xa0;&#xa0;&#xa0;<span class="tag"><span class="handler">handler</span></span></h2>
<div class="outline-text-2" id="text-orgheadline65">
</div><div id="outline-container-orgheadline63" class="outline-3">
<h3 id="orgheadline63">在其他线程中创建handler</h3>
<div class="outline-text-3" id="text-orgheadline63">
<ol class="org-ol">
<li>使用Looper.prepare()给该thread创建一个looper "线程变量"</li>
<li>创建一个handler.</li>
<li>调用Looper.loop()函数使线程陷入等待事件状态.</li>
</ol>
</div>
</div>
<div id="outline-container-orgheadline64" class="outline-3">
<h3 id="orgheadline64">在其他线程中使用UI线程的looper.</h3>
<div class="outline-text-3" id="text-orgheadline64">
<ol class="org-ol">
<li>通过Looper.getMainLooper()获取UI线程的looper.
然后使用该Looper创建一个handler.</li>
<li>使用handler.post()交给主线程执行.如果主线程有Handler, 
会调用handler的handleMessage.</li>
<li>如果是线程的handler没有覆盖handleMessage()方法.
那么调用sendMessage方法默认不处理. 只有重写该方法
才会处理.</li>
<li>调用loop()函数之后就进入死循环, 后面的代码都不会调用到.</li>
</ol>
</div>
</div>
</div>
<div id="outline-container-orgheadline66" class="outline-2">
<h2 id="orgheadline66">how to resolve ANR</h2>
<div class="outline-text-2" id="text-orgheadline66">
<p>
<a href="http://www.programering.com/a/MTMyEDMwATI.html">http://www.programering.com/a/MTMyEDMwATI.html</a>
</p>
<ol class="org-ol">
<li>first analysis log</li>
<li>from the trace.txt file call stack.</li>
<li>see code</li>
<li>check the ANR origin(iowait?block?memoryleak?)</li>
</ol>
</div>
</div>
<div id="outline-container-orgheadline68" class="outline-2">
<h2 id="orgheadline68">touch事件传递机制</h2>
<div class="outline-text-2" id="text-orgheadline68">
</div><div id="outline-container-orgheadline67" class="outline-3">
<h3 id="orgheadline67">实验</h3>
<div class="outline-text-3" id="text-orgheadline67">
<p>
自定义一个relativelayout和view, layout结构是两个relativelayout A/B, 里面放一个view C.
</p>
<ol class="org-ol">
<li>默认点击行为. onInterceptTouchEvent()都返回false, onTouchEvent()都返回false.
ACTIONDOWN的传递过程: 
<ol class="org-ol">
<li>A:onInterceptTouchEvent-&gt;B:onInterceptTouchEvent-&gt;C:onTouchEvent-&gt;B:onTouchEvent-&gt;A:onTouchEvent</li>
<li>MOVE和UP的动作都不会被收到.</li>
</ol></li>
<li>A拦截DOWN和MOVE. onTouchEvent中DOWN和MOVE都返回true.
A的onInterceptTouchEvent()只有在DOWN时被调用. 后续ACTION不会调用. 
所有ACTION都会传递给onTouchEvent().</li>
<li>A拦截DOWN, 但是onTouchEvent返回false.
后续所有的事件都不会传递给ABC.</li>
<li>A不拦截DOWN, 但是在onTouchEvent()里消耗DOWN(BC都是false, 所以会回传到A的onTouchEvent).
这样会导致所有的MOVE和UP都会再传递给A.</li>
<li>A不拦截DOWN, 拦截MOVE. B拦截DOWN.
<ol class="org-ol">
<li>DOWN发生时AB的intercept都会被调用.</li>
<li>第一次MOVE时只调用A的intercept. 但是会转化成CANCEL传给B的onTouchEvent.</li>
<li>后续的MOVE和UP都只传给A.</li>
</ol></li>
<li>A拦截UP, B拦截MOVE, C拦截DOWN.
<ol class="org-ol">
<li>DOWN会传给C的onTouchEvent.</li>
<li>第一次MOVE最终会变成CANCEL, 传给C.</li>
<li>后续的MOVE都会先经过A的onInterceptTouchEvent, 然后传给B的onTouchEvent.</li>
<li>UP会变成CANCEL传给B的onTouchEvent.</li>
</ol></li>
</ol>
</div>
</div>
</div>
<div id="outline-container-orgheadline69" class="outline-2">
<h2 id="orgheadline69">使用 Resource 类来获取 resource 资源</h2>
<div class="outline-text-2" id="text-orgheadline69">
<p>
context 的 getResource 会返回一个 Resource 类, 使用该类可以获取定义的资源文件,
例如 String,Drawable,Integer 等等.
</p>
</div>
</div>
<div id="outline-container-orgheadline70" class="outline-2">
<h2 id="orgheadline70">辅助功能</h2>
<div class="outline-text-2" id="text-orgheadline70">
<p>
通过开启辅助功能权限(也称作无障碍)可以模拟用户的点击,滚动等一切行为,
同时可以监控屏幕的变化, 实现一些"自动化"操作. 比如设置自动设置一些权限.
</p>
</div>
<div id="outline-container-orgheadline71" class="outline-3">
<h3 id="orgheadline71">开启步骤</h3>
<div class="outline-text-3" id="text-orgheadline71">
<ol class="org-ol">
<li>实现一个类继承自AccessibilityService类.</li>
<li>在AndroidManifest.xml里注册这个service, 并需要做如下配置
<ol class="org-ol">
<li>为该service增加permission "android.permission.BIND_ACCESSIBILITY_SERVICE"</li>
<li>为该service设置filter. action为android.accessibilityservice.AccessibilityService.
这样权限开启后才可以获得回调.</li>
<li><p>
如果需要在xml里(也可以在代码里)对service进行配置, 比如要过滤屏幕事件.则需要增加一个meta-data.
</p>
<pre class="example">
&lt;meta-data
    android:name="android.accessibilityservice"
    android:resource="@xml/keyguard_accessibility_service_config"/&gt;
</pre></li>
</ol></li>
</ol>

<p>
通过上面的设置, 就可以在辅助功能设置页面看到app的项,勾选就可以, 或者在程序里直接
跳转到该页面, 使用如下代码:
</p>
<pre class="example">
Intent intent = new Intent(Settings.ACTION_ACCESSIBILITY_SETTINGS);
</pre>
</div>
</div>
<div id="outline-container-orgheadline72" class="outline-3">
<h3 id="orgheadline72">自动控制逻辑</h3>
<div class="outline-text-3" id="text-orgheadline72">
<ol class="org-ol">
<li>当用户在上一步中把权限开启后, 自定义的Service的onServiceConnected()函数
会被调用. 可以在这一步里进行配置. 或者如上一步所述在xml里配置.
并可以由此进行设置操作.</li>
<li>当有事件发生时, 例如窗口变化, 点击等, 会回调 onAccessibilityEvent()函数.
并传入事件.</li>
</ol>
</div>
</div>
</div>
<div id="outline-container-orgheadline73" class="outline-2">
<h2 id="orgheadline73">系统的"最近任务"中不现实activity</h2>
<div class="outline-text-2" id="text-orgheadline73">
<p>
可以在Actvivity的配置中加入 <code>excludeFromRecents</code>, 
或者Intent中设置相应的FLAG.
</p>
</div>
</div>
<div id="outline-container-orgheadline74" class="outline-2">
<h2 id="orgheadline74">打开"最近任务"窗口</h2>
<div class="outline-text-2" id="text-orgheadline74">
<pre class="example">
private static void openRecentApps() {
    try {
        Class serviceManagerClass = Class.forName("android.os.ServiceManager");
        Method getService = serviceManagerClass.getMethod("getService", String.class);
        IBinder retbinder = (IBinder) getService.invoke(serviceManagerClass, "statusbar");
        Class statusBarClass = Class.forName(retbinder.getInterfaceDescriptor());
        Object statusBarObject = statusBarClass.getClasses()[0].getMethod("asInterface", IBinder.class).invoke(null, new Object[] { retbinder });
        Method clearAll = statusBarClass.getMethod("toggleRecentApps");
        clearAll.setAccessible(true);
        clearAll.invoke(statusBarObject);
    } catch (Exception e) {
        Log.d("Licc","Exception "+e.getMessage());
    }
}
</pre>
</div>
</div>
<div id="outline-container-orgheadline76" class="outline-2">
<h2 id="orgheadline76">不同机型特殊配置</h2>
<div class="outline-text-2" id="text-orgheadline76">
</div><div id="outline-container-orgheadline75" class="outline-3">
<h3 id="orgheadline75">判断是否为小米及获取小米版本</h3>
<div class="outline-text-3" id="text-orgheadline75">
<p>
通过反射 <code>android.os.SystemProperties</code> 这个类, 调用其
get()函数, 来获取属性"ro.miui.ui.version.name"的值.
</p>

<p>
通过Build.java的BRAND变量来获取品牌名称判断是否为xiaomi.
</p>
<div class="org-src-container">

<pre class="src src-java"><span style="color: #F0DFAF; font-weight: bold;">public</span> <span style="color: #F0DFAF; font-weight: bold;">static</span> <span style="color: #7CB8BB;">int</span> <span style="color: #93E0E3;">getMIUIVersion</span>() {
    <span style="color: #7CB8BB;">int</span> <span style="color: #DFAF8F;">versionName</span> = UNKNOWN;
    <span style="color: #F0DFAF; font-weight: bold;">try</span> {
        <span style="color: #7CB8BB;">Class</span>&lt;?&gt; <span style="color: #DFAF8F;">classType</span> = Class.forName(<span style="color: #CC9393;">"android.os.SystemProperties"</span>);
        <span style="color: #7CB8BB;">Method</span> <span style="color: #DFAF8F;">getStringMethod</span> = classType.getDeclaredMethod(<span style="color: #CC9393;">"get"</span>, String.<span style="color: #F0DFAF; font-weight: bold;">class</span>, String.<span style="color: #F0DFAF; font-weight: bold;">class</span>);
        <span style="color: #7CB8BB;">String</span> <span style="color: #DFAF8F;">version</span> = (<span style="color: #7CB8BB;">String</span>) getStringMethod.invoke(classType, KEY_MIUI_VERSION_NAME, <span style="color: #CC9393;">""</span>);
        <span style="color: #F0DFAF; font-weight: bold;">if</span> (<span style="color: #CC9393;">"v5"</span>.equalsIgnoreCase(version)) {
            versionName = V5;
        } <span style="color: #F0DFAF; font-weight: bold;">else</span> <span style="color: #F0DFAF; font-weight: bold;">if</span> (<span style="color: #CC9393;">"v6"</span>.equalsIgnoreCase(version)) {
            versionName = V6;
        } <span style="color: #F0DFAF; font-weight: bold;">else</span> <span style="color: #F0DFAF; font-weight: bold;">if</span> (<span style="color: #CC9393;">"v7"</span>.equalsIgnoreCase(version)) {
            versionName = V7;
        }
    } <span style="color: #F0DFAF; font-weight: bold;">catch</span> (<span style="color: #7CB8BB;">Exception</span> <span style="color: #DFAF8F;">e</span>) {
    }
    <span style="color: #F0DFAF; font-weight: bold;">return</span> versionName;
}

<span style="color: #9FC59F;">/** The consumer-visible brand with which the product/hardware will be associated, if any. */</span>
<span style="color: #F0DFAF; font-weight: bold;">public</span> <span style="color: #F0DFAF; font-weight: bold;">static</span> <span style="color: #F0DFAF; font-weight: bold;">final</span> <span style="color: #7CB8BB;">String</span> <span style="color: #DFAF8F;">BRAND</span> = getString(<span style="color: #CC9393;">"ro.product.brand"</span>);
</pre>
</div>
</div>
</div>
</div>
<div id="outline-container-orgheadline77" class="outline-2">
<h2 id="orgheadline77">获取当前正在运行的应用&#xa0;&#xa0;&#xa0;<span class="tag"><span class="system">system</span></span></h2>
<div class="outline-text-2" id="text-orgheadline77">
<p>
CH在实现中从三个地方取数据, 因为使用的API都说系统级的api,
在官方文档中明确支出这些api获取的数据是不可靠的, 
所以多试几个以保证正确率.
</p>
</div>
<div id="outline-container-orgheadline78" class="outline-3">
<h3 id="orgheadline78">getRunningAppProcess()</h3>
<div class="outline-text-3" id="text-orgheadline78">
<p>
调用了ActivityManager的getRunningAppProcess()函数.获取
RunningAppProcessInfo的一个list.
</p>

<p>
<b>注</b>: 在 L 及其以后的版本中, 首先会调用该方法, 观察系统的返回值,
如果系统返回的值为 null 或只包含 CH 的信息, 那么会设置一个 flag,
告知后面的程序需要打开下一步的 UsageStat 权限.
</p>
</div>
</div>
<div id="outline-container-orgheadline79" class="outline-3">
<h3 id="orgheadline79">queryUsageStats()&#xa0;&#xa0;&#xa0;<span class="tag"><span class="stat">stat</span></span></h3>
<div class="outline-text-3" id="text-orgheadline79">
<p>
调用了UsageStatManager的queryUsageStats()函数,
该函数返回UsageStats的一个list. UsageStatManager需要在权限中
申请 <code>android.permission.PACKAGE_USAGE_STATS</code>, 并需要用户
在手机中授权才可以使用.
</p>

<p>
<b>注</b>:  可以通过 PackageManager 的 queryIntentActivities()  函数来查询是否有
响应  "android.settings.USAGE_ACCESS_SETTINGS" 这个 action 的 activity
 来判断能否打开设置这个权限的页面.
</p>
</div>
</div>
<div id="outline-container-orgheadline80" class="outline-3">
<h3 id="orgheadline80">getRunningTasks()</h3>
<div class="outline-text-3" id="text-orgheadline80">
<p>
调用了 ActivityManager 的 getRunningTasks() 函数, 该函数返回正在运行
的 Task, 该函数 L 版本之后被抛弃.
</p>
</div>
</div>
</div>
<div id="outline-container-orgheadline81" class="outline-2">
<h2 id="orgheadline81">使用 native 程序保持进程不死</h2>
<div class="outline-text-2" id="text-orgheadline81">
<p>
 CH 的思路是 app 开启的时候通过 jni 来启动一个 native 程序
每次 app 启动的时候,都会去检查这个程序进程是否还在, 如果不在就启动一下. 
</p>

<p>
而这个 native 的进程会周期性的检查 app 的进程目录(/proc/pid)是否存在,
如果发现不存在, 就会执行系统命令 "am" 发送 intent 来启动 Service.
</p>
</div>
</div>
<div id="outline-container-orgheadline82" class="outline-2">
<h2 id="orgheadline82">版本更新</h2>
<div class="outline-text-2" id="text-orgheadline82">
<p>
一般的版本更新分为两种情况:
</p>
<ol class="org-ol">
<li>强制更新, 每次启动 app 都弹出更新提示, 不更新进不去.</li>
<li>非强制更新, 用户可以选择取消更新.</li>
</ol>

<p>
更新同时也分为"免流量"或"需要流量"更新, "省流量"的伎俩就是在
 wifi 环境下偷偷把 apk 包下载下来,然后提示用户安装. "需要流量"
则是在用户确认之后再下载. "需要流量"一般是在移动网络环境下使用.
只要在 wifi 下测到有新版本就偷偷下载. 
</p>

<p>
apk包下载中的一些知识:
</p>
<ol class="org-ol">
<li>何时去服务器检验是否有新包?
可以通过下载一个配置文件来获取服务器最新包的所有信息.
然后通过当前包的版本信息与配置文件做对比.</li>
<li>下载下来的包校验.
在配置文件中返回新包的 MD5值, 把 apk 下载之后计算新包的 MD5.
然后做对比.</li>
</ol>
</div>
</div>
<div id="outline-container-orgheadline83" class="outline-2">
<h2 id="orgheadline83">与服务器数据传输的加密</h2>
<div class="outline-text-2" id="text-orgheadline83">
<p>
主要使用了两个东西, u-key 和 us.
</p>
<ol class="org-ol">
<li>u-key:  通过 AESCoder来加密程序获取的一系列手机参数,
AESCoder 的 encoder() 函数的 key 放到 jni 层,通过
jni 获取.</li>
<li>us:通过阿里聚安全再对上面的 u-key 做进一步加密生成 us.
这样传给服务器的加密数据有两个, 一般 us 不会被识破.</li>
</ol>

<p>
<b>注</b>:  阿里聚安全还可以识别是否为虚拟机.
</p>
</div>
</div>
<div id="outline-container-orgheadline84" class="outline-2">
<h2 id="orgheadline84">通过 intentservice 来执行后台任务&#xa0;&#xa0;&#xa0;<span class="tag"><span class="intentservice">intentservice</span></span></h2>
<div class="outline-text-2" id="text-orgheadline84">
<p>
intentService 通过执行一个后台线程来处理接受到的 intent.所以可以让一些繁重的工作通过
 intentService 来处理. 但是 intentService 只启动一个线程, 对于接受到的 intent 都是
依次处理的. 可能需要等待较长时间.
</p>

<p>
<b>注:</b> intentService 是一个抽象类, 使用者必须自己实现一个其子类并实现 onHandleIntent() 函数.
</p>
</div>
</div>
<div id="outline-container-orgheadline86" class="outline-2">
<h2 id="orgheadline86">JobScheduler</h2>
<div class="outline-text-2" id="text-orgheadline86">
</div><div id="outline-container-orgheadline85" class="outline-3">
<h3 id="orgheadline85">一般使用流程</h3>
<div class="outline-text-3" id="text-orgheadline85">
<ol class="org-ol">
<li>创建一个自定义JobService</li>
<li>使用JobInfo的builder基于上面的JobService创建一个JobInfo.</li>
<li>调用JobScheduler的schedule()函数安排工作.</li>
</ol>
</div>
</div>
</div>
<div id="outline-container-orgheadline90" class="outline-2">
<h2 id="orgheadline90">ch</h2>
<div class="outline-text-2" id="text-orgheadline90">
</div><div id="outline-container-orgheadline87" class="outline-3">
<h3 id="orgheadline87">常见的主页展示方式</h3>
<div class="outline-text-3" id="text-orgheadline87">
<p>
目前国内主流的主页展示方式是下面一个 tab 栏, 然后
点击每个 tab 项展示不同的页面.
</p>

<p>
CH 的实现使用了 TabLayout 和 FragmentPageAdapter.
</p>
</div>
</div>
<div id="outline-container-orgheadline88" class="outline-3">
<h3 id="orgheadline88">锁屏上的滑动解锁 view</h3>
<div class="outline-text-3" id="text-orgheadline88">
<ol class="org-ol">
<li>整个的这块区域就是一个 view, 图标都是通过画布画上去的.</li>
<li>构造函数来获取要绘制的 drawable</li>
<li>onMeasure 中计算 view 的实际宽高.</li>
<li>onLayout  中确定各个 drawable 的摆放位置</li>
<li>onDraw 中将各个 drawable 画到画布上.</li>
</ol>
</div>
<div id="outline-container-orgheadline89" class="outline-4">
<h4 id="orgheadline89">通过 view 学习的思考自定义 view 的实现</h4>
<div class="outline-text-4" id="text-orgheadline89">
<ol class="org-ol">
<li>要确定好这个 view 的原型图和动画效果. 
控件要怎么布局, 控件支持的动画和控件之间的动画交互.</li>
<li>View 支持的自定义属性.</li>
<li>尽量把 view 细分, 一个 view 可能包含多个组件. 每个组件要怎么
实现要想好. 组件之间有没有共性, 能否抽象.</li>
<li>耦合性, 在这个例子里, 动画使用 ObjectAnimator, 可以支持
View 的封装对象(该对象本身不是 view, 但通过该对象的变化来支持 view).</li>
<li>如果 view UI 有改变要记得调用 invalidate().</li>
<li>要熟练画布的使用.</li>
</ol>
</div>
</div>
</div>
</div>

<div id="outline-container-orgheadline95" class="outline-2">
<h2 id="orgheadline95">Handler</h2>
<div class="outline-text-2" id="text-orgheadline95">
</div><div id="outline-container-orgheadline91" class="outline-3">
<h3 id="orgheadline91">消息分发流程 dispatchMessage()</h3>
<div class="outline-text-3" id="text-orgheadline91">
<ol class="org-ol">
<li>如果消息本身是一个runnable,调用run()函数</li>
<li>否则如果该handler有callback,调用callback的handleMessage()函数</li>
<li>否则调用handleMessage()函数(一般自定义handler需要复写该函数)</li>
</ol>
</div>
</div>
<div id="outline-container-orgheadline92" class="outline-3">
<h3 id="orgheadline92">Handler创建</h3>
<div class="outline-text-3" id="text-orgheadline92">
<p>
handler必须创建在一个带有Looper的线程上, 默认UI线程有Looper. 如果不显示指定,
handler会绑定创建它线程的Looper. 没有Looper则报错.
</p>
</div>
</div>
<div id="outline-container-orgheadline93" class="outline-3">
<h3 id="orgheadline93">通过Handler获取消息</h3>
<div class="outline-text-3" id="text-orgheadline93">
<p>
所有的obtain()函数都会从系统全局的消息池中获取一个消息, 并且将该消息的Handler绑定到当前
Handler中.
</p>
</div>
</div>
<div id="outline-container-orgheadline94" class="outline-3">
<h3 id="orgheadline94">会导致内存泄漏的原因?</h3>
</div>
</div>
<div id="outline-container-orgheadline98" class="outline-2">
<h2 id="orgheadline98">jni</h2>
<div class="outline-text-2" id="text-orgheadline98">
</div><div id="outline-container-orgheadline96" class="outline-3">
<h3 id="orgheadline96">jni里分配的内存会算到OOM内存上吗?</h3>
</div>
<div id="outline-container-orgheadline97" class="outline-3">
<h3 id="orgheadline97">jni原理</h3>
</div>
</div>
<div id="outline-container-orgheadline99" class="outline-2">
<h2 id="orgheadline99">AsyncTask支持多任务提交吗?</h2>
</div>
<div id="outline-container-orgheadline100" class="outline-2">
<h2 id="orgheadline100">如何设计网络框架?</h2>
</div>
<div id="outline-container-orgheadline101" class="outline-2">
<h2 id="orgheadline101">前台service的好处?</h2>
</div>
<div id="outline-container-orgheadline102" class="outline-2">
<h2 id="orgheadline102">ImageLoader如何同步</h2>
</div>
<div id="outline-container-orgheadline103" class="outline-2">
<h2 id="orgheadline103">单例模式使用volatile</h2>
</div>
<div id="outline-container-orgheadline104" class="outline-2">
<h2 id="orgheadline104">thread vs asynctask</h2>
</div>
</div>
<div id="postamble" class="status">
<p class="postamble">Created At  by Luis Xu. Email: <a href="mailto:xuzhengchaojob@gmail.com">xuzhengchaojob@gmail.com</a></p>
</div>
</body>
</html>
