<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
"http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en">
<head>
<!-- 2017-03-14 Tue 22:52 -->
<meta  http-equiv="Content-Type" content="text/html;charset=utf-8" />
<meta  name="viewport" content="width=device-width, initial-scale=1" />
<title>Android Log 系统</title>
<meta  name="generator" content="Org-mode" />
<meta  name="author" content="Luis Xu" />
<link rel="stylesheet" title="Standard" href="/style/worg.css" type="text/css" />
<link rel="alternate stylesheet" title="Zenburn" href="/style/worg-zenburn.css" type="text/css" />
<link rel="alternate stylesheet" title="Classic" href="/style/worg-classic.css" type="text/css" />
<link rel="SHORTCUT ICON" href="/org-mode-unicorn.ico" type="image/x-icon" />
<link rel="icon" href="/org-mode-unicorn.ico" type="image/ico" />
<script type="text/javascript">
/*
@licstart  The following is the entire license notice for the
JavaScript code in this tag.

Copyright (C) 2012-2013 Free Software Foundation, Inc.

The JavaScript code in this tag is free software: you can
redistribute it and/or modify it under the terms of the GNU
General Public License (GNU GPL) as published by the Free Software
Foundation, either version 3 of the License, or (at your option)
any later version.  The code is distributed WITHOUT ANY WARRANTY;
without even the implied warranty of MERCHANTABILITY or FITNESS
FOR A PARTICULAR PURPOSE.  See the GNU GPL for more details.

As additional permission under GNU GPL version 3 section 7, you
may distribute non-source (e.g., minimized or compacted) forms of
that code without the copy of the GNU GPL normally required by
section 4, provided you include this license notice and a URL
through which recipients can access the Corresponding Source.


@licend  The above is the entire license notice
for the JavaScript code in this tag.
*/
<!--/*--><![CDATA[/*><!--*/
 function CodeHighlightOn(elem, id)
 {
   var target = document.getElementById(id);
   if(null != target) {
     elem.cacheClassElem = elem.className;
     elem.cacheClassTarget = target.className;
     target.className = "code-highlighted";
     elem.className   = "code-highlighted";
   }
 }
 function CodeHighlightOff(elem, id)
 {
   var target = document.getElementById(id);
   if(elem.cacheClassElem)
     elem.className = elem.cacheClassElem;
   if(elem.cacheClassTarget)
     target.className = elem.cacheClassTarget;
 }
/*]]>*///-->
</script>
<script type="text/x-mathjax-config">
    MathJax.Hub.Config({
        displayAlign: "center",
        displayIndent: "0em",

        "HTML-CSS": { scale: 100,
                        linebreaks: { automatic: "false" },
                        webFont: "TeX"
                       },
        SVG: {scale: 100,
              linebreaks: { automatic: "false" },
              font: "TeX"},
        NativeMML: {scale: 100},
        TeX: { equationNumbers: {autoNumber: "AMS"},
               MultLineWidth: "85%",
               TagSide: "right",
               TagIndent: ".8em"
             }
});
</script>
<script type="text/javascript"
        src="http://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS_HTML"></script>
</head>
<body>
<div id="preamble" class="status">
<script type="text/javascript">

  var _gaq = _gaq || [];
  _gaq.push(['_setAccount', 'UA-7691209-1']);
  _gaq.push(['_trackPageview']);

  (function() {
    var ga = document.createElement('script'); ga.type = 'text/javascript'; ga.async = true;
    ga.src = ('https:' == document.location.protocol ? 'https://ssl' : 'http://www') + '.google-analytics.com/ga.js';
    var s = document.getElementsByTagName('script')[0]; s.parentNode.insertBefore(ga, s);
  })();

  document.addEventListener('DOMContentLoaded',function() {
      document.getElementById("table-of-contents").onclick = function() {
          var elem = document.getElementById("text-table-of-contents");
          elem.style.display = elem.style.display == "block" ? "none" : "block";
      }
  });
</script>
</div>
<div id="content">
<h1 class="title">Android Log 系统</h1>
<div id="table-of-contents">
<h2>Table of Contents</h2>
<div id="text-table-of-contents">
<ul>
<li><a href="#orgheadline1">Logcat</a>
<ul>
<li><a href="#orgheadline2">test 参数</a></li>
<li><a href="#orgheadline3">"-s" 参数</a></li>
<li><a href="#orgheadline4">"-c" 参数</a></li>
<li><a href="#orgheadline5">"-d" "-t N" 参数</a></li>
<li><a href="#orgheadline6">"-g" 参数</a></li>
<li><a href="#orgheadline7">"-b device" 参数</a></li>
<li><a href="#orgheadline8">"-B" 参数</a></li>
<li><a href="#orgheadline9">"-f file" 参数</a></li>
<li><a href="#orgheadline10">"-r size" 参数</a></li>
<li><a href="#orgheadline11">"-n num" 参数</a></li>
<li><a href="#orgheadline12">"-v format" 参数</a></li>
<li><a href="#orgheadline13">读log</a></li>
</ul>
</li>
<li><a href="#orgheadline14">Liblog</a>
<ul>
<li><a href="#orgheadline15">ALOGX 系列</a></li>
<li><a href="#orgheadline16">SLOGX</a></li>
<li><a href="#orgheadline17">Events Log</a></li>
</ul>
</li>
<li><a href="#orgheadline18">Logger</a>
<ul>
<li><a href="#orgheadline19">打开Logger设备</a></li>
<li><a href="#orgheadline20">读logger</a></li>
<li><a href="#orgheadline21">Log write</a></li>
<li><a href="#orgheadline22">logger_poll</a></li>
</ul>
</li>
<li><a href="#orgheadline23">Logwrapper</a>
<ul>
<li><a href="#orgheadline24">clogwrapper 代码</a></li>
</ul>
</li>
</ul>
</div>
</div>
<p>
In memory of those days in MTK
</p>

<div id="outline-container-orgheadline1" class="outline-2">
<h2 id="orgheadline1">Logcat</h2>
<div class="outline-text-2" id="text-orgheadline1">
<p>
这篇文章介绍android系统中录log的工具 logcat.
</p>

<p>
Android 系统提供了一整套的API供Java层和Native层的程序写log,以方便调试及在系统出问题的时候有据可查. 
而logcat是把这些抓log的工具,可以通过logcat把log显示到标准输出或文件中,同时还可以对log进行过滤. 设定log level及只读取指定module的log. logcat 的详细用法可以在手机中输入"logcat &#x2013;help" 命令查看.
</p>

<p>
本文主要对logcat的源码进行分析,从main函数开始.从main函数开始遇到的第一个函数调用是.
</p>

<p>
g_logformat = android_log_format_new();
</p>

<p>
看下这个函数的定义:
</p>
<div class="org-src-container">

<pre class="src src-c"><span style="color: #5F7F5F;">/* </span><span style="color: #7F9F7F;">android_log_format_new()</span><span style="color: #5F7F5F;">*/</span>
<span style="color: #7CB8BB;">AndroidLogFormat</span> *<span style="color: #93E0E3;">android_log_format_new</span>()
{
    <span style="color: #7CB8BB;">AndroidLogFormat</span> *<span style="color: #DFAF8F;">p_ret</span>;

    p_ret = calloc(1, <span style="color: #F0DFAF; font-weight: bold;">sizeof</span>(AndroidLogFormat));

    p_ret-&gt;global_pri = ANDROID_LOG_VERBOSE;
    p_ret-&gt;format = FORMAT_BRIEF;

    <span style="color: #F0DFAF; font-weight: bold;">return</span> p_ret;
}
</pre>
</div>
<p>
这个函数通过malloc生成一个 AndroidLogFormat 的结构体,并将结构体的成员变量 'global_pri' 和 'format' 设置.先省略这个结构体的实现,继续看main 函数的代码.
</p>
<div class="org-src-container">

<pre class="src src-c">    <span style="color: #5F7F5F;">/* </span><span style="color: #7F9F7F;">main()</span><span style="color: #5F7F5F;">*/</span>
<span style="color: #F0DFAF; font-weight: bold;">if</span> (argc == 2 &amp;&amp; 0 == strcmp(argv[1], <span style="color: #CC9393;">"--test"</span>)) {
    logprint_run_tests();
    exit(0);
}
</pre>
</div>
</div>
<div id="outline-container-orgheadline2" class="outline-3">
<h3 id="orgheadline2">test 参数</h3>
<div class="outline-text-3" id="text-orgheadline2">
<div class="org-src-container">

<pre class="src src-c">&#22914;&#26524;logcat&#21482;&#26377;&#19968;&#20010;&#21442;&#25968;<span style="color: #CC9393;">"--test"</span>,&#21017;&#25191;&#34892;logprint_run_tests()&#20989;&#25968;,&#20174;&#20195;&#30721;&#26469;&#30475;,&#36825;&#20010;&#20989;&#25968;&#20027;&#35201;&#26159;&#27979;&#35797;logcat&#30340;&#21151;&#33021;&#30340;.

        <span style="color: #5F7F5F;">/* </span><span style="color: #7F9F7F;">logprint_run_tests()</span><span style="color: #5F7F5F;">*/</span>
    p_format = android_log_format_new();
    fprintf(stderr, <span style="color: #CC9393;">"running tests\n"</span>);
    tag = <span style="color: #CC9393;">"random"</span>;
    android_log_addFilterRule(p_format,<span style="color: #CC9393;">"*:i"</span>);

<span style="color: #7CB8BB;">&#36825;&#20010;&#20989;&#25968;&#24320;&#22987;&#20063;call&#20102;&#19968;&#27425;</span> <span style="color: #93E0E3;">android_log_format_new</span>()&#20998;&#37197;&#20102;&#19968;&#20010;&#32467;&#26500;&#20307;.&#24182;&#35774;&#32622;&#20102;tag&#21464;&#37327;,tag&#26159;&#27599;&#20010;module&#22312;&#25171;log&#26102;&#37117;&#38656;&#35201;&#35774;&#32622;&#19968;&#20010;tag,&#21487;&#20197;&#36890;&#36807;tag&#29992;&#26469;&#26631;&#24535;&#26159;&#35813;module&#36755;&#20986;&#30340;log. &#25509;&#30528;call&#20989;&#25968; android_log_addFilterRule(), &#35774;&#32622;logcat&#30340;&#36807;&#28388;&#26426;&#21046;.

        <span style="color: #5F7F5F;">/* </span><span style="color: #7F9F7F;">android_log_addFilterRule() </span><span style="color: #5F7F5F;">*/</span>
        android_LogPriority pri = ANDROID_LOG_DEFAULT;
        tagNameLength = strcspn(filterExpression, <span style="color: #CC9393;">":"</span>);
    <span style="color: #F0DFAF; font-weight: bold;">if</span>(filterExpression[tagNameLength] == <span style="color: #CC9393;">':'</span>) {
        pri = filterCharToPri(filterExpression[tagNameLength+1]);

        <span style="color: #F0DFAF; font-weight: bold;">if</span> (pri == ANDROID_LOG_UNKNOWN) {
            <span style="color: #F0DFAF; font-weight: bold;">goto</span> <span style="color: #BFEBBF;">error</span>;
        }
    }

<span style="color: #7CB8BB;">&#35813;&#20989;&#25968;&#35774;&#32622;pri&#21464;&#37327;&#30340;&#20540;&#20026;</span> <span style="color: #DFAF8F;">ANDROID_LOG_DEFAULT</span>, <span style="color: #7CB8BB;">&#36825;&#20010;&#20540;&#34987;&#23450;&#20041;&#22312;&#19968;&#20010;enum&#20013;</span>,<span style="color: #DFAF8F;">&#22914;&#26524;log</span> pririoty&#34987;&#35774;&#20026; ANDROID_LOG_DEFAULT, <span style="color: #DFAF8F;">&#21017;&#34920;&#31034;&#36755;&#20986;&#25152;&#26377;&#31561;&#32423;&#30340;log</span>.&#25509;&#30528;&#33719;&#24471;filter&#30340;tag&#30340;&#38271;&#24230;,<span style="color: #DFAF8F;">&#26681;&#25454;&#21069;&#38754;&#30340;&#21442;&#25968;</span>,<span style="color: #CC9393;">"*:i"</span>&#30340;&#36820;&#22238;&#32467;&#26524;&#26159;1, &#25509;&#30528;&#35843;&#29992;filterCharToPri(),&#24182;&#20256;&#20837;&#21442;&#25968;<span style="color: #CC9393;">"i"</span>
. &#36825;&#20010;&#20989;&#25968;&#25226;&#20256;&#20837;&#30340;&#23383;&#31526;&#24418;&#24335;&#30340;log level &#36716;&#25442;&#20026;&#25968;&#23383;level,<span style="color: #7CB8BB;">&#36825;&#20123;level&#21644;</span> <span style="color: #7CB8BB;">ANDROID_LOG_DEFAULT&#19968;&#36215;&#23450;&#20041;&#22312;enum&#20013;</span>.

    } <span style="color: #F0DFAF; font-weight: bold;">else</span> <span style="color: #F0DFAF; font-weight: bold;">if</span> (c == <span style="color: #CC9393;">'i'</span>) {
        pri = ANDROID_LOG_INFO;

        <span style="color: #5F7F5F;">/* </span><span style="color: #7F9F7F;">define </span><span style="color: #5F7F5F;">*/</span>
        <span style="color: #F0DFAF; font-weight: bold;">enum</span>  {
            <span style="color: #DFAF8F;">ANDROID_LOG_UNKNOWN</span> = 0,
            <span style="color: #DFAF8F;">ANDROID_LOG_DEFAULT</span>,    <span style="color: #5F7F5F;">/* </span><span style="color: #7F9F7F;">only for SetMinPriority() </span><span style="color: #5F7F5F;">*/</span>

            <span style="color: #DFAF8F;">ANDROID_LOG_VERBOSE</span>,
            <span style="color: #DFAF8F;">ANDROID_LOG_DEBUG</span>,
            <span style="color: #DFAF8F;">ANDROID_LOG_INFO</span>,
            <span style="color: #DFAF8F;">ANDROID_LOG_WARN</span>,
            <span style="color: #DFAF8F;">ANDROID_LOG_ERROR</span>,
            <span style="color: #DFAF8F;">ANDROID_LOG_FATAL</span>,

            <span style="color: #DFAF8F;">ANDROID_LOG_SILENT</span>,     <span style="color: #5F7F5F;">/* </span><span style="color: #7F9F7F;">only for SetMinPriority(); must be last </span><span style="color: #5F7F5F;">*/</span>

<span style="color: #7CB8BB;">&#25509;&#19979;&#26469;&#21028;&#26029;&#26159;&#21542;&#26377;&#35774;&#32622;&#20840;&#23616;&#30340;log</span> <span style="color: #DFAF8F;">level</span>,<span style="color: #DFAF8F;">&#21363;&#20256;&#20837;&#30340;filter&#20013;&#26159;&#21542;&#21253;&#21547;</span><span style="color: #CC9393;">"*:x"</span>&#30340;&#23383;&#31526;&#20018;,<span style="color: #DFAF8F;">&#22914;&#26524;&#26159;&#30340;&#35805;</span>,<span style="color: #7CB8BB;">&#23601;&#35774;&#32622;&#19968;&#20010;&#20840;&#23616;&#24615;&#30340;log</span> <span style="color: #93E0E3;">level</span>

        <span style="color: #5F7F5F;">/* </span><span style="color: #7F9F7F;">android_log_addFilterRule() </span><span style="color: #5F7F5F;">*/</span>
    <span style="color: #F0DFAF; font-weight: bold;">if</span>(0 == strncmp(<span style="color: #CC9393;">"*"</span>, filterExpression, tagNameLength)) {
        <span style="color: #F0DFAF; font-weight: bold;">if</span> (pri == ANDROID_LOG_DEFAULT) {
            pri = ANDROID_LOG_DEBUG;
        }
        p_format-&gt;global_pri = pri;

&#36825;&#26679;,runtest()&#20989;&#25968;&#30340;filter&#35774;&#32622;&#23601;&#23436;&#25104;&#20102;,&#21097;&#19979;&#37117;&#26159;&#19968;&#20123;&#22522;&#26412;&#30340;&#26816;&#26597;&#35821;&#21477;&#26816;&#26597;&#35774;&#32622;&#26377;&#27809;&#26377;&#25104;&#21151;.

            assert (ANDROID_LOG_INFO == filterPriForTag(p_format, <span style="color: #CC9393;">"random"</span>));

&#36825;&#26465;&#35821;&#21477;&#26816;&#26597;tag <span style="color: #CC9393;">"random"</span>&#30340;priority&#26159;&#21542;&#26159;ANDROID_LOG_INFO,&#30475;&#19979; <span style="color: #7CB8BB;">filterPriForTag</span>()&#20989;&#25968;&#23454;&#29616;

        <span style="color: #F0DFAF; font-weight: bold;">static</span> <span style="color: #7CB8BB;">android_LogPriority</span> <span style="color: #93E0E3;">filterPriForTag</span>(
                <span style="color: #7CB8BB;">AndroidLogFormat</span> *<span style="color: #DFAF8F;">p_format</span>, <span style="color: #F0DFAF; font-weight: bold;">const</span> <span style="color: #7CB8BB;">char</span> *<span style="color: #DFAF8F;">tag</span>)
        {
            <span style="color: #7CB8BB;">FilterInfo</span> *<span style="color: #DFAF8F;">p_curFilter</span>;
            <span style="color: #F0DFAF; font-weight: bold;">for</span> (p_curFilter = p_format-&gt;filters
                    ; p_curFilter != <span style="color: #BFEBBF;">NULL</span>
                    ; p_curFilter = p_curFilter-&gt;p_next
            ) {
                <span style="color: #F0DFAF; font-weight: bold;">if</span> (0 == strcmp(tag, p_curFilter-&gt;mTag)) {
                    <span style="color: #F0DFAF; font-weight: bold;">if</span> (p_curFilter-&gt;mPri == ANDROID_LOG_DEFAULT) {
                        <span style="color: #F0DFAF; font-weight: bold;">return</span> p_format-&gt;global_pri;
                    } <span style="color: #F0DFAF; font-weight: bold;">else</span> {
                        <span style="color: #F0DFAF; font-weight: bold;">return</span> p_curFilter-&gt;mPri;
                    }
                }
            }

            <span style="color: #F0DFAF; font-weight: bold;">return</span> p_format-&gt;global_pri;
        }

&#36825;&#27573;code&#24456;&#30452;&#35266;,&#39318;&#20808;&#36941;&#21382;p_format&#30340;filter,&#26816;&#26597;&#26377;&#27809;&#26377;&#35774;&#32622;tag&#30340;priority, &#22914;&#26524;&#27809;&#26377;&#25214;&#21040;,<span style="color: #7CB8BB;">&#23601;&#36820;&#22238;&#20840;&#23616;&#30340;log</span> <span style="color: #93E0E3;">level</span>. &#36824;&#26377;&#21478;&#19968;&#20010;&#38656;&#35201;&#26816;&#26597;&#30340;&#22320;&#26041;

    assert(android_log_shouldPrintLine(p_format, tag, ANDROID_LOG_DEBUG) == 0);

&#22312;android&#20013;&#27599;&#26465;log&#37117;&#23545;&#24212;&#35201;&#19968;&#20010;priority,&#36825;&#20010;&#20989;&#25968;&#26816;&#26597;&#30456;&#24212;tag&#30340;&#36825;&#26465;log&#26159;&#21542;&#24212;&#35813;&#25171;&#21360;&#20986;&#26469;.

        <span style="color: #7CB8BB;">int</span> android_log_shouldPrintLine (
                AndroidLogFormat *p_format, <span style="color: #F0DFAF; font-weight: bold;">const</span> <span style="color: #7CB8BB;">char</span> *<span style="color: #DFAF8F;">tag</span>, <span style="color: #7CB8BB;">android_LogPriority</span> <span style="color: #DFAF8F;">pri</span>)
        {
            <span style="color: #F0DFAF; font-weight: bold;">return</span> pri &gt;= filterPriForTag(p_format, tag);
        }

&#36890;&#36807;filterPriForTag()&#20989;&#25968;&#26597;&#25214;&#35813;tag&#30340;priority,&#28982;&#21518;&#36319;&#20256;&#20837;&#30340;level&#20570;&#27604;&#36739;,&#21028;&#26029;&#26159;&#21542;&#38656;&#35201;&#25171;&#21360;&#35813;tag&#35813;level&#32423;&#21035;&#30340;log.

&#21516;&#26102;,&#21487;&#20197;&#36890;&#36807; <span style="color: #7CB8BB;">android_log_addFilterString</span>()<span style="color: #7CB8BB;">&#35774;&#23450;&#22810;&#20010;log</span> <span style="color: #DFAF8F;">filter</span>.

    err = android_log_addFilterString(p_format, <span style="color: #CC9393;">"*:s random:d "</span>);

        <span style="color: #7CB8BB;">int</span> <span style="color: #93E0E3;">android_log_addFilterString</span>(<span style="color: #7CB8BB;">AndroidLogFormat</span> *<span style="color: #DFAF8F;">p_format</span>,
                <span style="color: #F0DFAF; font-weight: bold;">const</span> <span style="color: #7CB8BB;">char</span> *<span style="color: #DFAF8F;">filterString</span>)
        {
            <span style="color: #5F7F5F;">// </span><span style="color: #7F9F7F;">Yes, I'm using strsep</span>
            <span style="color: #F0DFAF; font-weight: bold;">while</span> (<span style="color: #BFEBBF;">NULL</span> != (p_ret = strsep(&amp;p_cur, <span style="color: #CC9393;">" \t,"</span>))) {
                <span style="color: #5F7F5F;">// </span><span style="color: #7F9F7F;">ignore whitespace-only entries</span>
                <span style="color: #F0DFAF; font-weight: bold;">if</span>(p_ret[0] != <span style="color: #CC9393;">'\0'</span>) {
                    err = android_log_addFilterRule(p_format, p_ret);
                }
            }
        ...... 
        }

android_log_addFilterString()<span style="color: #7CB8BB;">&#20250;&#24490;&#29615;&#36941;&#21382;&#20256;&#20837;&#30340;filter</span> <span style="color: #DFAF8F;">string</span>,<span style="color: #DFAF8F;">&#24182;&#23558;&#20854;&#28155;&#21152;&#21040;filter</span> &#38142;&#34920;&#20013;.
ok, <span style="color: #CC9393;">"--test"</span> &#21442;&#25968;&#21040;&#36825;&#37324;&#23601;&#35762;&#23436;&#20102;.
</pre>
</div>
</div>
</div>
<div id="outline-container-orgheadline3" class="outline-3">
<h3 id="orgheadline3">"-s" 参数</h3>
<div class="outline-text-3" id="text-orgheadline3">
<p>
将全局的log level 设为 ANDROID_LOG_SILENT, 即不输出所有level的log
</p>

<p>
android_log_addFilterRule(g_logformat, "*:s");
</p>
</div>
</div>

<div id="outline-container-orgheadline4" class="outline-3">
<h3 id="orgheadline4">"-c" 参数</h3>
<div class="outline-text-3" id="text-orgheadline4">
<p>
该参数可以将log device中的log删除.
</p>

<p>
    case 'c':
   clearLog = 1;
   mode = O_WRONLY;
break;
</p>

<p>
if (clearLog) {
    int ret;
    ret = android::clearLog(dev-&gt;fd);
</p>

<p>
看下clearLog函数
</p>

<p>
static int clearLog(int logfd)
{
    return ioctl(logfd, LOGGER_FLUSH_LOG);
}
</p>

<p>
该函数向driver层下发 LOGGER_FLUSH_LOG 命令,告诉logger device的driver将logger中的log清除,关于logger device的实现在后面会讲到.
</p>
</div>
</div>

<div id="outline-container-orgheadline5" class="outline-3">
<h3 id="orgheadline5">"-d" "-t N" 参数</h3>
<div class="outline-text-3" id="text-orgheadline5">
<p>
这两个参数都会将g_nonblock变量设为true,表示把logger里的log读完就会立刻退出,而不会等待新log的写入. 同时"-t"参数后面还要跟着一个值N,表示只读最近的N条log.
</p>
</div>
</div>

<div id="outline-container-orgheadline6" class="outline-3">
<h3 id="orgheadline6">"-g" 参数</h3>
<div class="outline-text-3" id="text-orgheadline6">
<p>
给driver发送LOGGER_GET_LOG_BUF_SIZE, 获得logger device的大小.
</p>
</div>
</div>

<div id="outline-container-orgheadline7" class="outline-3">
<h3 id="orgheadline7">"-b device" 参数</h3>
<div class="outline-text-3" id="text-orgheadline7">
<p>
指定要从哪个buffer中读log, "-b"可以使用多次,例如" -b main -b radio"
</p>
</div>
</div>

<div id="outline-container-orgheadline8" class="outline-3">
<h3 id="orgheadline8">"-B" 参数</h3>
<div class="outline-text-3" id="text-orgheadline8">
<p>
以二进制方式打印log(目前默认会对log进行解析,以字符串形式打印)
</p>
</div>
</div>

<div id="outline-container-orgheadline9" class="outline-3">
<h3 id="orgheadline9">"-f file" 参数</h3>
<div class="outline-text-3" id="text-orgheadline9">
<p>
将log 输出到指定文件 file
</p>
</div>
</div>

<div id="outline-container-orgheadline10" class="outline-3">
<h3 id="orgheadline10">"-r size" 参数</h3>
<div class="outline-text-3" id="text-orgheadline10">
<p>
设定rotate size大小,rotate size 的含义是每种log 最多只有 size 大小. 录满后旧log会被覆盖
</p>
</div>
</div>

<div id="outline-container-orgheadline11" class="outline-3">
<h3 id="orgheadline11">"-n num" 参数</h3>
<div class="outline-text-3" id="text-orgheadline11">
<p>
设定每种log最大的log file数量,每个file的大小为 rotate_size/num
</p>
</div>
</div>

<div id="outline-container-orgheadline12" class="outline-3">
<h3 id="orgheadline12">"-v format" 参数</h3>
<div class="outline-text-3" id="text-orgheadline12">
<p>
设定输出的log 格式
</p>

<p>
err = setLogFormat (optarg);
static int setLogFormat(const char * formatString)
{
    static AndroidLogPrintFormat format;
</p>

<p>
format = android_log_formatFromString(formatString);
android_log_setPrintFormat(g_logformat, format);
</p>

<p>
    return 0;
}
</p>

<p>
AndroidLogPrintFormat android_log_formatFromString(const char * formatString)
{
    static AndroidLogPrintFormat format;
</p>

<p>
if (strcmp(formatString, "brief") <code>= 0) format = FORMAT_BRIEF;
	     else if (strcmp(formatString, "process") =</code> 0) format = FORMAT_PROCESS;
else if (strcmp(formatString, "tag") <code>= 0) format = FORMAT_TAG;
	     else if (strcmp(formatString, "thread") =</code> 0) format = FORMAT_THREAD;
else if (strcmp(formatString, "raw") <code>= 0) format = FORMAT_RAW;
	     else if (strcmp(formatString, "time") =</code> 0) format = FORMAT_TIME;
else if (strcmp(formatString, "threadtime") <code>= 0) format = FORMAT_THREADTIME;
	     else if (strcmp(formatString, "long") =</code> 0) format = FORMAT_LONG;
else format = FORMAT_OFF;
</p>

<p>
    return format;
}
</p>

<p>
第一个函数把字符串形式的format转换成整形表示,第二个参数把转换后的format设置到全局变量g_logformat中
</p>


<p>
OK, 到此为止,参数部分就解析完毕.接着执行下面的代码
</p>


<p>
如果没有指定"-b"参数的话,会默认打开 "main" 和 "system" 两个logger device
</p>

<p>
if (!devices) {
    devices = new log_device_t(strdup("<i>dev</i>"LOGGER_LOG_MAIN), false, 'm');
    android::g_devCount = 1;
    int accessmode =
              (mode &amp; O_RDONLY) ? R_OK : 0
</p>
<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">


<colgroup>
<col  class="org-left" />
</colgroup>
<tbody>
<tr>
<td class="org-left">(mode &amp; O_WRONLY) ? W_OK : 0;</td>
</tr>
</tbody>
</table>
<p>
    if (0 == access("<i>dev</i>"LOGGER_LOG_SYSTEM, accessmode)) {
        devices-&gt;next = new log_device_t(strdup("<i>dev</i>"LOGGER_LOG_SYSTEM), false, 's');
        android::g_devCount++;
    }
}
</p>

<p>
接下来是设定输出,如果没有指定"-f file"参数,默认输出到标准输出,否则打开file 文件.
</p>

<p>
static void setupOutput()
{
</p>

<p>
    if (g_outputFileName == NULL) {
        g_outFD = STDOUT_FILENO;
    } else {
        struct stat statbuf;
        g_outFD = openLogFile (g_outputFileName);
        fstat(g_outFD, &amp;statbuf);
        g_outByteCount = statbuf.st_size;
    }
}
</p>

<p>
如果有设定log filter的话,会解析字符串并加入到g_logformat的filter链表中 
</p>

<p>
for (int i = optind ; i &lt; argc ; i++) {
    err = android_log_addFilterString(g_logformat, argv[i]);
</p>

<p>
接下来会打开logger device,然后就是读log了.
</p>

<p>
android::readLogLines(devices);
</p>
</div>
</div>

<div id="outline-container-orgheadline13" class="outline-3">
<h3 id="orgheadline13">读log</h3>
<div class="outline-text-3" id="text-orgheadline13">
<p>
readLogLines()函数通过一个while loop不停的从kernel 层的logger device中读取log
</p>

<p>
while (1) {
    do {
        timeval timeout = { 0, 5000 <i>* 5ms *</i> }; // If we oversleep it's ok, i.e. ignore EINTR.
        FD_ZERO(&amp;readset);
        for (dev=devices; dev; dev = dev-&gt;next) {
            FD_SET(dev-&gt;fd, &amp;readset);
        }
        result = select(max + 1, &amp;readset, NULL, NULL, sleep ? NULL : &amp;timeout);
    } while (result <code>= -1 &amp;&amp; errno =</code> EINTR);
</p>

<p>
这里有设一个timeout,最开始这个值为false,标志一直等待有log产生. 如果为true, 表示这段时间内没有新的log产生,则会把以及读出来的log全部flush到输出.
</p>

<p>
如果select()返回,会检查是否有logger device可读,并尝试从device中读取一条log.
</p>
<div class="org-src-container">

<pre class="src src-c"><span style="color: #F0DFAF; font-weight: bold;">if</span> (result &gt;= 0) {
    <span style="color: #F0DFAF; font-weight: bold;">for</span> (dev=devices; dev; dev = dev-&gt;next) {
        <span style="color: #F0DFAF; font-weight: bold;">if</span> (FD_ISSET(dev-&gt;fd, &amp;readset)) {
            <span style="color: #7CB8BB;">queued_entry_t</span>* <span style="color: #DFAF8F;">entry</span> = new queued_entry_t();
            ret = read(dev-&gt;fd, entry-&gt;buf, LOGGER_ENTRY_MAX_LEN);
</pre>
</div>
<p>
logger device read() 的实现是每次读取一条logger_entry, 并存放到结构体queued_entry_t 的成员变量 buf 中,queued_entry_t 的定义如下:
</p>
<div class="org-src-container">

<pre class="src src-c"><span style="color: #F0DFAF; font-weight: bold;">struct</span> <span style="color: #7CB8BB;">queued_entry_t</span> {
    <span style="color: #F0DFAF; font-weight: bold;">union</span> {
        <span style="color: #7CB8BB;">unsigned</span> <span style="color: #7CB8BB;">char</span> <span style="color: #DFAF8F;">buf</span>[LOGGER_ENTRY_MAX_LEN + 1] <span style="color: #F0DFAF; font-weight: bold;">__attribute__</span>((aligned(4)));
        <span style="color: #F0DFAF; font-weight: bold;">struct</span> <span style="color: #7CB8BB;">logger_entry</span> <span style="color: #DFAF8F;">entry</span> <span style="color: #F0DFAF; font-weight: bold;">__attribute__</span>((aligned(4)));
    };
    <span style="color: #7CB8BB;">queued_entry_t</span>* <span style="color: #DFAF8F;">next</span>;

    <span style="color: #93E0E3;">queued_entry_t</span>() {
        next = <span style="color: #BFEBBF;">NULL</span>;
    }
};
</pre>
</div>
<p>
可以看到buf和logger_entry被定义成union结构,所以读到buffer的内容同时是一条logger_entry.        该结构体的定义如下
</p>
<div class="org-src-container">

<pre class="src src-c"><span style="color: #F0DFAF; font-weight: bold;">struct</span> <span style="color: #7CB8BB;">logger_entry</span> {
    <span style="color: #7CB8BB;">uint16_t</span>    <span style="color: #DFAF8F;">len</span>;    <span style="color: #5F7F5F;">/* </span><span style="color: #7F9F7F;">length of the payload </span><span style="color: #5F7F5F;">*/</span>
    <span style="color: #7CB8BB;">uint16_t</span>    <span style="color: #DFAF8F;">__pad</span>;  <span style="color: #5F7F5F;">/* </span><span style="color: #7F9F7F;">no matter what, we get 2 bytes of padding </span><span style="color: #5F7F5F;">*/</span>
    <span style="color: #7CB8BB;">int32_t</span>     <span style="color: #DFAF8F;">pid</span>;    <span style="color: #5F7F5F;">/* </span><span style="color: #7F9F7F;">generating process's pid </span><span style="color: #5F7F5F;">*/</span>
    <span style="color: #7CB8BB;">int32_t</span>     <span style="color: #DFAF8F;">tid</span>;    <span style="color: #5F7F5F;">/* </span><span style="color: #7F9F7F;">generating process's tid </span><span style="color: #5F7F5F;">*/</span>
    <span style="color: #7CB8BB;">int32_t</span>     <span style="color: #DFAF8F;">sec</span>;    <span style="color: #5F7F5F;">/* </span><span style="color: #7F9F7F;">seconds since Epoch </span><span style="color: #5F7F5F;">*/</span>
    <span style="color: #7CB8BB;">int32_t</span>     <span style="color: #DFAF8F;">nsec</span>;   <span style="color: #5F7F5F;">/* </span><span style="color: #7F9F7F;">nanoseconds </span><span style="color: #5F7F5F;">*/</span>
    <span style="color: #7CB8BB;">char</span>        <span style="color: #DFAF8F;">msg</span>[0]; <span style="color: #5F7F5F;">/* </span><span style="color: #7F9F7F;">the entry's payload </span><span style="color: #5F7F5F;">*/</span>
};
</pre>
</div>
<p>
第一个变量len是字符串msg的长度,所以read()函数返回后会对返回值和len的值做比较,如果不相等,表示读的数据有错误.
</p>
<div class="org-src-container">

<pre class="src src-c"><span style="color: #F0DFAF; font-weight: bold;">else</span> <span style="color: #F0DFAF; font-weight: bold;">if</span> (entry-&gt;entry.len != ret - <span style="color: #F0DFAF; font-weight: bold;">sizeof</span>(<span style="color: #F0DFAF; font-weight: bold;">struct</span> <span style="color: #7CB8BB;">logger_entry</span>)) {
        fprintf(stderr, <span style="color: #CC9393;">"read: unexpected length. Expected %d, got %d\n"</span>,
        entry-&gt;entry.len, ret - <span style="color: #F0DFAF; font-weight: bold;">sizeof</span>(<span style="color: #F0DFAF; font-weight: bold;">struct</span> <span style="color: #7CB8BB;">logger_entry</span>));
        exit(EXIT_FAILURE);
}
</pre>
</div>
<p>
接着会call device变量dev的enqueue()函数把刚读出来的log插入到dev的entry list中,并排序.
</p>
<div class="org-src-container">

<pre class="src src-c"><span style="color: #7CB8BB;">void</span> <span style="color: #93E0E3;">enqueue</span>(<span style="color: #7CB8BB;">queued_entry_t</span>* <span style="color: #DFAF8F;">entry</span>) {
    <span style="color: #F0DFAF; font-weight: bold;">if</span> (this-&gt;queue == <span style="color: #BFEBBF;">NULL</span>) {
        this-&gt;queue = entry;
    } <span style="color: #F0DFAF; font-weight: bold;">else</span> {
        <span style="color: #7CB8BB;">queued_entry_t</span>** <span style="color: #DFAF8F;">e</span> = &amp;this-&gt;queue;
        <span style="color: #F0DFAF; font-weight: bold;">while</span> (*e &amp;&amp; cmp(entry, *e) &gt;= 0) {
            e = &amp;((*e)-&gt;next);
        }
        entry-&gt;next = *e;
        *e = entry;
    }
}

    <span style="color: #F0DFAF; font-weight: bold;">static</span> <span style="color: #7CB8BB;">int</span> <span style="color: #93E0E3;">cmp</span>(<span style="color: #7CB8BB;">queued_entry_t</span>* <span style="color: #DFAF8F;">a</span>, <span style="color: #7CB8BB;">queued_entry_t</span>* <span style="color: #DFAF8F;">b</span>) {
        <span style="color: #7CB8BB;">int</span> <span style="color: #DFAF8F;">n</span> = a-&gt;entry.sec - b-&gt;entry.sec;
        <span style="color: #F0DFAF; font-weight: bold;">if</span> (n != 0) {
            <span style="color: #F0DFAF; font-weight: bold;">return</span> n;
        }
        <span style="color: #F0DFAF; font-weight: bold;">return</span> a-&gt;entry.nsec - b-&gt;entry.nsec;
    }
</pre>
</div>
<p>
插入的算法是从链表头开始已有entry与新entry的时间戳,如果新entry的产生时间比较晚,就继续与下一个entry比较. 其实理论上讲,晚到来的log总是产生时间晚的log,所以这种比较的比较次数一般要大于从尾部开始比较. 另外值得一提的是比较算法采用了指针的指针,比较简洁,避免插入时链表头的判断. Linus大婶曾经在一次访谈中说道"这才是指针的真正用法"&#x2026;&#x2026;.
</p>

<p>
接下来会打印log,需要说明的是没读出一次log就会判断是否需要打印log. 如果是select超时返回,会打印所有"需要"打印的log(这里加所有是因为如果使用"t"参数的话,只会打印最新的几条log),否则,会打印除最后一条log以外的所有log,剩一条log是为了下次时间戳的比较.
</p>
<div class="org-src-container">

<pre class="src src-c"><span style="color: #F0DFAF; font-weight: bold;">while</span> (g_tail_lines == 0 || queued_lines &gt; g_tail_lines) {
chooseFirst(devices, &amp;dev);
<span style="color: #F0DFAF; font-weight: bold;">if</span> (dev == <span style="color: #BFEBBF;">NULL</span> || dev-&gt;queue-&gt;next == <span style="color: #BFEBBF;">NULL</span>) {
        <span style="color: #F0DFAF; font-weight: bold;">break</span>;
}
<span style="color: #F0DFAF; font-weight: bold;">if</span> (g_tail_lines == 0) {
        printNextEntry(dev);
} <span style="color: #F0DFAF; font-weight: bold;">else</span> {
    skipNextEntry(dev);
}
--queued_lines;
</pre>
</div>
<p>
chooseFirst()函数会把device链表中包含最新log的device选出来,这样对于多种类型的log输出到同一个文件的case,可以保证log按时间排序.
</p>
<div class="org-src-container">

<pre class="src src-c"><span style="color: #F0DFAF; font-weight: bold;">static</span> <span style="color: #7CB8BB;">void</span> <span style="color: #93E0E3;">chooseFirst</span>(<span style="color: #7CB8BB;">log_device_t</span>* <span style="color: #DFAF8F;">dev</span>, <span style="color: #7CB8BB;">log_device_t</span>** <span style="color: #DFAF8F;">firstdev</span>) {
    <span style="color: #F0DFAF; font-weight: bold;">for</span> (*firstdev = <span style="color: #BFEBBF;">NULL</span>; dev != <span style="color: #BFEBBF;">NULL</span>; dev = dev-&gt;next) {
        <span style="color: #F0DFAF; font-weight: bold;">if</span> (dev-&gt;queue != <span style="color: #BFEBBF;">NULL</span> &amp;&amp; (*firstdev == <span style="color: #BFEBBF;">NULL</span> || cmp(dev-&gt;queue, (*firstdev)-&gt;queue) &lt; 0)) {
            *firstdev = dev;
        }
    }
}
</pre>
</div>
<p>
接着就是call printNextEntry()进行log输出.
</p>
<div class="org-src-container">

<pre class="src src-c"><span style="color: #F0DFAF; font-weight: bold;">static</span> <span style="color: #7CB8BB;">void</span> <span style="color: #93E0E3;">printNextEntry</span>(<span style="color: #7CB8BB;">log_device_t</span>* <span style="color: #DFAF8F;">dev</span>) {
    maybePrintStart(dev);
    <span style="color: #F0DFAF; font-weight: bold;">if</span> (g_printBinary) {
        printBinary(&amp;dev-&gt;queue-&gt;entry);
    } <span style="color: #F0DFAF; font-weight: bold;">else</span> {
        processBuffer(dev, &amp;dev-&gt;queue-&gt;entry);
    }
    skipNextEntry(dev);
}
</pre>
</div>
<p>
如果中指定了"B"参数,log将不会被解析,直接以二进制的方式输出,否则,调用 processBuffer()对log entry进行解析.
</p>
<div class="org-src-container">

<pre class="src src-c"><span style="color: #F0DFAF; font-weight: bold;">if</span> (dev-&gt;binary) {
    err = android_log_processBinaryLogBuffer(buf, &amp;entry, g_eventTagMap,
            binaryMsgBuf, <span style="color: #F0DFAF; font-weight: bold;">sizeof</span>(binaryMsgBuf));
    <span style="color: #5F7F5F;">//</span><span style="color: #7F9F7F;">printf("&gt;&gt;&gt; pri=%d len=%d msg='%s'\n",</span>
    <span style="color: #5F7F5F;">//    </span><span style="color: #7F9F7F;">entry.priority, entry.messageLen, entry.message);</span>
} <span style="color: #F0DFAF; font-weight: bold;">else</span> {
    err = android_log_processLogBuffer(buf, &amp;entry);
}
</pre>
</div>
<p>
android log system目前有四种类型的log: main, system, radio, event. 其中前三种可以分为同一类型,log可以通过android_log_processLogBuffer()直接解析成人类可以读懂的文字. event log则稍有不同,解析后的log也要通过相应的文件才能读懂. 这里主要看一下常规log的解析.
</p>

<p>
android_log_processLogBuffer()的参数有两个,第一个是logger_entry变量,第二个是AndroidLogEntry变量,其实这两个结构体的内容大致相同,只不过后一个包含的信息更多一些.
</p>
<div class="org-src-container">

<pre class="src src-c"><span style="color: #F0DFAF; font-weight: bold;">struct</span> <span style="color: #7CB8BB;">logger_entry</span> {
    <span style="color: #7CB8BB;">uint16_t</span>    <span style="color: #DFAF8F;">len</span>;    <span style="color: #5F7F5F;">/* </span><span style="color: #7F9F7F;">length of the payload </span><span style="color: #5F7F5F;">*/</span>
    <span style="color: #7CB8BB;">uint16_t</span>    <span style="color: #DFAF8F;">__pad</span>;  <span style="color: #5F7F5F;">/* </span><span style="color: #7F9F7F;">no matter what, we get 2 bytes of padding </span><span style="color: #5F7F5F;">*/</span>
    <span style="color: #7CB8BB;">int32_t</span>     <span style="color: #DFAF8F;">pid</span>;    <span style="color: #5F7F5F;">/* </span><span style="color: #7F9F7F;">generating process's pid </span><span style="color: #5F7F5F;">*/</span>
    <span style="color: #7CB8BB;">int32_t</span>     <span style="color: #DFAF8F;">tid</span>;    <span style="color: #5F7F5F;">/* </span><span style="color: #7F9F7F;">generating process's tid </span><span style="color: #5F7F5F;">*/</span>
    <span style="color: #7CB8BB;">int32_t</span>     <span style="color: #DFAF8F;">sec</span>;    <span style="color: #5F7F5F;">/* </span><span style="color: #7F9F7F;">seconds since Epoch </span><span style="color: #5F7F5F;">*/</span>
    <span style="color: #7CB8BB;">int32_t</span>     <span style="color: #DFAF8F;">nsec</span>;   <span style="color: #5F7F5F;">/* </span><span style="color: #7F9F7F;">nanoseconds </span><span style="color: #5F7F5F;">*/</span>
    <span style="color: #7CB8BB;">char</span>        <span style="color: #DFAF8F;">msg</span>[0]; <span style="color: #5F7F5F;">/* </span><span style="color: #7F9F7F;">the entry's payload </span><span style="color: #5F7F5F;">*/</span>
};

<span style="color: #F0DFAF; font-weight: bold;">typedef</span> <span style="color: #F0DFAF; font-weight: bold;">struct</span> <span style="color: #7CB8BB;">AndroidLogEntry_t</span> {
    <span style="color: #7CB8BB;">time_t</span> <span style="color: #DFAF8F;">tv_sec</span>;
    <span style="color: #7CB8BB;">long</span> <span style="color: #DFAF8F;">tv_nsec</span>;
    <span style="color: #7CB8BB;">android_LogPriority</span> <span style="color: #DFAF8F;">priority</span>;
    <span style="color: #7CB8BB;">int32_t</span> <span style="color: #DFAF8F;">pid</span>;
    <span style="color: #7CB8BB;">int32_t</span> <span style="color: #DFAF8F;">tid</span>;
    <span style="color: #F0DFAF; font-weight: bold;">const</span> <span style="color: #7CB8BB;">char</span> * <span style="color: #DFAF8F;">tag</span>;
    <span style="color: #7CB8BB;">size_t</span> <span style="color: #DFAF8F;">messageLen</span>;
    <span style="color: #F0DFAF; font-weight: bold;">const</span> <span style="color: #7CB8BB;">char</span> * <span style="color: #DFAF8F;">message</span>;
} <span style="color: #7CB8BB;">AndroidLogEntry</span>;

<span style="color: #7CB8BB;">int</span> <span style="color: #93E0E3;">android_log_processLogBuffer</span>(<span style="color: #F0DFAF; font-weight: bold;">struct</span> <span style="color: #7CB8BB;">logger_entry</span> *<span style="color: #DFAF8F;">buf</span>,
                                 <span style="color: #7CB8BB;">AndroidLogEntry</span> *<span style="color: #DFAF8F;">entry</span>)
{
    entry-&gt;tv_sec = buf-&gt;sec;
    entry-&gt;tv_nsec = buf-&gt;nsec;
    entry-&gt;pid = buf-&gt;pid;
    entry-&gt;tid = buf-&gt;tid;

    <span style="color: #7CB8BB;">int</span> <span style="color: #DFAF8F;">msgStart</span> = -1;
    <span style="color: #7CB8BB;">int</span> <span style="color: #DFAF8F;">msgEnd</span> = -1;

    <span style="color: #7CB8BB;">int</span> <span style="color: #DFAF8F;">i</span>;
    <span style="color: #F0DFAF; font-weight: bold;">for</span> (i = 1; i &lt; buf-&gt;len; i++) {
        <span style="color: #F0DFAF; font-weight: bold;">if</span> (buf-&gt;msg[i] == <span style="color: #CC9393;">'\0'</span>) {
            <span style="color: #F0DFAF; font-weight: bold;">if</span> (msgStart == -1) {
                msgStart = i + 1;
            } <span style="color: #F0DFAF; font-weight: bold;">else</span> {
                msgEnd = i;
                <span style="color: #F0DFAF; font-weight: bold;">break</span>;
            }
        }
    }

    entry-&gt;priority = buf-&gt;msg[0];
    entry-&gt;tag = buf-&gt;msg + 1;
    entry-&gt;message = buf-&gt;msg + msgStart;
    entry-&gt;messageLen = msgEnd - msgStart;

    <span style="color: #F0DFAF; font-weight: bold;">return</span> 0;
}
</pre>
</div>
<p>
可以看到转换函数主要是把logger_entry的msg给分割成三个部分:priority, tag, message.
</p>

<p>
接着会调用android_log_shouldPrintLine()检查该该tag及该level的log是否应该被打印,如果是,则调用android_log_printLogLine()打印.
</p>
<div class="org-src-container">

<pre class="src src-c">        <span style="color: #5F7F5F;">/* </span><span style="color: #7F9F7F;">android_log_printLogLine() </span><span style="color: #5F7F5F;">*/</span>

    outBuffer = android_log_formatLogLine(p_format, defaultBuffer,
            <span style="color: #F0DFAF; font-weight: bold;">sizeof</span>(defaultBuffer), entry, &amp;totalLen);

    <span style="color: #F0DFAF; font-weight: bold;">do</span> {
        ret = write(fd, outBuffer, totalLen);
    } <span style="color: #F0DFAF; font-weight: bold;">while</span> (ret &lt; 0 &amp;&amp; errno == EINTR);

        ......

    <span style="color: #F0DFAF; font-weight: bold;">if</span> (outBuffer != defaultBuffer) {
        free(outBuffer);
    }

&#21069;&#38754;&#35762;&#36807;&#21487;&#20197;&#36890;&#36807;&#21442;&#25968;<span style="color: #CC9393;">"-v"</span>&#35774;&#32622;&#25171;&#21360;&#30340;log&#26684;&#24335;,&#25152;&#20197;android_log_formatLogLine()<span style="color: #7CB8BB;">&#30340;&#20316;&#29992;&#23601;&#26159;&#23558;entry</span> <span style="color: #DFAF8F;">&#36716;&#25442;&#20026;&#26368;&#32456;&#30340;&#25171;&#21360;&#26684;&#24335;</span>.


        <span style="color: #5F7F5F;">/* </span><span style="color: #7F9F7F;">android_log_formatLogLine() </span><span style="color: #5F7F5F;">*/</span>

    priChar = filterPriToChar(entry-&gt;priority);
    ptm = localtime(&amp;(entry-&gt;tv_sec));
    strftime(timeBuf, <span style="color: #F0DFAF; font-weight: bold;">sizeof</span>(timeBuf), <span style="color: #CC9393;">"%m-%d %H:%M:%S"</span>, ptm);

    <span style="color: #7CB8BB;">size_t</span> <span style="color: #DFAF8F;">prefixLen</span>, <span style="color: #DFAF8F;">suffixLen</span>;

    <span style="color: #F0DFAF; font-weight: bold;">switch</span> (p_format-&gt;format) {
        <span style="color: #F0DFAF; font-weight: bold;">case</span> FORMAT_TAG:
            prefixLen = snprintf(prefixBuf, <span style="color: #F0DFAF; font-weight: bold;">sizeof</span>(prefixBuf),
                <span style="color: #CC9393;">"%c/%-8s: "</span>, priChar, entry-&gt;tag);
            strcpy(suffixBuf, <span style="color: #CC9393;">"\n"</span>); suffixLen = 1;
            <span style="color: #F0DFAF; font-weight: bold;">break</span>;
        <span style="color: #F0DFAF; font-weight: bold;">case</span> FORMAT_PROCESS:
            prefixLen = snprintf(prefixBuf, <span style="color: #F0DFAF; font-weight: bold;">sizeof</span>(prefixBuf),
                <span style="color: #CC9393;">"%c(%5d) "</span>, priChar, entry-&gt;pid);
            suffixLen = snprintf(suffixBuf, <span style="color: #F0DFAF; font-weight: bold;">sizeof</span>(suffixBuf),
                <span style="color: #CC9393;">"  (%s)\n"</span>, entry-&gt;tag);
            <span style="color: #F0DFAF; font-weight: bold;">break</span>;
        <span style="color: #F0DFAF; font-weight: bold;">case</span> FORMAT_THREAD:
            prefixLen = snprintf(prefixBuf, <span style="color: #F0DFAF; font-weight: bold;">sizeof</span>(prefixBuf),
                <span style="color: #CC9393;">"%c(%5d:%5d) "</span>, priChar, entry-&gt;pid, entry-&gt;tid);
            strcpy(suffixBuf, <span style="color: #CC9393;">"\n"</span>);
            suffixLen = 1;
            <span style="color: #F0DFAF; font-weight: bold;">break</span>;
        <span style="color: #F0DFAF; font-weight: bold;">case</span> FORMAT_RAW:
            prefixBuf[0] = 0;
            prefixLen = 0;
            strcpy(suffixBuf, <span style="color: #CC9393;">"\n"</span>);
            suffixLen = 1;
            <span style="color: #F0DFAF; font-weight: bold;">break</span>;
        <span style="color: #F0DFAF; font-weight: bold;">case</span> FORMAT_TIME:
            prefixLen = snprintf(prefixBuf, <span style="color: #F0DFAF; font-weight: bold;">sizeof</span>(prefixBuf),
                <span style="color: #CC9393;">"%s.%03ld %c/%-8s(%5d): "</span>, timeBuf, entry-&gt;tv_nsec / 1000000,
                priChar, entry-&gt;tag, entry-&gt;pid);
            strcpy(suffixBuf, <span style="color: #CC9393;">"\n"</span>);
            suffixLen = 1;
            <span style="color: #F0DFAF; font-weight: bold;">break</span>;
        <span style="color: #F0DFAF; font-weight: bold;">case</span> FORMAT_THREADTIME:
            prefixLen = snprintf(prefixBuf, <span style="color: #F0DFAF; font-weight: bold;">sizeof</span>(prefixBuf),
                <span style="color: #CC9393;">"%s.%03ld %5d %5d %c %-8s: "</span>, timeBuf, entry-&gt;tv_nsec / 1000000,
                entry-&gt;pid, entry-&gt;tid, priChar, entry-&gt;tag);
            strcpy(suffixBuf, <span style="color: #CC9393;">"\n"</span>);
            suffixLen = 1;
            <span style="color: #F0DFAF; font-weight: bold;">break</span>;
        <span style="color: #F0DFAF; font-weight: bold;">case</span> FORMAT_LONG:
            prefixLen = snprintf(prefixBuf, <span style="color: #F0DFAF; font-weight: bold;">sizeof</span>(prefixBuf),
                <span style="color: #CC9393;">"[ %s.%03ld %5d:%5d %c/%-8s ]\n"</span>,
                timeBuf, entry-&gt;tv_nsec / 1000000, entry-&gt;pid,
                entry-&gt;tid, priChar, entry-&gt;tag);
            strcpy(suffixBuf, <span style="color: #CC9393;">"\n\n"</span>);
            suffixLen = 2;
            prefixSuffixIsHeaderFooter = 1;
            <span style="color: #F0DFAF; font-weight: bold;">break</span>;
        <span style="color: #F0DFAF; font-weight: bold;">case</span> FORMAT_BRIEF:
        <span style="color: #F0DFAF; font-weight: bold;">default</span>:
            prefixLen = snprintf(prefixBuf, <span style="color: #F0DFAF; font-weight: bold;">sizeof</span>(prefixBuf),
                <span style="color: #CC9393;">"%c/%-8s(%5d): "</span>, priChar, entry-&gt;tag, entry-&gt;pid);
            strcpy(suffixBuf, <span style="color: #CC9393;">"\n"</span>);
            suffixLen = 1;
            <span style="color: #F0DFAF; font-weight: bold;">break</span>;
    }

    <span style="color: #7CB8BB;">size_t</span> <span style="color: #DFAF8F;">numLines</span>;
    <span style="color: #7CB8BB;">size_t</span> <span style="color: #DFAF8F;">i</span>;
    <span style="color: #7CB8BB;">char</span> *<span style="color: #DFAF8F;">p</span>;
    <span style="color: #7CB8BB;">size_t</span> <span style="color: #DFAF8F;">bufferSize</span>;
    <span style="color: #F0DFAF; font-weight: bold;">const</span> <span style="color: #7CB8BB;">char</span> *<span style="color: #DFAF8F;">pm</span>;


    ret[0] = <span style="color: #CC9393;">'\0'</span>;       <span style="color: #5F7F5F;">/* </span><span style="color: #7F9F7F;">to start strcat off </span><span style="color: #5F7F5F;">*/</span>

    p = ret;
    pm = entry-&gt;message;
</pre>
</div>
<p>
首先会将数字格式的priority转为字符格式,接着生成格式化时间字符串.然后进入switch判断当前的format形式,并生成对应的prefix. 因为snprintf/vsnprintf有个特点:虽然它们最多只会向buffer写入指定长度的字符串(也就是说,如果buffer不足,字符串会被截断),但是,它们的返回值确是理想情况下(buffer足够大)可以写入的字符串长度.所以程序接下来会判断返回值跟buffer size是否相等.
</p>

<div class="org-src-container">

<pre class="src src-c">        <span style="color: #5F7F5F;">/* </span><span style="color: #7F9F7F;">android_log_formatLogLine() </span><span style="color: #5F7F5F;">*/</span>
    <span style="color: #F0DFAF; font-weight: bold;">if</span>(prefixLen &gt;= <span style="color: #F0DFAF; font-weight: bold;">sizeof</span>(prefixBuf))
        prefixLen = <span style="color: #F0DFAF; font-weight: bold;">sizeof</span>(prefixBuf) - 1;
    <span style="color: #F0DFAF; font-weight: bold;">if</span>(suffixLen &gt;= <span style="color: #F0DFAF; font-weight: bold;">sizeof</span>(suffixBuf))
        suffixLen = <span style="color: #F0DFAF; font-weight: bold;">sizeof</span>(suffixBuf) - 1;

&#25509;&#30528;&#20250;&#36941;&#21382;msg&#20013;&#30340;<span style="color: #CC9393;">"\n"</span>&#21028;&#26029;&#35813;&#26465;log&#38656;&#35201;&#20998;&#20960;&#34892;&#25171;&#20986;,&#27599;&#34892;&#25171;&#20986;&#30340;log&#37117;&#20250;&#26377;prefix&#23383;&#31526;&#20018;

        <span style="color: #5F7F5F;">/* </span><span style="color: #7F9F7F;">android_log_formatLogLine() </span><span style="color: #5F7F5F;">*/</span>
    <span style="color: #F0DFAF; font-weight: bold;">if</span> (prefixSuffixIsHeaderFooter) {
        numLines = 1;
    } <span style="color: #F0DFAF; font-weight: bold;">else</span> {
        pm = entry-&gt;message;
        numLines = 0;

        <span style="color: #F0DFAF; font-weight: bold;">while</span> (pm &lt; (entry-&gt;message + entry-&gt;messageLen)) {
            <span style="color: #F0DFAF; font-weight: bold;">if</span> (*pm++ == <span style="color: #CC9393;">'\n'</span>) numLines++;
        }
        <span style="color: #F0DFAF; font-weight: bold;">if</span> (pm &gt; entry-&gt;message &amp;&amp; *(pm-1) != <span style="color: #CC9393;">'\n'</span>) numLines++;
    }
</pre>
</div>
<p>
在函数参数中已经传入了存log的buffer,但是,如果需要打印的log 长度超过了buffer size,则系统会重新malloc一个新的buffer,记住:这个buffer需要在函数外free掉!!!!(logcat的做法是判断函数返回值是否等于传入的buffer,如果不是,则表示有新buffer malloc,就会free掉)
</p>
<div class="org-src-container">

<pre class="src src-c">    <span style="color: #5F7F5F;">/* </span><span style="color: #7F9F7F;">android_log_formatLogLine() </span><span style="color: #5F7F5F;">*/</span>
bufferSize = (numLines * (prefixLen + suffixLen)) + entry-&gt;messageLen + 1;

<span style="color: #F0DFAF; font-weight: bold;">if</span> (defaultBufferSize &gt;= bufferSize) {
    ret = defaultBuffer;
} <span style="color: #F0DFAF; font-weight: bold;">else</span> {
    ret = (<span style="color: #7CB8BB;">char</span> *)malloc(bufferSize);

    <span style="color: #F0DFAF; font-weight: bold;">if</span> (ret == <span style="color: #BFEBBF;">NULL</span>) {
        <span style="color: #F0DFAF; font-weight: bold;">return</span> ret;
    }
}

    <span style="color: #5F7F5F;">/* </span><span style="color: #7F9F7F;">android_log_printLogLine() </span><span style="color: #5F7F5F;">*/</span>
<span style="color: #F0DFAF; font-weight: bold;">if</span> (outBuffer != defaultBuffer) {
    free(outBuffer);
}
</pre>
</div>
<p>
最后是生成最终的log字符串.对于"long"格式的log format来讲,prefix只需打印一次,所以不需要遍历msg中的"\n".否则,对于每行log都要加上prefix.
</p>

<div class="org-src-container">

<pre class="src src-c"><span style="color: #F0DFAF; font-weight: bold;">if</span> (prefixSuffixIsHeaderFooter) {
    strcat(p, prefixBuf);
    p += prefixLen;
    strncat(p, entry-&gt;message, entry-&gt;messageLen);
    p += entry-&gt;messageLen;
    strcat(p, suffixBuf);
    p += suffixLen;
} <span style="color: #F0DFAF; font-weight: bold;">else</span> {
    <span style="color: #F0DFAF; font-weight: bold;">while</span>(pm &lt; (entry-&gt;message + entry-&gt;messageLen)) {
        <span style="color: #F0DFAF; font-weight: bold;">const</span> <span style="color: #7CB8BB;">char</span> *<span style="color: #DFAF8F;">lineStart</span>;
        <span style="color: #7CB8BB;">size_t</span> <span style="color: #DFAF8F;">lineLen</span>;
        lineStart = pm;

        <span style="color: #5F7F5F;">// </span><span style="color: #7F9F7F;">Find the next end-of-line in message</span>
        <span style="color: #F0DFAF; font-weight: bold;">while</span> (pm &lt; (entry-&gt;message + entry-&gt;messageLen)
                &amp;&amp; *pm != <span style="color: #CC9393;">'\n'</span>) pm++;
        lineLen = pm - lineStart;

        strcat(p, prefixBuf);
        p += prefixLen;
        strncat(p, lineStart, lineLen);
        p += lineLen;
        strcat(p, suffixBuf);
        p += suffixLen;

        <span style="color: #F0DFAF; font-weight: bold;">if</span> (*pm == <span style="color: #CC9393;">'\n'</span>) pm++;
    }
}

<span style="color: #F0DFAF; font-weight: bold;">if</span> (p_outLength != <span style="color: #BFEBBF;">NULL</span>) {
    *p_outLength = p - ret;
}

<span style="color: #F0DFAF; font-weight: bold;">return</span> ret;
</pre>
</div>
<p>
函数返回后,就把最终字符串写到输出. 
</p>

<p>
OK,logcat的用法及实现流程到这里就基本结束了.
</p>
</div>
</div>
</div>
<div id="outline-container-orgheadline14" class="outline-2">
<h2 id="orgheadline14">Liblog</h2>
<div class="outline-text-2" id="text-orgheadline14">
<p>
Androi系统提供了一套完整的API供其他程序调用输出log,这套API分为Java 层和 native 层,不过两个API最终都是通过file system将log写入kernel 层的logger device.
</p>
</div>

<div id="outline-container-orgheadline15" class="outline-3">
<h3 id="orgheadline15">ALOGX 系列</h3>
<div class="outline-text-3" id="text-orgheadline15">
<p>
以native层为例,如果我们要开发'.cpp'或'.c'程序,那么可以call下列API之以写出不同level的log
</p>
<div class="org-src-container">

<pre class="src src-c"><span style="color: #94BFF3;">#define</span> <span style="color: #DFAF8F;">LOG_TAG</span> <span style="color: #CC9393;">"HeloWorld"</span>
ALOGV(<span style="color: #CC9393;">"hello world,level verbose"</span>);
ALOGD(<span style="color: #CC9393;">"hello world,level debug"</span>);
ALOGI(<span style="color: #CC9393;">"hello world,level info"</span>);
ALOGE(<span style="color: #CC9393;">"hello world,level error"</span>);
ALOGW(<span style="color: #CC9393;">"hello world,level warning"</span>);
</pre>
</div>
<p>
这里通常都需要定义一个LOG_TAG, 作为一个完整log的一部分,可以唯一的定位一个module. ALOGX()系列API的实现通过宏定位到共同的一组函数.
</p>
<div class="org-src-container">

<pre class="src src-c"><span style="color: #94BFF3;">#if</span><span style="color: #F0DFAF; font-weight: bold;">n</span><span style="color: #94BFF3;">def</span> ALOGE
<span style="color: #94BFF3;">#define</span> <span style="color: #93E0E3;">ALOGE</span>(...) ((<span style="color: #7CB8BB;">void</span>)ALOG(LOG_ERROR, LOG_TAG, __VA_ARGS__))
<span style="color: #94BFF3;">#endif</span>

<span style="color: #94BFF3;">#if</span><span style="color: #F0DFAF; font-weight: bold;">n</span><span style="color: #94BFF3;">def</span> ALOG
<span style="color: #94BFF3;">#define</span> <span style="color: #93E0E3;">ALOG</span>(<span style="color: #DFAF8F;">priority</span>, <span style="color: #DFAF8F;">tag</span>, ...) \
    LOG_PRI(ANDROID_##priority, tag, __VA_ARGS__)
<span style="color: #94BFF3;">#endif</span>

<span style="color: #94BFF3;">#if</span><span style="color: #F0DFAF; font-weight: bold;">n</span><span style="color: #94BFF3;">def</span> LOG_PRI
<span style="color: #94BFF3;">#define</span> <span style="color: #93E0E3;">LOG_PRI</span>(<span style="color: #DFAF8F;">priority</span>, <span style="color: #DFAF8F;">tag</span>, ...) \
    android_printLog(priority, tag, __VA_ARGS__)
<span style="color: #94BFF3;">#endif</span>

<span style="color: #94BFF3;">#define</span> <span style="color: #93E0E3;">android_printLog</span>(<span style="color: #DFAF8F;">prio</span>, <span style="color: #DFAF8F;">tag</span>, <span style="color: #DFAF8F;">fmt</span>...) \
    __android_log_print(prio, tag, fmt)

<span style="color: #7CB8BB;">int</span> <span style="color: #93E0E3;">__android_log_print</span>(<span style="color: #7CB8BB;">int</span> <span style="color: #DFAF8F;">prio</span>, <span style="color: #F0DFAF; font-weight: bold;">const</span> <span style="color: #7CB8BB;">char</span> *<span style="color: #DFAF8F;">tag</span>, <span style="color: #F0DFAF; font-weight: bold;">const</span> <span style="color: #7CB8BB;">char</span> *<span style="color: #DFAF8F;">fmt</span>, ...)
{
    <span style="color: #7CB8BB;">va_list</span> <span style="color: #DFAF8F;">ap</span>;
    <span style="color: #7CB8BB;">char</span> <span style="color: #DFAF8F;">buf</span>[LOG_BUF_SIZE];

    va_start(ap, fmt);
    vsnprintf(buf, LOG_BUF_SIZE, fmt, ap);
    va_end(ap);

    <span style="color: #F0DFAF; font-weight: bold;">return</span> __android_log_write(prio, tag, buf);
}
</pre>
</div>
<p>
__android_log_print()通过va_list变量把format形式字符串生成最终的字符串,然后调用__android_log_write(),这里的参数tag就是之前定义的 LOG_TAG. 而prio是一个整数值,中[logcat](../Android-logcat/)讲到过,最后通过logcat抓出来后,会将整形log level转换为字符型.
</p>

<div class="org-src-container">

<pre class="src src-c"><span style="color: #7CB8BB;">int</span> <span style="color: #93E0E3;">__android_log_write</span>(<span style="color: #7CB8BB;">int</span> <span style="color: #DFAF8F;">prio</span>, <span style="color: #F0DFAF; font-weight: bold;">const</span> <span style="color: #7CB8BB;">char</span> *<span style="color: #DFAF8F;">tag</span>, <span style="color: #F0DFAF; font-weight: bold;">const</span> <span style="color: #7CB8BB;">char</span> *<span style="color: #DFAF8F;">msg</span>)
{
    <span style="color: #F0DFAF; font-weight: bold;">struct</span> <span style="color: #7CB8BB;">iovec</span> <span style="color: #DFAF8F;">vec</span>[3];
    <span style="color: #7CB8BB;">log_id_t</span> <span style="color: #DFAF8F;">log_id</span> = LOG_ID_MAIN;

    <span style="color: #F0DFAF; font-weight: bold;">if</span> (<span style="color: #F0DFAF; font-weight: bold;">!</span>tag)
        tag = <span style="color: #CC9393;">""</span>;

    <span style="color: #5F7F5F;">/* </span><span style="color: #7F9F7F;">XXX: This needs to go! </span><span style="color: #5F7F5F;">*/</span>
    <span style="color: #F0DFAF; font-weight: bold;">if</span> (<span style="color: #F0DFAF; font-weight: bold;">!</span>strcmp(tag, <span style="color: #CC9393;">"HTC_RIL"</span>) ||
        <span style="color: #F0DFAF; font-weight: bold;">!</span>strncmp(tag, <span style="color: #CC9393;">"RIL"</span>, 3) || <span style="color: #5F7F5F;">/* </span><span style="color: #7F9F7F;">Any log tag with "RIL" as the prefix </span><span style="color: #5F7F5F;">*/</span>
        <span style="color: #F0DFAF; font-weight: bold;">!</span>strncmp(tag, <span style="color: #CC9393;">"IMS"</span>, 3) || <span style="color: #5F7F5F;">/* </span><span style="color: #7F9F7F;">Any log tag with "IMS" as the prefix </span><span style="color: #5F7F5F;">*/</span>
        <span style="color: #F0DFAF; font-weight: bold;">!</span>strcmp(tag, <span style="color: #CC9393;">"AT"</span>) ||
        <span style="color: #F0DFAF; font-weight: bold;">!</span>strcmp(tag, <span style="color: #CC9393;">"GSM"</span>) ||
        <span style="color: #F0DFAF; font-weight: bold;">!</span>strcmp(tag, <span style="color: #CC9393;">"STK"</span>) ||
        <span style="color: #F0DFAF; font-weight: bold;">!</span>strcmp(tag, <span style="color: #CC9393;">"CDMA"</span>) ||
        <span style="color: #F0DFAF; font-weight: bold;">!</span>strcmp(tag, <span style="color: #CC9393;">"PHONE"</span>) ||
        <span style="color: #F0DFAF; font-weight: bold;">!</span>strcmp(tag, <span style="color: #CC9393;">"SMS"</span>))
            log_id = LOG_ID_RADIO;

    vec[0].iov_base   = (<span style="color: #7CB8BB;">unsigned</span> <span style="color: #7CB8BB;">char</span> *) &amp;prio;
    vec[0].iov_len    = 1;
    vec[1].iov_base   = (<span style="color: #7CB8BB;">void</span> *) tag;
    vec[1].iov_len    = strlen(tag) + 1;
    vec[2].iov_base   = (<span style="color: #7CB8BB;">void</span> *) msg;
    vec[2].iov_len    = strlen(msg) + 1;

    <span style="color: #F0DFAF; font-weight: bold;">return</span> write_to_log(log_id, vec, 3);
}
</pre>
</div>
<p>
Android log 系统目前有四种类型的log:main,system,radio,events. 后三种一般都是系统的一些特殊的log,除此之外,自己开发的程序,log都默认写到main中. 所以程序最开始把 log_id 设为 LOG_ID_MAIN. 不过程序接下来会判断tag参数,如果tag符合radio log的规则的话,则将log_id改为 LOG_ID_RADIO. 接着把传入的三个参数放到一个iovec变量中. 并调用write_to_log()
</p>

<div class="org-src-container">

<pre class="src src-c"><span style="color: #F0DFAF; font-weight: bold;">struct</span> <span style="color: #7CB8BB;">iovec</span> {
    <span style="color: #F0DFAF; font-weight: bold;">const</span> <span style="color: #7CB8BB;">void</span>*  <span style="color: #DFAF8F;">iov_base</span>;
    <span style="color: #7CB8BB;">size_t</span>       <span style="color: #DFAF8F;">iov_len</span>;
};

<span style="color: #F0DFAF; font-weight: bold;">static</span> <span style="color: #7CB8BB;">int</span> (*<span style="color: #93E0E3;">write_to_log</span>)(<span style="color: #7CB8BB;">log_id_t</span>, <span style="color: #F0DFAF; font-weight: bold;">struct</span> <span style="color: #7CB8BB;">iovec</span> *<span style="color: #DFAF8F;">vec</span>, <span style="color: #7CB8BB;">size_t</span> <span style="color: #DFAF8F;">nr</span>) = __write_to_log_init;
</pre>
</div>
<p>
write_to_log()是一个指针函数,这里的实现用了一点小伎俩. 最开始这个指针就被赋值为__write_to_log_init, 所以,在第一次调用该函数的时候,调用的就是 __write_to_log_init()
</p>

<div class="org-src-container">

<pre class="src src-c"><span style="color: #F0DFAF; font-weight: bold;">static</span> <span style="color: #7CB8BB;">int</span> <span style="color: #93E0E3;">__write_to_log_init</span>(<span style="color: #7CB8BB;">log_id_t</span> <span style="color: #DFAF8F;">log_id</span>, <span style="color: #F0DFAF; font-weight: bold;">struct</span> <span style="color: #7CB8BB;">iovec</span> *<span style="color: #DFAF8F;">vec</span>, <span style="color: #7CB8BB;">size_t</span> <span style="color: #DFAF8F;">nr</span>)
{
<span style="color: #94BFF3;">#ifdef</span> HAVE_PTHREADS
    pthread_mutex_lock(&amp;log_init_lock);
<span style="color: #94BFF3;">#endif</span>

    <span style="color: #F0DFAF; font-weight: bold;">if</span> (write_to_log == __write_to_log_init) {
        log_fds[LOG_ID_MAIN] = log_open(<span style="color: #CC9393;">"/dev/"</span>LOGGER_LOG_MAIN, O_WRONLY);
        log_fds[LOG_ID_RADIO] = log_open(<span style="color: #CC9393;">"/dev/"</span>LOGGER_LOG_RADIO, O_WRONLY);
        log_fds[LOG_ID_EVENTS] = log_open(<span style="color: #CC9393;">"/dev/"</span>LOGGER_LOG_EVENTS, O_WRONLY);
        log_fds[LOG_ID_SYSTEM] = log_open(<span style="color: #CC9393;">"/dev/"</span>LOGGER_LOG_SYSTEM, O_WRONLY);

        write_to_log = __write_to_log_kernel;

        <span style="color: #F0DFAF; font-weight: bold;">if</span> (log_fds[LOG_ID_MAIN] &lt; 0 || log_fds[LOG_ID_RADIO] &lt; 0 ||
                log_fds[LOG_ID_EVENTS] &lt; 0) {
            log_close(log_fds[LOG_ID_MAIN]);
            log_close(log_fds[LOG_ID_RADIO]);
            log_close(log_fds[LOG_ID_EVENTS]);
            log_fds[LOG_ID_MAIN] = -1;
            log_fds[LOG_ID_RADIO] = -1;
            log_fds[LOG_ID_EVENTS] = -1;
            write_to_log = __write_to_log_null;
        }

        <span style="color: #F0DFAF; font-weight: bold;">if</span> (log_fds[LOG_ID_SYSTEM] &lt; 0) {
            log_fds[LOG_ID_SYSTEM] = log_fds[LOG_ID_MAIN];
        }
    }

<span style="color: #94BFF3;">#ifdef</span> HAVE_PTHREADS
    pthread_mutex_unlock(&amp;log_init_lock);
<span style="color: #94BFF3;">#endif</span>

    <span style="color: #F0DFAF; font-weight: bold;">return</span> write_to_log(log_id, vec, nr);
}
</pre>
</div>
<p>
之所以要这样做,是因为在系统开启后第一次写通过ALOGX函数写log的时候,kernel 层的logger device还未被打开,所以要将这些device都打开,然后,将write_to_log改成__write_to_log_kernel. 在函数的最后,接着再调用一次write_to_log(),这次调用的就是__write_log_log_kernel 了.
</p>

<div class="org-src-container">

<pre class="src src-c"><span style="color: #F0DFAF; font-weight: bold;">static</span> <span style="color: #7CB8BB;">int</span> <span style="color: #93E0E3;">__write_to_log_kernel</span>(<span style="color: #7CB8BB;">log_id_t</span> <span style="color: #DFAF8F;">log_id</span>, <span style="color: #F0DFAF; font-weight: bold;">struct</span> <span style="color: #7CB8BB;">iovec</span> *<span style="color: #DFAF8F;">vec</span>, <span style="color: #7CB8BB;">size_t</span> <span style="color: #DFAF8F;">nr</span>)
{
    <span style="color: #7CB8BB;">ssize_t</span> <span style="color: #DFAF8F;">ret</span>;
    <span style="color: #7CB8BB;">int</span> <span style="color: #DFAF8F;">log_fd</span>;

    <span style="color: #F0DFAF; font-weight: bold;">if</span> (<span style="color: #5F7F5F;">/*</span><span style="color: #7F9F7F;">(int)log_id &gt;= 0 &amp;&amp;</span><span style="color: #5F7F5F;">*/</span> (<span style="color: #7CB8BB;">int</span>)log_id &lt; (<span style="color: #7CB8BB;">int</span>)LOG_ID_MAX) {
        log_fd = log_fds[(<span style="color: #7CB8BB;">int</span>)log_id];
    } <span style="color: #F0DFAF; font-weight: bold;">else</span> {
        <span style="color: #F0DFAF; font-weight: bold;">return</span> EBADF;
    }

    <span style="color: #F0DFAF; font-weight: bold;">do</span> {
        ret = log_writev(log_fd, vec, nr);
    } <span style="color: #F0DFAF; font-weight: bold;">while</span> (ret &lt; 0 &amp;&amp; errno == EINTR);

    <span style="color: #F0DFAF; font-weight: bold;">return</span> ret;
}
</pre>
</div>
<p>
函数将log_id转为log_fd后,就直接调用 log_writev()函数
</p>

<div class="org-src-container">

<pre class="src src-c"><span style="color: #94BFF3;">#define</span> <span style="color: #93E0E3;">log_writev</span>(<span style="color: #DFAF8F;">filedes</span>, <span style="color: #DFAF8F;">vector</span>, <span style="color: #DFAF8F;">count</span>) writev(filedes, vector, count)
</pre>
</div>
<p>
log_writev()就被映射到具体的driver层的writev()函数.这样,一条log就被写入到了kernel层的device中.
</p>
</div>
</div>

<div id="outline-container-orgheadline16" class="outline-3">
<h3 id="orgheadline16">SLOGX</h3>
<div class="outline-text-3" id="text-orgheadline16">
<p>
SLOGX()API族用于生成system log,log被写到system这个logger device中,SLOGX的实现跟main log基本相同,只是默认的log id是system而不是main
</p>

<div class="org-src-container">

<pre class="src src-c"><span style="color: #94BFF3;">#define</span> <span style="color: #93E0E3;">SLOGV</span>(...) ((<span style="color: #7CB8BB;">void</span>)__android_log_buf_print(LOG_ID_SYSTEM, ANDROID_LOG_VERBOSE, LOG_TAG, __VA_ARGS__))

<span style="color: #7CB8BB;">int</span> <span style="color: #93E0E3;">__android_log_buf_print</span>(<span style="color: #7CB8BB;">int</span> <span style="color: #DFAF8F;">bufID</span>, <span style="color: #7CB8BB;">int</span> <span style="color: #DFAF8F;">prio</span>, <span style="color: #F0DFAF; font-weight: bold;">const</span> <span style="color: #7CB8BB;">char</span> *<span style="color: #DFAF8F;">tag</span>, <span style="color: #F0DFAF; font-weight: bold;">const</span> <span style="color: #7CB8BB;">char</span> *<span style="color: #DFAF8F;">fmt</span>, ...)
{
    <span style="color: #7CB8BB;">va_list</span> <span style="color: #DFAF8F;">ap</span>;
    <span style="color: #7CB8BB;">char</span> <span style="color: #DFAF8F;">buf</span>[LOG_BUF_SIZE];

    va_start(ap, fmt);
    vsnprintf(buf, LOG_BUF_SIZE, fmt, ap);
    va_end(ap);

    <span style="color: #F0DFAF; font-weight: bold;">return</span> __android_log_buf_write(bufID, prio, tag, buf);
}

<span style="color: #7CB8BB;">int</span> <span style="color: #93E0E3;">__android_log_buf_write</span>(<span style="color: #7CB8BB;">int</span> <span style="color: #DFAF8F;">bufID</span>, <span style="color: #7CB8BB;">int</span> <span style="color: #DFAF8F;">prio</span>, <span style="color: #F0DFAF; font-weight: bold;">const</span> <span style="color: #7CB8BB;">char</span> *<span style="color: #DFAF8F;">tag</span>, <span style="color: #F0DFAF; font-weight: bold;">const</span> <span style="color: #7CB8BB;">char</span> *<span style="color: #DFAF8F;">msg</span>)
{
    <span style="color: #F0DFAF; font-weight: bold;">struct</span> <span style="color: #7CB8BB;">iovec</span> <span style="color: #DFAF8F;">vec</span>[3];

    <span style="color: #F0DFAF; font-weight: bold;">if</span> (<span style="color: #F0DFAF; font-weight: bold;">!</span>tag)
        tag = <span style="color: #CC9393;">""</span>;

    <span style="color: #5F7F5F;">/* </span><span style="color: #7F9F7F;">XXX: This needs to go! </span><span style="color: #5F7F5F;">*/</span>
    <span style="color: #F0DFAF; font-weight: bold;">if</span> (<span style="color: #F0DFAF; font-weight: bold;">!</span>strcmp(tag, <span style="color: #CC9393;">"HTC_RIL"</span>) ||
        <span style="color: #F0DFAF; font-weight: bold;">!</span>strncmp(tag, <span style="color: #CC9393;">"RIL"</span>, 3) || <span style="color: #5F7F5F;">/* </span><span style="color: #7F9F7F;">Any log tag with "RIL" as the prefix </span><span style="color: #5F7F5F;">*/</span>
        <span style="color: #F0DFAF; font-weight: bold;">!</span>strncmp(tag, <span style="color: #CC9393;">"IMS"</span>, 3) || <span style="color: #5F7F5F;">/* </span><span style="color: #7F9F7F;">Any log tag with "IMS" as the prefix </span><span style="color: #5F7F5F;">*/</span>
        <span style="color: #F0DFAF; font-weight: bold;">!</span>strcmp(tag, <span style="color: #CC9393;">"AT"</span>) ||
        <span style="color: #F0DFAF; font-weight: bold;">!</span>strcmp(tag, <span style="color: #CC9393;">"GSM"</span>) ||
        <span style="color: #F0DFAF; font-weight: bold;">!</span>strcmp(tag, <span style="color: #CC9393;">"STK"</span>) ||
        <span style="color: #F0DFAF; font-weight: bold;">!</span>strcmp(tag, <span style="color: #CC9393;">"CDMA"</span>) ||
        <span style="color: #F0DFAF; font-weight: bold;">!</span>strcmp(tag, <span style="color: #CC9393;">"PHONE"</span>) ||
        <span style="color: #F0DFAF; font-weight: bold;">!</span>strcmp(tag, <span style="color: #CC9393;">"SMS"</span>))
            bufID = LOG_ID_RADIO;

    vec[0].iov_base   = (<span style="color: #7CB8BB;">unsigned</span> <span style="color: #7CB8BB;">char</span> *) &amp;prio;
    vec[0].iov_len    = 1;
    vec[1].iov_base   = (<span style="color: #7CB8BB;">void</span> *) tag;
    vec[1].iov_len    = strlen(tag) + 1;
    vec[2].iov_base   = (<span style="color: #7CB8BB;">void</span> *) msg;
    vec[2].iov_len    = strlen(msg) + 1;

    <span style="color: #F0DFAF; font-weight: bold;">return</span> write_to_log(bufID, vec, 3);
}
</pre>
</div>
</div>
</div>
<div id="outline-container-orgheadline17" class="outline-3">
<h3 id="orgheadline17">Events Log</h3>
<div class="outline-text-3" id="text-orgheadline17">
<p>
Events log是一种特殊的log,经常被用来记录系统的一些参数:例如电池的当前状态,剩余电量&#x2026;&#x2026;等等
</p>

<p>
Java层写event log的api为 writeEvent(),不过系统有四种该函数的实现.
</p>

<div class="org-src-container">

<pre class="src src-c">public <span style="color: #F0DFAF; font-weight: bold;">static</span> native <span style="color: #7CB8BB;">int</span> <span style="color: #93E0E3;">writeEvent</span>(<span style="color: #7CB8BB;">int</span> <span style="color: #DFAF8F;">tag</span>, <span style="color: #7CB8BB;">int</span> <span style="color: #DFAF8F;">value</span>);
public <span style="color: #F0DFAF; font-weight: bold;">static</span> native <span style="color: #7CB8BB;">int</span> <span style="color: #93E0E3;">writeEvent</span>(<span style="color: #7CB8BB;">int</span> <span style="color: #DFAF8F;">tag</span>, <span style="color: #7CB8BB;">long</span> <span style="color: #DFAF8F;">value</span>);
public <span style="color: #F0DFAF; font-weight: bold;">static</span> native <span style="color: #7CB8BB;">int</span> <span style="color: #93E0E3;">writeEvent</span>(<span style="color: #7CB8BB;">int</span> <span style="color: #DFAF8F;">tag</span>, <span style="color: #7CB8BB;">String</span> <span style="color: #DFAF8F;">str</span>);
public <span style="color: #F0DFAF; font-weight: bold;">static</span> native <span style="color: #7CB8BB;">int</span> <span style="color: #93E0E3;">writeEvent</span>(<span style="color: #7CB8BB;">int</span> <span style="color: #DFAF8F;">tag</span>, <span style="color: #7CB8BB;">Object</span>... <span style="color: #DFAF8F;">list</span>);
</pre>
</div>
<p>
系统会根据模块中call api时传入的参数对应调用不同的writeEvent()函数.这些函数分别对应到不同的JNI实现.首先看下参数为int/long时的JNI实现.
</p>

<div class="org-src-container">

<pre class="src src-c"><span style="color: #F0DFAF; font-weight: bold;">static</span> <span style="color: #7CB8BB;">jint</span> <span style="color: #93E0E3;">android_util_EventLog_writeEvent_Integer</span>(<span style="color: #7CB8BB;">JNIEnv</span>* <span style="color: #DFAF8F;">env</span>, <span style="color: #7CB8BB;">jobject</span> <span style="color: #DFAF8F;">clazz</span>,
                                                     <span style="color: #7CB8BB;">jint</span> <span style="color: #DFAF8F;">tag</span>, <span style="color: #7CB8BB;">jint</span> <span style="color: #DFAF8F;">value</span>)
{
    <span style="color: #F0DFAF; font-weight: bold;">return</span> android_btWriteLog(tag, EVENT_TYPE_INT, &amp;value, <span style="color: #F0DFAF; font-weight: bold;">sizeof</span>(value));
}

<span style="color: #F0DFAF; font-weight: bold;">static</span> <span style="color: #7CB8BB;">jint</span> <span style="color: #93E0E3;">android_util_EventLog_writeEvent_Long</span>(<span style="color: #7CB8BB;">JNIEnv</span>* <span style="color: #DFAF8F;">env</span>, <span style="color: #7CB8BB;">jobject</span> <span style="color: #DFAF8F;">clazz</span>,
                                                  <span style="color: #7CB8BB;">jint</span> <span style="color: #DFAF8F;">tag</span>, <span style="color: #7CB8BB;">jlong</span> <span style="color: #DFAF8F;">value</span>)
{
    <span style="color: #F0DFAF; font-weight: bold;">return</span> android_btWriteLog(tag, EVENT_TYPE_LONG, &amp;value, <span style="color: #F0DFAF; font-weight: bold;">sizeof</span>(value));
}
</pre>
</div>
<p>
这两个函数调用了一个共同的函数 android_btWriteLog()
</p>

<div class="org-src-container">

<pre class="src src-c"><span style="color: #94BFF3;">#define</span> <span style="color: #93E0E3;">android_btWriteLog</span>(<span style="color: #DFAF8F;">tag</span>, <span style="color: #DFAF8F;">type</span>, <span style="color: #DFAF8F;">payload</span>, <span style="color: #DFAF8F;">len</span>)  __android_log_btwrite(tag, type, payload, len)

<span style="color: #7CB8BB;">int</span> <span style="color: #93E0E3;">__android_log_btwrite</span>(<span style="color: #7CB8BB;">int32_t</span> <span style="color: #DFAF8F;">tag</span>, <span style="color: #7CB8BB;">char</span> <span style="color: #DFAF8F;">type</span>, <span style="color: #F0DFAF; font-weight: bold;">const</span> <span style="color: #7CB8BB;">void</span> *<span style="color: #DFAF8F;">payload</span>,
    <span style="color: #7CB8BB;">size_t</span> <span style="color: #DFAF8F;">len</span>)
{
    <span style="color: #F0DFAF; font-weight: bold;">struct</span> <span style="color: #7CB8BB;">iovec</span> <span style="color: #DFAF8F;">vec</span>[3];

    vec[0].iov_base = &amp;tag;
    vec[0].iov_len = <span style="color: #F0DFAF; font-weight: bold;">sizeof</span>(tag);
    vec[1].iov_base = &amp;type;
    vec[1].iov_len = <span style="color: #F0DFAF; font-weight: bold;">sizeof</span>(type);
    vec[2].iov_base = (<span style="color: #7CB8BB;">void</span>*)payload;
    vec[2].iov_len = len;

    <span style="color: #F0DFAF; font-weight: bold;">return</span> write_to_log(LOG_ID_EVENTS, vec, 3);
}
</pre>
</div>
<p>
是不是很熟悉?没错,最后跟main log流程一样,都调用write_to_log(0函数. 下面是参数为string时的JNI实现:
</p>

<div class="org-src-container">

<pre class="src src-c"><span style="color: #F0DFAF; font-weight: bold;">static</span> <span style="color: #7CB8BB;">jint</span> <span style="color: #93E0E3;">android_util_EventLog_writeEvent_String</span>(<span style="color: #7CB8BB;">JNIEnv</span>* <span style="color: #DFAF8F;">env</span>, <span style="color: #7CB8BB;">jobject</span> <span style="color: #DFAF8F;">clazz</span>,
                                                    <span style="color: #7CB8BB;">jint</span> <span style="color: #DFAF8F;">tag</span>, <span style="color: #7CB8BB;">jstring</span> <span style="color: #DFAF8F;">value</span>) {
    <span style="color: #7CB8BB;">uint8_t</span> <span style="color: #DFAF8F;">buf</span>[MAX_EVENT_PAYLOAD];

    <span style="color: #F0DFAF; font-weight: bold;">const</span> <span style="color: #7CB8BB;">char</span> *<span style="color: #DFAF8F;">str</span> = value != <span style="color: #BFEBBF;">NULL</span> ? env-&gt;GetStringUTFChars(value, <span style="color: #BFEBBF;">NULL</span>) : <span style="color: #CC9393;">"NULL"</span>;
    <span style="color: #7CB8BB;">jint</span> <span style="color: #DFAF8F;">len</span> = strlen(str);
    <span style="color: #F0DFAF; font-weight: bold;">const</span> <span style="color: #7CB8BB;">int</span> <span style="color: #DFAF8F;">max</span> = <span style="color: #F0DFAF; font-weight: bold;">sizeof</span>(buf) - <span style="color: #F0DFAF; font-weight: bold;">sizeof</span>(len) - 2;  <span style="color: #5F7F5F;">// </span><span style="color: #7F9F7F;">Type byte, final newline</span>
    <span style="color: #F0DFAF; font-weight: bold;">if</span> (len &gt; max) len = max;

    buf[0] = EVENT_TYPE_STRING;
    memcpy(&amp;buf[1], &amp;len, <span style="color: #F0DFAF; font-weight: bold;">sizeof</span>(len));
    memcpy(&amp;buf[1 + <span style="color: #F0DFAF; font-weight: bold;">sizeof</span>(len)], str, len);
    buf[1 + <span style="color: #F0DFAF; font-weight: bold;">sizeof</span>(len) + len] = <span style="color: #CC9393;">'\n'</span>;

    <span style="color: #F0DFAF; font-weight: bold;">if</span> (value != <span style="color: #BFEBBF;">NULL</span>) env-&gt;ReleaseStringUTFChars(value, str);
    <span style="color: #F0DFAF; font-weight: bold;">return</span> android_bWriteLog(tag, buf, 2 + <span style="color: #F0DFAF; font-weight: bold;">sizeof</span>(len) + len);
}
</pre>
</div>
<p>
该函数把type,string长度,string都放到了同一个buffer中,然后call android_bWriteLog()
</p>

<div class="org-src-container">

<pre class="src src-c"><span style="color: #7CB8BB;">int</span> <span style="color: #93E0E3;">__android_log_bwrite</span>(<span style="color: #7CB8BB;">int32_t</span> <span style="color: #DFAF8F;">tag</span>, <span style="color: #F0DFAF; font-weight: bold;">const</span> <span style="color: #7CB8BB;">void</span> *<span style="color: #DFAF8F;">payload</span>, <span style="color: #7CB8BB;">size_t</span> <span style="color: #DFAF8F;">len</span>)
{
    <span style="color: #F0DFAF; font-weight: bold;">struct</span> <span style="color: #7CB8BB;">iovec</span> <span style="color: #DFAF8F;">vec</span>[2];

    vec[0].iov_base = &amp;tag;
    vec[0].iov_len = <span style="color: #F0DFAF; font-weight: bold;">sizeof</span>(tag);
    vec[1].iov_base = (<span style="color: #7CB8BB;">void</span>*)payload;
    vec[1].iov_len = len;

    <span style="color: #F0DFAF; font-weight: bold;">return</span> write_to_log(LOG_ID_EVENTS, vec, 2);
}
</pre>
</div>
<p>
该函数与__android_log_bwrite的不同是后者是把type(int/long)跟payload分开的,而该函数放到了一起.
</p>

<p>
writeEvent的第四种形式:写入的是int/long/string的组合体,则会循环遍历该组合,转换成格式化字符串放到同一个buffer中.
</p>

<div class="org-src-container">

<pre class="src src-c"><span style="color: #F0DFAF; font-weight: bold;">static</span> <span style="color: #7CB8BB;">jint</span> <span style="color: #93E0E3;">android_util_EventLog_writeEvent_Array</span>(<span style="color: #7CB8BB;">JNIEnv</span>* <span style="color: #DFAF8F;">env</span>, <span style="color: #7CB8BB;">jobject</span> <span style="color: #DFAF8F;">clazz</span>,
                                                   <span style="color: #7CB8BB;">jint</span> <span style="color: #DFAF8F;">tag</span>, <span style="color: #7CB8BB;">jobjectArray</span> <span style="color: #DFAF8F;">value</span>) {

    <span style="color: #7CB8BB;">uint8_t</span> <span style="color: #DFAF8F;">buf</span>[MAX_EVENT_PAYLOAD];
    <span style="color: #F0DFAF; font-weight: bold;">const</span> <span style="color: #7CB8BB;">size_t</span> <span style="color: #DFAF8F;">max</span> = <span style="color: #F0DFAF; font-weight: bold;">sizeof</span>(buf) - 1;  <span style="color: #5F7F5F;">// </span><span style="color: #7F9F7F;">leave room for final newline</span>
    <span style="color: #7CB8BB;">size_t</span> <span style="color: #DFAF8F;">pos</span> = 2;  <span style="color: #5F7F5F;">// </span><span style="color: #7F9F7F;">Save room for type tag &amp; array count</span>

    <span style="color: #7CB8BB;">jsize</span> <span style="color: #DFAF8F;">copied</span> = 0, <span style="color: #DFAF8F;">num</span> = env-&gt;GetArrayLength(value);
    <span style="color: #F0DFAF; font-weight: bold;">for</span> (; copied &lt; num &amp;&amp; copied &lt; 255; ++copied) {
        <span style="color: #7CB8BB;">jobject</span> <span style="color: #DFAF8F;">item</span> = env-&gt;GetObjectArrayElement(value, copied);
        <span style="color: #F0DFAF; font-weight: bold;">if</span> (item == <span style="color: #BFEBBF;">NULL</span> || env-&gt;IsInstanceOf(item, gStringClass)) {
            <span style="color: #F0DFAF; font-weight: bold;">if</span> (pos + 1 + <span style="color: #F0DFAF; font-weight: bold;">sizeof</span>(jint) &gt; max) <span style="color: #F0DFAF; font-weight: bold;">break</span>;
            <span style="color: #F0DFAF; font-weight: bold;">const</span> <span style="color: #7CB8BB;">char</span> *<span style="color: #DFAF8F;">str</span> = item != <span style="color: #BFEBBF;">NULL</span> ? env-&gt;GetStringUTFChars((<span style="color: #7CB8BB;">jstring</span>) item, <span style="color: #BFEBBF;">NULL</span>) : <span style="color: #CC9393;">"NULL"</span>;
            <span style="color: #7CB8BB;">jint</span> <span style="color: #DFAF8F;">len</span> = strlen(str);
            <span style="color: #F0DFAF; font-weight: bold;">if</span> (pos + 1 + <span style="color: #F0DFAF; font-weight: bold;">sizeof</span>(len) + len &gt; max) len = max - pos - 1 - <span style="color: #F0DFAF; font-weight: bold;">sizeof</span>(len);
            buf[pos++] = EVENT_TYPE_STRING;
            memcpy(&amp;buf[pos], &amp;len, <span style="color: #F0DFAF; font-weight: bold;">sizeof</span>(len));
            memcpy(&amp;buf[pos + <span style="color: #F0DFAF; font-weight: bold;">sizeof</span>(len)], str, len);
            pos += <span style="color: #F0DFAF; font-weight: bold;">sizeof</span>(len) + len;
            <span style="color: #F0DFAF; font-weight: bold;">if</span> (item != <span style="color: #BFEBBF;">NULL</span>) env-&gt;ReleaseStringUTFChars((<span style="color: #7CB8BB;">jstring</span>) item, str);
        } <span style="color: #F0DFAF; font-weight: bold;">else</span> <span style="color: #F0DFAF; font-weight: bold;">if</span> (env-&gt;IsInstanceOf(item, gIntegerClass)) {
            <span style="color: #7CB8BB;">jint</span> <span style="color: #DFAF8F;">intVal</span> = env-&gt;GetIntField(item, gIntegerValueID);
            <span style="color: #F0DFAF; font-weight: bold;">if</span> (pos + 1 + <span style="color: #F0DFAF; font-weight: bold;">sizeof</span>(intVal) &gt; max) <span style="color: #F0DFAF; font-weight: bold;">break</span>;
            buf[pos++] = EVENT_TYPE_INT;
            memcpy(&amp;buf[pos], &amp;intVal, <span style="color: #F0DFAF; font-weight: bold;">sizeof</span>(intVal));
            pos += <span style="color: #F0DFAF; font-weight: bold;">sizeof</span>(intVal);
        } <span style="color: #F0DFAF; font-weight: bold;">else</span> <span style="color: #F0DFAF; font-weight: bold;">if</span> (env-&gt;IsInstanceOf(item, gLongClass)) {
            <span style="color: #7CB8BB;">jlong</span> <span style="color: #DFAF8F;">longVal</span> = env-&gt;GetLongField(item, gLongValueID);
            <span style="color: #F0DFAF; font-weight: bold;">if</span> (pos + 1 + <span style="color: #F0DFAF; font-weight: bold;">sizeof</span>(longVal) &gt; max) <span style="color: #F0DFAF; font-weight: bold;">break</span>;
            buf[pos++] = EVENT_TYPE_LONG;
            memcpy(&amp;buf[pos], &amp;longVal, <span style="color: #F0DFAF; font-weight: bold;">sizeof</span>(longVal));
            pos += <span style="color: #F0DFAF; font-weight: bold;">sizeof</span>(longVal);
        } <span style="color: #F0DFAF; font-weight: bold;">else</span> {
            jniThrowException(env,
                    <span style="color: #CC9393;">"java/lang/IllegalArgumentException"</span>,
                    <span style="color: #CC9393;">"Invalid payload item type"</span>);
            <span style="color: #F0DFAF; font-weight: bold;">return</span> -1;
        }
        env-&gt;DeleteLocalRef(item);
    }

    buf[0] = EVENT_TYPE_LIST;
    buf[1] = copied;
    buf[pos++] = <span style="color: #CC9393;">'\n'</span>;
    <span style="color: #F0DFAF; font-weight: bold;">return</span> android_bWriteLog(tag, buf, pos);
}
</pre>
</div>
<p>
最后同样是调用函数 android_bWriteLog()
</p>
</div>
</div>
</div>
<div id="outline-container-orgheadline18" class="outline-2">
<h2 id="orgheadline18">Logger</h2>
<div class="outline-text-2" id="text-orgheadline18">
<p>
<a href="#orgheadline1">Logcat</a> 和 <a href="#orgheadline14">Liblog</a> 这两篇文章,讲到了android系统中如何读log和写log. 那么,log存放的位置在哪里? 本文就介绍一下android 系统中存放log的地方: logger device.
</p>

<p>
Android 在 kernel 层提供了四个虚拟的device 设备,用于存放log. 可以通过输入 `adb shell ls /dev/log/` 来查看系统的虚拟logger 设备. 这些设备是在系统启动的时候以内核模块的方式初始化.
</p>
<div class="org-src-container">

<pre class="src src-c">device_initcall(logger_init);

<span style="color: #F0DFAF; font-weight: bold;">static</span> <span style="color: #7CB8BB;">int</span> <span style="color: #93E0E3;">__init</span> logger_init(<span style="color: #7CB8BB;">void</span>)
{
        <span style="color: #7CB8BB;">int</span> <span style="color: #DFAF8F;">ret</span>;

        ret = create_log(LOGGER_LOG_MAIN, 256*1024);
        <span style="color: #F0DFAF; font-weight: bold;">if</span> (unlikely(ret))
                <span style="color: #F0DFAF; font-weight: bold;">goto</span> <span style="color: #BFEBBF;">out</span>;

        ret = create_log(LOGGER_LOG_EVENTS, 256*1024);
        <span style="color: #F0DFAF; font-weight: bold;">if</span> (unlikely(ret))
                <span style="color: #F0DFAF; font-weight: bold;">goto</span> <span style="color: #BFEBBF;">out</span>;

        ret = create_log(LOGGER_LOG_RADIO, 256*1024);
        <span style="color: #F0DFAF; font-weight: bold;">if</span> (unlikely(ret))
                <span style="color: #F0DFAF; font-weight: bold;">goto</span> <span style="color: #BFEBBF;">out</span>;

        ret = create_log(LOGGER_LOG_SYSTEM, 256*1024);
        <span style="color: #F0DFAF; font-weight: bold;">if</span> (unlikely(ret))
                <span style="color: #F0DFAF; font-weight: bold;">goto</span> <span style="color: #BFEBBF;">out</span>;

<span style="color: #BFEBBF;">out</span>:
        <span style="color: #F0DFAF; font-weight: bold;">return</span> ret;
}
</pre>
</div>
<p>
模块初始话函数通过create_log()生成四个device,并指定了每个device的大小.
</p>

<div class="org-src-container">

<pre class="src src-c">        <span style="color: #F0DFAF; font-weight: bold;">static</span> <span style="color: #7CB8BB;">int</span> <span style="color: #93E0E3;">__init</span> create_log(<span style="color: #7CB8BB;">char</span> *<span style="color: #DFAF8F;">log_name</span>, <span style="color: #7CB8BB;">int</span> <span style="color: #DFAF8F;">size</span>)
        {
                <span style="color: #7CB8BB;">int</span> <span style="color: #DFAF8F;">ret</span> = 0;
                <span style="color: #F0DFAF; font-weight: bold;">struct</span> <span style="color: #7CB8BB;">logger_log</span> *<span style="color: #DFAF8F;">log</span>;
                <span style="color: #7CB8BB;">unsigned</span> <span style="color: #7CB8BB;">char</span> *<span style="color: #DFAF8F;">buffer</span>;

                buffer = vmalloc(size);
                <span style="color: #F0DFAF; font-weight: bold;">if</span> (buffer == <span style="color: #BFEBBF;">NULL</span>)
                        <span style="color: #F0DFAF; font-weight: bold;">return</span> -ENOMEM;

                log = kzalloc(<span style="color: #F0DFAF; font-weight: bold;">sizeof</span>(<span style="color: #F0DFAF; font-weight: bold;">struct</span> <span style="color: #7CB8BB;">logger_log</span>), GFP_KERNEL);
                <span style="color: #F0DFAF; font-weight: bold;">if</span> (log == <span style="color: #BFEBBF;">NULL</span>) {
                        ret = -ENOMEM;
                        <span style="color: #F0DFAF; font-weight: bold;">goto</span> <span style="color: #BFEBBF;">out_free_buffer</span>;
                }
                log-&gt;buffer = buffer;

                log-&gt;misc.minor = MISC_DYNAMIC_MINOR;
                log-&gt;misc.name = kstrdup(log_name, GFP_KERNEL);
                <span style="color: #F0DFAF; font-weight: bold;">if</span> (log-&gt;misc.name == <span style="color: #BFEBBF;">NULL</span>) {
                        ret = -ENOMEM;
                        <span style="color: #F0DFAF; font-weight: bold;">goto</span> <span style="color: #BFEBBF;">out_free_log</span>;
                }

                log-&gt;misc.fops = &amp;logger_fops;
                log-&gt;misc.parent = <span style="color: #BFEBBF;">NULL</span>;

                init_waitqueue_head(&amp;log-&gt;wq);
                INIT_LIST_HEAD(&amp;log-&gt;readers);
                mutex_init(&amp;log-&gt;mutex);
                log-&gt;w_off = 0;
                log-&gt;head = 0;
                log-&gt;size = size;

                INIT_LIST_HEAD(&amp;log-&gt;logs);
                list_add_tail(&amp;log-&gt;logs, &amp;log_list);

                <span style="color: #5F7F5F;">/* </span><span style="color: #7F9F7F;">finally, initialize the misc device for this log </span><span style="color: #5F7F5F;">*/</span>
                ret = misc_register(&amp;log-&gt;misc);
                <span style="color: #F0DFAF; font-weight: bold;">if</span> (unlikely(ret)) {
                        pr_err(<span style="color: #CC9393;">"failed to register misc device for log '%s'!\n"</span>,
                                        log-&gt;misc.name);
                        <span style="color: #F0DFAF; font-weight: bold;">goto</span> <span style="color: #BFEBBF;">out_free_log</span>;
                }

                pr_info(<span style="color: #CC9393;">"created %luK log '%s'\n"</span>,
                        (<span style="color: #7CB8BB;">unsigned</span> <span style="color: #7CB8BB;">long</span>) log-&gt;size &gt;&gt; 10, log-&gt;misc.name);

                <span style="color: #F0DFAF; font-weight: bold;">return</span> 0;

        <span style="color: #BFEBBF;">out_free_log</span>:
                kfree(log);

        <span style="color: #BFEBBF;">out_free_buffer</span>:
                vfree(buffer);
                <span style="color: #F0DFAF; font-weight: bold;">return</span> ret;
        }

<span style="color: #7CB8BB;">&#23545;&#20110;&#27599;&#19968;&#20010;logger</span> <span style="color: #DFAF8F;">device</span>,<span style="color: #93E0E3;">&#37117;&#23545;&#24212;&#19968;&#20010;&#26680;&#24515;&#30340;&#32467;&#26500;&#20307;</span>: <span style="color: #F0DFAF; font-weight: bold;">struct</span> <span style="color: #7CB8BB;">logger_log</span>. create_log()&#20989;&#25968;&#30340;&#20316;&#29992;&#23601;&#26159;&#20998;&#37197;&#19968;&#20010;logger_log,&#21021;&#22987;&#21270;&#20854;&#21464;&#37327;,&#24182;&#36890;&#36807;misc_register()&#27880;&#20876;&#20026;misc&#35774;&#22791;.

&#23545;&#20110;&#20043;&#21069;&#20171;&#32461;&#30340; [logcat](../Android-logcat/) &#21644; [liblog](../Android-liblog/), &#35762;&#21040;&#37117;&#26159;&#36890;&#36807;read()/write()&#20989;&#25968;&#26469;&#35835;&#20889;log, read/write&#30340;&#23454;&#29616;&#21017;&#23545;&#24212;&#21040;driver&#23618;&#27880;&#20876;&#21040;file system&#30340; fops.

        log-&gt;misc.fops = &amp;logger_fops;

        <span style="color: #F0DFAF; font-weight: bold;">static</span> <span style="color: #F0DFAF; font-weight: bold;">const</span> <span style="color: #F0DFAF; font-weight: bold;">struct</span> <span style="color: #7CB8BB;">file_operations</span> <span style="color: #DFAF8F;">logger_fops</span> = {
                .owner = THIS_MODULE,
                .read = logger_read,
                .aio_write = logger_aio_write,
                .poll = logger_poll,
                .unlocked_ioctl = logger_ioctl,
                .compat_ioctl = logger_ioctl,
                .open = logger_open,
                .release = logger_release,
        };
</pre>
</div>
</div>
<div id="outline-container-orgheadline19" class="outline-3">
<h3 id="orgheadline19">打开Logger设备</h3>
<div class="outline-text-3" id="text-orgheadline19">
<p>
在应用层通过调用open("/dev/log/main",O_RDWR)的方式可以打开一个logger设备,对应的kernel 层的实现是logger_open.
</p>

<div class="org-src-container">

<pre class="src src-c"><span style="color: #5F7F5F;">/* </span><span style="color: #7F9F7F;">logger_open() </span><span style="color: #5F7F5F;">*/</span>
log = get_log_from_minor(MINOR(inode-&gt;i_rdev));
<span style="color: #F0DFAF; font-weight: bold;">if</span> (<span style="color: #F0DFAF; font-weight: bold;">!</span>log)
        <span style="color: #F0DFAF; font-weight: bold;">return</span> -ENODEV;

<span style="color: #F0DFAF; font-weight: bold;">if</span> (file-&gt;f_mode &amp; FMODE_READ) {
        <span style="color: #F0DFAF; font-weight: bold;">struct</span> <span style="color: #7CB8BB;">logger_reader</span> *<span style="color: #DFAF8F;">reader</span>;

        reader = kmalloc(<span style="color: #F0DFAF; font-weight: bold;">sizeof</span>(<span style="color: #F0DFAF; font-weight: bold;">struct</span> <span style="color: #7CB8BB;">logger_reader</span>), GFP_KERNEL);
        <span style="color: #F0DFAF; font-weight: bold;">if</span> (<span style="color: #F0DFAF; font-weight: bold;">!</span>reader)
                <span style="color: #F0DFAF; font-weight: bold;">return</span> -ENOMEM;

        reader-&gt;log = log;
        reader-&gt;r_ver = 1;
        reader-&gt;r_all = in_egroup_p(inode-&gt;i_gid) ||
                capable(CAP_SYSLOG);

        INIT_LIST_HEAD(&amp;reader-&gt;list);

        mutex_lock(&amp;log-&gt;mutex);
        reader-&gt;r_off = log-&gt;head;
        list_add_tail(&amp;reader-&gt;list, &amp;log-&gt;readers);
        mutex_unlock(&amp;log-&gt;mutex);

        file-&gt;private_data = reader;
} <span style="color: #F0DFAF; font-weight: bold;">else</span>
        file-&gt;private_data = log;
</pre>
</div>
<p>
通过传入的inode节点的次设备号从log_list链表中找到对应的logger device的结构体. 接着会判断打开方式,如果打开方式中包含"read"(例如logcat)的话,会分配一个logger_read结构体被赋值给file的private_data变量,同时会把reader的读开始位置设为logger buffer的head位置(也就是从头开始读),然后把reader加入到logger的reader链表中.否则file的private_data变量直接指向logger.
</p>
</div>
</div>

<div id="outline-container-orgheadline20" class="outline-3">
<h3 id="orgheadline20">读logger</h3>
<div class="outline-text-3" id="text-orgheadline20">
<p>
read()函数对应logger_read.
</p>

<div class="org-src-container">

<pre class="src src-c">.read = logger_read,

<span style="color: #F0DFAF; font-weight: bold;">static</span> <span style="color: #7CB8BB;">ssize_t</span> <span style="color: #93E0E3;">logger_read</span>(<span style="color: #F0DFAF; font-weight: bold;">struct</span> <span style="color: #7CB8BB;">file</span> *<span style="color: #DFAF8F;">file</span>, <span style="color: #7CB8BB;">char</span> <span style="color: #DFAF8F;">__user</span> *buf,
                           <span style="color: #7CB8BB;">size_t</span> <span style="color: #DFAF8F;">count</span>, <span style="color: #7CB8BB;">loff_t</span> *<span style="color: #DFAF8F;">pos</span>)
{
        <span style="color: #F0DFAF; font-weight: bold;">struct</span> <span style="color: #7CB8BB;">logger_reader</span> *<span style="color: #DFAF8F;">reader</span> = file-&gt;private_data;
        <span style="color: #F0DFAF; font-weight: bold;">struct</span> <span style="color: #7CB8BB;">logger_log</span> *<span style="color: #DFAF8F;">log</span> = reader-&gt;log;
        <span style="color: #7CB8BB;">ssize_t</span> <span style="color: #DFAF8F;">ret</span>;
        DEFINE_WAIT(wait);

<span style="color: #BFEBBF;">start</span>:
        <span style="color: #F0DFAF; font-weight: bold;">while</span> (1) {
                mutex_lock(&amp;log-&gt;mutex);

                prepare_to_wait(&amp;log-&gt;wq, &amp;wait, TASK_INTERRUPTIBLE);

                ret = (log-&gt;w_off == reader-&gt;r_off);
                mutex_unlock(&amp;log-&gt;mutex);
                <span style="color: #F0DFAF; font-weight: bold;">if</span> (<span style="color: #F0DFAF; font-weight: bold;">!</span>ret)
                        <span style="color: #F0DFAF; font-weight: bold;">break</span>;

                <span style="color: #F0DFAF; font-weight: bold;">if</span> (file-&gt;f_flags &amp; O_NONBLOCK) {
                        ret = -EAGAIN;
                        <span style="color: #F0DFAF; font-weight: bold;">break</span>;
                }

                <span style="color: #F0DFAF; font-weight: bold;">if</span> (signal_pending(current)) {
                        ret = -EINTR;
                        <span style="color: #F0DFAF; font-weight: bold;">break</span>;
                }

                schedule();
        }

        finish_wait(&amp;log-&gt;wq, &amp;wait);
        <span style="color: #F0DFAF; font-weight: bold;">if</span> (ret)
                <span style="color: #F0DFAF; font-weight: bold;">return</span> ret;
</pre>
</div>
<p>
首先程序会在一个while循环中做一些判断:如果w_off不等于r_off,表明目前logger中有log可读,跳出循环.否则,如果设备以非阻塞的方式打开,直接返回 -EAGAIN 的错误. 如果程序被信号打断,则返回 -EINTR. 如果这些条件都不满足,表示目前没有log可读,调用schedule()让出cpu.
</p>

<div class="org-src-container">

<pre class="src src-c"><span style="color: #5F7F5F;">/*</span><span style="color: #7F9F7F;">logger_read()</span><span style="color: #5F7F5F;">*/</span>
mutex_lock(&amp;log-&gt;mutex);

<span style="color: #F0DFAF; font-weight: bold;">if</span> (<span style="color: #F0DFAF; font-weight: bold;">!</span>reader-&gt;r_all)
        reader-&gt;r_off = get_next_entry_by_uid(log,
                reader-&gt;r_off, current_euid());

<span style="color: #5F7F5F;">/* </span><span style="color: #7F9F7F;">is there still something to read or did we race? </span><span style="color: #5F7F5F;">*/</span>
<span style="color: #F0DFAF; font-weight: bold;">if</span> (unlikely(log-&gt;w_off == reader-&gt;r_off)) {
        mutex_unlock(&amp;log-&gt;mutex);
        <span style="color: #F0DFAF; font-weight: bold;">goto</span> <span style="color: #BFEBBF;">start</span>;
}
</pre>
</div>
<p>
r_all部分目前还不太理解,以后再补充&#x2026;..(从代码来看,这个变量应该是与reader的权限有关,通过这个变量可以控制该reader是否有权限去读所有的log, 如果为0,表明reader没有该权限,只能读自己进程euid相等的log)
</p>

<div class="org-src-container">

<pre class="src src-c"><span style="color: #5F7F5F;">/*</span><span style="color: #7F9F7F;">logger_read()</span><span style="color: #5F7F5F;">*/</span>
ret = get_user_hdr_len(reader-&gt;r_ver) +
        get_entry_msg_len(log, reader-&gt;r_off);
<span style="color: #F0DFAF; font-weight: bold;">if</span> (count &lt; ret) {
        ret = -EINVAL;
        <span style="color: #F0DFAF; font-weight: bold;">goto</span> <span style="color: #BFEBBF;">out</span>;
}
</pre>
</div>
<p>
通过get_user_hdr_len()及get_entry_msg_len()获取entry的header长度和entry长度,加起来就是一条log的长度.
</p>

<div class="org-src-container">

<pre class="src src-c"><span style="color: #F0DFAF; font-weight: bold;">static</span> <span style="color: #7CB8BB;">size_t</span> <span style="color: #93E0E3;">get_user_hdr_len</span>(<span style="color: #7CB8BB;">int</span> <span style="color: #DFAF8F;">ver</span>)
{
        <span style="color: #F0DFAF; font-weight: bold;">if</span> (ver &lt; 2)
                <span style="color: #F0DFAF; font-weight: bold;">return</span> <span style="color: #F0DFAF; font-weight: bold;">sizeof</span>(<span style="color: #F0DFAF; font-weight: bold;">struct</span> <span style="color: #7CB8BB;">user_logger_entry_compat</span>);
        <span style="color: #F0DFAF; font-weight: bold;">else</span>
                <span style="color: #F0DFAF; font-weight: bold;">return</span> <span style="color: #F0DFAF; font-weight: bold;">sizeof</span>(<span style="color: #F0DFAF; font-weight: bold;">struct</span> <span style="color: #7CB8BB;">logger_entry</span>);
}
</pre>
</div>
<p>
该函数会根据传入的reader成员r_ver的值来决定返回哪个长度的entry header值,因为在logger_open中该值被设定为1, 故该函数的返回值为 user_logger_entry_compat 的长度. 接着读取log entry的长度.
</p>

<div class="org-src-container">

<pre class="src src-c"><span style="color: #F0DFAF; font-weight: bold;">static</span> <span style="color: #7CB8BB;">__u32</span> <span style="color: #93E0E3;">get_entry_msg_len</span>(<span style="color: #F0DFAF; font-weight: bold;">struct</span> <span style="color: #7CB8BB;">logger_log</span> *<span style="color: #DFAF8F;">log</span>, <span style="color: #7CB8BB;">size_t</span> <span style="color: #DFAF8F;">off</span>)
{
        <span style="color: #F0DFAF; font-weight: bold;">struct</span> <span style="color: #7CB8BB;">logger_entry</span> <span style="color: #DFAF8F;">scratch</span>;
        <span style="color: #F0DFAF; font-weight: bold;">struct</span> <span style="color: #7CB8BB;">logger_entry</span> *<span style="color: #DFAF8F;">entry</span>;

        entry = get_entry_header(log, off, &amp;scratch);
        <span style="color: #F0DFAF; font-weight: bold;">return</span> entry-&gt;len;
}


<span style="color: #F0DFAF; font-weight: bold;">static</span> <span style="color: #F0DFAF; font-weight: bold;">struct</span> <span style="color: #7CB8BB;">logger_entry</span> *<span style="color: #93E0E3;">get_entry_header</span>(<span style="color: #F0DFAF; font-weight: bold;">struct</span> <span style="color: #7CB8BB;">logger_log</span> *<span style="color: #DFAF8F;">log</span>,
                <span style="color: #7CB8BB;">size_t</span> <span style="color: #DFAF8F;">off</span>, <span style="color: #F0DFAF; font-weight: bold;">struct</span> <span style="color: #7CB8BB;">logger_entry</span> *<span style="color: #DFAF8F;">scratch</span>)
{
        <span style="color: #7CB8BB;">size_t</span> <span style="color: #DFAF8F;">len</span> = min(<span style="color: #F0DFAF; font-weight: bold;">sizeof</span>(<span style="color: #F0DFAF; font-weight: bold;">struct</span> <span style="color: #7CB8BB;">logger_entry</span>), log-&gt;size - off);
        <span style="color: #F0DFAF; font-weight: bold;">if</span> (len != <span style="color: #F0DFAF; font-weight: bold;">sizeof</span>(<span style="color: #F0DFAF; font-weight: bold;">struct</span> <span style="color: #7CB8BB;">logger_entry</span>)) {
                memcpy(((<span style="color: #7CB8BB;">void</span> *) scratch), log-&gt;buffer + off, len);
                memcpy(((<span style="color: #7CB8BB;">void</span> *) scratch) + len, log-&gt;buffer,
                        <span style="color: #F0DFAF; font-weight: bold;">sizeof</span>(<span style="color: #F0DFAF; font-weight: bold;">struct</span> <span style="color: #7CB8BB;">logger_entry</span>) - len);
                <span style="color: #F0DFAF; font-weight: bold;">return</span> scratch;
        }

        <span style="color: #F0DFAF; font-weight: bold;">return</span> (<span style="color: #F0DFAF; font-weight: bold;">struct</span> <span style="color: #7CB8BB;">logger_entry</span> *) (log-&gt;buffer + off);
}
</pre>
</div>
<p>
因为每个logger device的size都是固定大小,而系统中的log量要远远大于该size,故logger device都是采用 ring buffer的方式存放log. 这样就可能出现这个的情况,一条log的一部分在buffer尾部,而另一部分在buffer头部,所以每次从buffer读log都要考虑这种情况. 获得entry之后,通过entry的变量len就可以知道msg的长度. 调用 do_read_log_to_user()将entry+msg写到user的buf中.
</p>

<p>
ret = do_read_log_to_user(log, reader, buf, ret);
</p>
</div>
</div>

<div id="outline-container-orgheadline21" class="outline-3">
<h3 id="orgheadline21">Log write</h3>
<div class="outline-text-3" id="text-orgheadline21">
<p>
之前有讲,user space在写log的流程最后调用到了write()函数,对应到driver层的实现为 logger_aio_write(). 让我们一段一段的分析这个函数的实现.
</p>

<div class="org-src-container">

<pre class="src src-c"><span style="color: #F0DFAF; font-weight: bold;">static</span> <span style="color: #7CB8BB;">ssize_t</span> <span style="color: #93E0E3;">logger_aio_write</span>(<span style="color: #F0DFAF; font-weight: bold;">struct</span> <span style="color: #7CB8BB;">kiocb</span> *<span style="color: #DFAF8F;">iocb</span>, <span style="color: #F0DFAF; font-weight: bold;">const</span> <span style="color: #F0DFAF; font-weight: bold;">struct</span> <span style="color: #7CB8BB;">iovec</span> *<span style="color: #DFAF8F;">iov</span>,
                         <span style="color: #7CB8BB;">unsigned</span> <span style="color: #7CB8BB;">long</span> <span style="color: #DFAF8F;">nr_segs</span>, <span style="color: #7CB8BB;">loff_t</span> <span style="color: #DFAF8F;">ppos</span>)
{
        <span style="color: #F0DFAF; font-weight: bold;">struct</span> <span style="color: #7CB8BB;">logger_log</span> *<span style="color: #DFAF8F;">log</span> = file_get_log(iocb-&gt;ki_filp);
        <span style="color: #7CB8BB;">size_t</span> <span style="color: #DFAF8F;">orig</span> = log-&gt;w_off;
        <span style="color: #F0DFAF; font-weight: bold;">struct</span> <span style="color: #7CB8BB;">logger_entry</span> <span style="color: #DFAF8F;">header</span>;
        <span style="color: #F0DFAF; font-weight: bold;">struct</span> <span style="color: #7CB8BB;">timespec</span> <span style="color: #DFAF8F;">now</span>;
        <span style="color: #7CB8BB;">ssize_t</span> <span style="color: #DFAF8F;">ret</span> = 0;
</pre>
</div>
<p>
首先是调用file_get_log()函数获得这个文件结构体对应的logger设备. 在打开设备的代码中有讲,file结构体的private_data变量会存放两个值之一:logger或reader,所以这里会判断文件是否以FMODE_READ的方式打开,如果是,则private_data为reader,需要去reader中找logger,否则直接返回private_data.
</p>

<div class="org-src-container">

<pre class="src src-c"><span style="color: #F0DFAF; font-weight: bold;">static</span> <span style="color: #F0DFAF; font-weight: bold;">inline</span> <span style="color: #F0DFAF; font-weight: bold;">struct</span> <span style="color: #7CB8BB;">logger_log</span> *<span style="color: #93E0E3;">file_get_log</span>(<span style="color: #F0DFAF; font-weight: bold;">struct</span> <span style="color: #7CB8BB;">file</span> *<span style="color: #DFAF8F;">file</span>)
{
        <span style="color: #F0DFAF; font-weight: bold;">if</span> (file-&gt;f_mode &amp; FMODE_READ) {
                <span style="color: #F0DFAF; font-weight: bold;">struct</span> <span style="color: #7CB8BB;">logger_reader</span> *<span style="color: #DFAF8F;">reader</span> = file-&gt;private_data;
                <span style="color: #F0DFAF; font-weight: bold;">return</span> reader-&gt;log;
        } <span style="color: #F0DFAF; font-weight: bold;">else</span>
                <span style="color: #F0DFAF; font-weight: bold;">return</span> file-&gt;private_data;
}
</pre>
</div>
<p>
下面的代码通过系统参数初始化log entry的header.
</p>
<div class="org-src-container">

<pre class="src src-c">now = current_kernel_time();

header.pid = current-&gt;tgid;
header.tid = current-&gt;pid;
header.sec = now.tv_sec;
header.nsec = now.tv_nsec;
header.euid = current_euid();
header.len = min_t(size_t, iocb-&gt;ki_left, LOGGER_ENTRY_MAX_PAYLOAD);
header.hdr_size = <span style="color: #F0DFAF; font-weight: bold;">sizeof</span>(<span style="color: #F0DFAF; font-weight: bold;">struct</span> <span style="color: #7CB8BB;">logger_entry</span>);

<span style="color: #5F7F5F;">/* </span><span style="color: #7F9F7F;">null writes succeed, return zero </span><span style="color: #5F7F5F;">*/</span>
<span style="color: #F0DFAF; font-weight: bold;">if</span> (unlikely(<span style="color: #F0DFAF; font-weight: bold;">!</span>header.len))
        <span style="color: #F0DFAF; font-weight: bold;">return</span> 0;

mutex_lock(&amp;log-&gt;mutex);
</pre>
</div>
<p>
接下来调用fix_up_readers()函数,通过传入本次log的长度对该logger设备的readers进行修正.
</p>
<div class="org-src-container">

<pre class="src src-c">        <span style="color: #5F7F5F;">/*</span>
<span style="color: #7F9F7F;">         * Fix up any readers, pulling them forward to the first readable</span>
<span style="color: #7F9F7F;">         * entry after (what will be) the new write offset. We do this now</span>
<span style="color: #7F9F7F;">         * because if we partially fail, we can end up with clobbered log</span>
<span style="color: #7F9F7F;">         * entries that encroach on readable buffer.</span>
<span style="color: #7F9F7F;">         </span><span style="color: #5F7F5F;">*/</span>
        fix_up_readers(log, <span style="color: #F0DFAF; font-weight: bold;">sizeof</span>(<span style="color: #F0DFAF; font-weight: bold;">struct</span> <span style="color: #7CB8BB;">logger_entry</span>) + header.len);

<span style="color: #F0DFAF; font-weight: bold;">static</span> <span style="color: #7CB8BB;">void</span> <span style="color: #93E0E3;">fix_up_readers</span>(<span style="color: #F0DFAF; font-weight: bold;">struct</span> <span style="color: #7CB8BB;">logger_log</span> *<span style="color: #DFAF8F;">log</span>, <span style="color: #7CB8BB;">size_t</span> <span style="color: #DFAF8F;">len</span>)
{
        <span style="color: #7CB8BB;">size_t</span> <span style="color: #DFAF8F;">old</span> = log-&gt;w_off;
        <span style="color: #7CB8BB;">size_t</span> <span style="color: #DFAF8F;">new</span> = logger_offset(log, old + len);
        <span style="color: #F0DFAF; font-weight: bold;">struct</span> <span style="color: #7CB8BB;">logger_reader</span> *<span style="color: #DFAF8F;">reader</span>;

        <span style="color: #F0DFAF; font-weight: bold;">if</span> (is_between(old, new, log-&gt;head))
                log-&gt;head = get_next_entry(log, log-&gt;head, len);

        list_for_each_entry(reader, &amp;log-&gt;readers, list)
                <span style="color: #F0DFAF; font-weight: bold;">if</span> (is_between(old, new, reader-&gt;r_off))
                        reader-&gt;r_off = get_next_entry(log, reader-&gt;r_off, len);
}

<span style="color: #F0DFAF; font-weight: bold;">static</span> <span style="color: #7CB8BB;">size_t</span> <span style="color: #93E0E3;">get_next_entry</span>(<span style="color: #F0DFAF; font-weight: bold;">struct</span> <span style="color: #7CB8BB;">logger_log</span> *<span style="color: #DFAF8F;">log</span>, <span style="color: #7CB8BB;">size_t</span> <span style="color: #DFAF8F;">off</span>, <span style="color: #7CB8BB;">size_t</span> <span style="color: #DFAF8F;">len</span>)
{
        <span style="color: #7CB8BB;">size_t</span> <span style="color: #DFAF8F;">count</span> = 0;

        <span style="color: #F0DFAF; font-weight: bold;">do</span> {
                <span style="color: #7CB8BB;">size_t</span> <span style="color: #DFAF8F;">nr</span> = <span style="color: #F0DFAF; font-weight: bold;">sizeof</span>(<span style="color: #F0DFAF; font-weight: bold;">struct</span> <span style="color: #7CB8BB;">logger_entry</span>) +
                        get_entry_msg_len(log, off);
                off = logger_offset(log, off + nr);
                count += nr;
        } <span style="color: #F0DFAF; font-weight: bold;">while</span> (count &lt; len);

        <span style="color: #F0DFAF; font-weight: bold;">return</span> off;
}
</pre>
</div>
<p>
为什么要对reader进行修正?前面有讲过,logger buffer的size是固定的,系统采用ring buffer的方式写log,那么就会出现这样的情况,最新的logger会有机会覆盖前面的一条log,那么在这种情况下,对于reader来说,r_off这个参数就是无效的,因为下一条log(或者后面几条log)已经不存在了.
</p>

<p>
get_next_entry()的实现不难理解,因为新加入的log长度为len,即寻找从r_off+len位置之后的第一条有效log.
</p>

<p>
接下来就是真正把log的内容写入buffer
</p>
<div class="org-src-container">

<pre class="src src-c">        do_write_log(log, &amp;header, <span style="color: #F0DFAF; font-weight: bold;">sizeof</span>(<span style="color: #F0DFAF; font-weight: bold;">struct</span> <span style="color: #7CB8BB;">logger_entry</span>));

        <span style="color: #F0DFAF; font-weight: bold;">while</span> (nr_segs-- &gt; 0) {
                <span style="color: #7CB8BB;">size_t</span> <span style="color: #DFAF8F;">len</span>;
                <span style="color: #7CB8BB;">ssize_t</span> <span style="color: #DFAF8F;">nr</span>;

                <span style="color: #5F7F5F;">/* </span><span style="color: #7F9F7F;">figure out how much of this vector we can keep </span><span style="color: #5F7F5F;">*/</span>
                len = min_t(size_t, iov-&gt;iov_len, header.len - ret);

                <span style="color: #5F7F5F;">/* </span><span style="color: #7F9F7F;">write out this segment's payload </span><span style="color: #5F7F5F;">*/</span>
                nr = do_write_log_from_user(log, iov-&gt;iov_base, len);
                <span style="color: #F0DFAF; font-weight: bold;">if</span> (unlikely(nr &lt; 0)) {
                        log-&gt;w_off = orig;
                        mutex_unlock(&amp;log-&gt;mutex);
                        <span style="color: #F0DFAF; font-weight: bold;">return</span> nr;
                }

                iov++;
                ret += nr;
        }

        mutex_unlock(&amp;log-&gt;mutex);

        <span style="color: #5F7F5F;">/* </span><span style="color: #7F9F7F;">wake up any blocked readers </span><span style="color: #5F7F5F;">*/</span>
        wake_up_interruptible(&amp;log-&gt;wq);

        <span style="color: #F0DFAF; font-weight: bold;">return</span> ret;
}
</pre>
</div>
<p>
首先会调用do_write_log()把header先写入buffer,这里直接调用memcpy(),header有可能被写到buffer的尾部和首部(ring buffer). 然后就是把user space传入的iovec数组的内容依次写入buffer. 如果写失败,会直接把logger的w_off位置roll back会之前的值.
</p>
</div>
</div>

<div id="outline-container-orgheadline22" class="outline-3">
<h3 id="orgheadline22">logger_poll</h3>
<div class="outline-text-3" id="text-orgheadline22">
<p>
在logcat的实现中曾讲到,logcat在打开logger设备后,会调用select()函数监控该logger设备,如果函数返回,表明有log可读,接下来就会调用read()读log.这里select对应的driver层函数就是logger_poll()
</p>

<div class="org-src-container">

<pre class="src src-c"><span style="color: #F0DFAF; font-weight: bold;">static</span> <span style="color: #7CB8BB;">unsigned</span> <span style="color: #7CB8BB;">int</span> <span style="color: #93E0E3;">logger_poll</span>(<span style="color: #F0DFAF; font-weight: bold;">struct</span> <span style="color: #7CB8BB;">file</span> *<span style="color: #DFAF8F;">file</span>, <span style="color: #7CB8BB;">poll_table</span> *<span style="color: #DFAF8F;">wait</span>)
{
        <span style="color: #F0DFAF; font-weight: bold;">struct</span> <span style="color: #7CB8BB;">logger_reader</span> *<span style="color: #DFAF8F;">reader</span>;
        <span style="color: #F0DFAF; font-weight: bold;">struct</span> <span style="color: #7CB8BB;">logger_log</span> *<span style="color: #DFAF8F;">log</span>;
        <span style="color: #7CB8BB;">unsigned</span> <span style="color: #7CB8BB;">int</span> <span style="color: #DFAF8F;">ret</span> = POLLOUT | POLLWRNORM;

        <span style="color: #F0DFAF; font-weight: bold;">if</span> (<span style="color: #F0DFAF; font-weight: bold;">!</span>(file-&gt;f_mode &amp; FMODE_READ))
                <span style="color: #F0DFAF; font-weight: bold;">return</span> ret;

        reader = file-&gt;private_data;
        log = reader-&gt;log;

        poll_wait(file, &amp;log-&gt;wq, wait);

        mutex_lock(&amp;log-&gt;mutex);
        <span style="color: #F0DFAF; font-weight: bold;">if</span> (<span style="color: #F0DFAF; font-weight: bold;">!</span>reader-&gt;r_all)
                reader-&gt;r_off = get_next_entry_by_uid(log,
                        reader-&gt;r_off, current_euid());

        <span style="color: #F0DFAF; font-weight: bold;">if</span> (log-&gt;w_off != reader-&gt;r_off)
                ret |= POLLIN | POLLRDNORM;
        mutex_unlock(&amp;log-&gt;mutex);

        <span style="color: #F0DFAF; font-weight: bold;">return</span> ret;
}
</pre>
</div>
<p>
函数首先会判断是否以read的方式打开设备,如果不是,直接返回.(因为select()一般对应读操作,如果不读那么select()就没什么意义了).判断log是否可读的唯一条件就是w_off是否等于r_off.
</p>

<p>
OK,logger设备暂时就写到这里,以后有新的理解会继续补充.
</p>
</div>
</div>
</div>

<div id="outline-container-orgheadline23" class="outline-2">
<h2 id="orgheadline23">Logwrapper</h2>
<div class="outline-text-2" id="text-orgheadline23">
<p>
严格来讲，logwrapper并不属于之前写的Android的Log体系（
<a href="logger.html">logger.html</a>、 <a href="liblog.html">liblog.html</a>、 <a href="logcat.html">logcat.html</a>
），但是呢，它多多少少又与这套体系有些关系，所以将其称之为“外传”。
</p>

<p>
什么是logwrapper？如果你写了一个android程序，使用了一些标准输出函数（printf），
但是有时候你无法看到这些输出（例如你写了一个native开机启动程序，
那你应该没办法在adb shell中看到你的输出吧）。
那么使用logwrapper可以将你的程序的标准输出重定向到android log或kernel log中，
就像是你调用了这些log函数(ALOGI或printk）一样。
</p>

<p>
例如，你在adb shell中输入‘logwrapper ls’，
终端上不会显示任何内容，ls的输出被重定向到了logger中，
通过logcat命令把logger的内容抓到文件中，可以看到ls的输出。
如下图。
</p>

<p>
使用logwrapper后，ls的结果没有输出到标准输出。
</p>


<div class="figure">
<p><img src="../img/ls.png" alt="ls.png" />
</p>
</div>

<p>
在logcat抓的log中发现了上面ls命令的结果。
</p>


<div class="figure">
<p><img src="../img/logwrapper.png" alt="logwrapper.png" />
</p>
</div>
</div>

<div id="outline-container-orgheadline24" class="outline-3">
<h3 id="orgheadline24">clogwrapper 代码</h3>
<div class="outline-text-3" id="text-orgheadline24">
<p>
logwrapper的代码位于 system/core/logwrapper目录。在最新的4.4.2_r1版本中，该模块增加到了三个源文件，
（原来只有logwrapper.c这支文件）。首先看一下该模块的makefile文件Android.mk。
</p>

<div class="org-src-container">

<pre class="src src-c"><span style="color: #BFEBBF;">LOCAL_PATH</span>:= $(<span style="color: #7CB8BB;">call</span> <span style="color: #DFAF8F;">my</span>-dir)

include $(CLEAR_VARS)

# ========================================================
<span style="color: #94BFF3;"># Static</span> library
# ========================================================
include $(CLEAR_VARS)
LOCAL_MODULE := liblogwrap
LOCAL_SRC_FILES := logwrap.c
LOCAL_SHARED_LIBRARIES := libcutils liblog
LOCAL_EXPORT_C_INCLUDE_DIRS := $(LOCAL_PATH)/include
LOCAL_C_INCLUDES := $(LOCAL_PATH)/include
include $(BUILD_STATIC_LIBRARY)

# ========================================================
<span style="color: #94BFF3;"># Shared</span> library
# ========================================================
include $(CLEAR_VARS)
LOCAL_MODULE := liblogwrap
LOCAL_SHARED_LIBRARIES := libcutils liblog
LOCAL_WHOLE_STATIC_LIBRARIES := liblogwrap
LOCAL_EXPORT_C_INCLUDE_DIRS := $(LOCAL_PATH)/include
LOCAL_C_INCLUDES := $(LOCAL_PATH)/include
include $(BUILD_SHARED_LIBRARY)

# ========================================================
<span style="color: #94BFF3;"># Executable</span>
# ========================================================
include $(CLEAR_VARS)
LOCAL_SRC_FILES:= logwrapper.c
LOCAL_MODULE := logwrapper
LOCAL_STATIC_LIBRARIES := liblog liblogwrap libcutils
include $(BUILD_EXECUTABLE)
</pre>
</div>
<p>
从Android可以看出，在编译时，先将logwrap.c文件编译成一个动态库liblogwrap，
然后再将该动态库编译成静态库liblogwrap，最后将logwrapper.c编译成一个
可执行shell命令logwrapper。
</p>

<p>
既然上面的例子中有用到logwrapper这个命令，那先从其源代码看起。该文件的代码只有不到100行，主要的工作还是在logwrap.c中完成。先看一下main函数。
</p>
<div class="org-src-container">

<pre class="src src-c"><span style="color: #7CB8BB;">int</span> <span style="color: #93E0E3;">main</span>(<span style="color: #7CB8BB;">int</span> <span style="color: #DFAF8F;">argc</span>, <span style="color: #7CB8BB;">char</span>* <span style="color: #DFAF8F;">argv</span>[]) {
        ....

    <span style="color: #F0DFAF; font-weight: bold;">while</span> ((ch = getopt(argc, argv, <span style="color: #CC9393;">"adk"</span>)) != -1) {
        <span style="color: #F0DFAF; font-weight: bold;">switch</span> (ch) {
            <span style="color: #F0DFAF; font-weight: bold;">case</span> <span style="color: #CC9393;">'a'</span>:
                abbreviated = <span style="color: #BFEBBF;">true</span>;
                <span style="color: #F0DFAF; font-weight: bold;">break</span>;
            <span style="color: #F0DFAF; font-weight: bold;">case</span> <span style="color: #CC9393;">'d'</span>:
                seg_fault_on_exit = 1;
                <span style="color: #F0DFAF; font-weight: bold;">break</span>;
            <span style="color: #F0DFAF; font-weight: bold;">case</span> <span style="color: #CC9393;">'k'</span>:
                log_target = LOG_KLOG;
                klog_set_level(6);
                <span style="color: #F0DFAF; font-weight: bold;">break</span>;
            <span style="color: #F0DFAF; font-weight: bold;">case</span> <span style="color: #CC9393;">'?'</span>:
            <span style="color: #F0DFAF; font-weight: bold;">default</span>:
              usage();
        }
    }
    argc -= optind;
    argv += optind;

    <span style="color: #F0DFAF; font-weight: bold;">if</span> (argc &lt; 1) {
        usage();
    }

    rc = android_fork_execvp_ext(argc, &amp;argv[0], &amp;status, <span style="color: #BFEBBF;">true</span>,
                                 log_target, abbreviated, <span style="color: #BFEBBF;">NULL</span>);

        ....

}
</pre>
</div>
<p>
首先通过getopt()函数获取命令行选项，
不同的选项会设置不同的变量。目前logwrapper支持三个命令行选项：
-a，压缩logging，该选项只保留‘命令’输出的前4K和后4K内容。
-d，‘命令’完成后，logwrapper会SIGSEGV。
-k，将‘命令’输出写到kernel log（默认是写道Android Log）。
读完命令行选项后，接下来调用android_fork_execvp_ext()函数，这是logwrapper工作的核心函数。该函数的实现在logwrap.c中。
</p>
<div class="org-src-container">

<pre class="src src-c">    <span style="color: #5F7F5F;">// </span><span style="color: #7F9F7F;">int android_fork_execvp_ext(int argc, char* argv[], int *status, bool ignore_int_quit,</span>
    <span style="color: #7CB8BB;">int</span> <span style="color: #DFAF8F;">log_target</span>, <span style="color: #DFAF8F;">bool</span> abbreviated, <span style="color: #7CB8BB;">char</span> *<span style="color: #DFAF8F;">file_path</span>) {

    ...

rc = pthread_mutex_lock(&amp;fd_mutex);
<span style="color: #F0DFAF; font-weight: bold;">if</span> (rc) {
    ERROR(<span style="color: #CC9393;">"failed to lock signal_fd mutex\n"</span>);
    <span style="color: #F0DFAF; font-weight: bold;">goto</span> <span style="color: #BFEBBF;">err_lock</span>;
}

<span style="color: #5F7F5F;">/* </span><span style="color: #7F9F7F;">Use ptty instead of socketpair so that STDOUT is not buffered </span><span style="color: #5F7F5F;">*/</span>
parent_ptty = open(<span style="color: #CC9393;">"/dev/ptmx"</span>, O_RDWR);
<span style="color: #F0DFAF; font-weight: bold;">if</span> (parent_ptty &lt; 0) {
    ERROR(<span style="color: #CC9393;">"Cannot create parent ptty\n"</span>);
    rc = -1;
    <span style="color: #F0DFAF; font-weight: bold;">goto</span> <span style="color: #BFEBBF;">err_open</span>;
}

<span style="color: #F0DFAF; font-weight: bold;">if</span> (grantpt(parent_ptty) || unlockpt(parent_ptty) ||
        ((child_devname = (<span style="color: #7CB8BB;">char</span>*)ptsname(parent_ptty)) == 0)) {
    ERROR(<span style="color: #CC9393;">"Problem with /dev/ptmx\n"</span>);
    rc = -1;
    <span style="color: #F0DFAF; font-weight: bold;">goto</span> <span style="color: #BFEBBF;">err_ptty</span>;
}

child_ptty = open(child_devname, O_RDWR);
<span style="color: #F0DFAF; font-weight: bold;">if</span> (child_ptty &lt; 0) {
    ERROR(<span style="color: #CC9393;">"Cannot open child_ptty\n"</span>);
    rc = -1;
    <span style="color: #F0DFAF; font-weight: bold;">goto</span> <span style="color: #BFEBBF;">err_child_ptty</span>;
}
</pre>
</div>

<p>
程序的最开始会尝试去拿fd_mutex这个锁，目前还不清楚这么做的原因。
</p>

<p>
接下来会打开/dev/ptmx这个设备节点。并通过grantpt()、unlockpt()、ptsname()
这三个函数得到对/dev/ptmx进行相关操作。最后打开从设备。
</p>

<p>
“伪终端主设备/dev/ptmx是一个流的增殖设备。这意味着当我们打开该增殖设备，
其open例程自动决定第一个未被使用的伪终端主设备并打开这个设备。
同时，打开这个主设备会自动锁定对应的从设备。
grantpt函数用来改变从设备的权限。执行如下操作：
（a）将从设备的所有权改为有效用户ID；（b）将组所有权改为组tty；
（c）将权限改为只允许user-read，user-write和group-write。
函数unlockpt用来清除从设备的内部锁。在打开从设备前我们必须做这件事情。
通过调用ptsname来得到从设备的名称。这个名称的格式是/dev/pts/NNN。”
</p>

<p>
上面的内容是从相关资料中摘取的对这三个函数的解释，
针对logwrapper这个程序，我的理解就是，logwrapper程序使用一个主设备，
然后它执行的‘命令’使用一个从设备，则‘命令’的输出就会透过从设备反映给主设备。
logwrapper程序再把它写到相关文件中。
</p>
<div class="org-src-container">

<pre class="src src-c">pid = fork();
<span style="color: #F0DFAF; font-weight: bold;">if</span> (pid &lt; 0) {
    close(child_ptty);
    ERROR(<span style="color: #CC9393;">"Failed to fork\n"</span>);
    rc = -1;
    <span style="color: #F0DFAF; font-weight: bold;">goto</span> <span style="color: #BFEBBF;">err_fork</span>;
} <span style="color: #F0DFAF; font-weight: bold;">else</span> <span style="color: #F0DFAF; font-weight: bold;">if</span> (pid == 0) {
    pthread_mutex_unlock(&amp;fd_mutex);
    pthread_sigmask(SIG_SETMASK, &amp;oldset, <span style="color: #BFEBBF;">NULL</span>);
    close(parent_ptty);

    <span style="color: #5F7F5F;">// </span><span style="color: #7F9F7F;">redirect stdout and stderr</span>
    dup2(child_ptty, 1);
    dup2(child_ptty, 2);
    close(child_ptty);

    child(argc, argv);
} <span style="color: #F0DFAF; font-weight: bold;">else</span> {
    close(child_ptty);
    <span style="color: #F0DFAF; font-weight: bold;">if</span> (ignore_int_quit) {
        <span style="color: #F0DFAF; font-weight: bold;">struct</span> <span style="color: #7CB8BB;">sigaction</span> <span style="color: #DFAF8F;">ignact</span>;

        memset(&amp;ignact, 0, <span style="color: #F0DFAF; font-weight: bold;">sizeof</span>(ignact));
        ignact.sa_handler = SIG_IGN;
        sigaction(<span style="color: #DFAF8F;">SIGINT</span>, &amp;ignact, &amp;intact);
        sigaction(<span style="color: #DFAF8F;">SIGQUIT</span>, &amp;ignact, &amp;quitact);
    }

    rc = parent(argv[0], parent_ptty, pid, status, log_target,
                abbreviated, file_path);
}
</pre>
</div>
<p>
接着通过fork()出一个新的进程来执行‘命令’程序，
父进程和子进程分别执行parent和child函数，在子进程执行child函数之前，
会先将其stdout和stderr重定向到从设备上。这样父进程就可以接受’命令‘的输出了。
</p>

<p>
先来看下child()函数的实现。该函数的程序很简单，就是通过execvp()执行‘命令’。
</p>
<div class="org-src-container">

<pre class="src src-c"><span style="color: #F0DFAF; font-weight: bold;">static</span> <span style="color: #7CB8BB;">void</span> <span style="color: #93E0E3;">child</span>(<span style="color: #7CB8BB;">int</span> <span style="color: #DFAF8F;">argc</span>, <span style="color: #7CB8BB;">char</span>* <span style="color: #DFAF8F;">argv</span>[]) {
    <span style="color: #5F7F5F;">// </span><span style="color: #7F9F7F;">create null terminated argv_child array</span>
    <span style="color: #7CB8BB;">char</span>* <span style="color: #DFAF8F;">argv_child</span>[argc + 1];
    memcpy(argv_child, argv, <span style="color: #7CB8BB;">argc</span> * <span style="color: #F0DFAF; font-weight: bold;">sizeof</span>(<span style="color: #7CB8BB;">char</span> *));
    argv_child[argc] = <span style="color: #BFEBBF;">NULL</span>;

    <span style="color: #F0DFAF; font-weight: bold;">if</span> (execvp(argv_child[0], argv_child)) {
        FATAL_CHILD(<span style="color: #CC9393;">"executing %s failed: %s\n"</span>, argv_child[0],
                strerror(errno));
    }
}
</pre>
</div>
<p>
parent()实现就比较复杂一些。
</p>
<div class="org-src-container">

<pre class="src src-c">    <span style="color: #5F7F5F;">// </span><span style="color: #7F9F7F;">static int parent(const char *tag, int parent_read, pid_t pid,</span>
    <span style="color: #5F7F5F;">//     </span><span style="color: #7F9F7F;">int *chld_sts, int log_target, bool abbreviated, char *file_path) {</span>

    ...

<span style="color: #F0DFAF; font-weight: bold;">struct</span> <span style="color: #7CB8BB;">pollfd</span> poll_fds[] = {
    [0] = {
        .fd = parent_read,
        .events = POLLIN,
    },
};
<span style="color: #F0DFAF; font-weight: bold;">struct</span> <span style="color: #7CB8BB;">log_info</span> <span style="color: #DFAF8F;">log_info</span>;

log_info.btag = basename(tag);
<span style="color: #F0DFAF; font-weight: bold;">if</span> (<span style="color: #F0DFAF; font-weight: bold;">!</span>log_info.btag) {
    log_info.btag = (<span style="color: #7CB8BB;">char</span>*) tag;
}

<span style="color: #F0DFAF; font-weight: bold;">if</span> (abbreviated &amp;&amp; (log_target == LOG_NONE)) {
    abbreviated = 0;
}
<span style="color: #F0DFAF; font-weight: bold;">if</span> (abbreviated) {
    init_abbr_buf(&amp;log_info.a_buf);
}

<span style="color: #F0DFAF; font-weight: bold;">if</span> (log_target &amp; LOG_KLOG) {
    snprintf(log_info.klog_fmt, <span style="color: #F0DFAF; font-weight: bold;">sizeof</span>(log_info.klog_fmt),
             <span style="color: #CC9393;">"&lt;6&gt;%.*s: %%s"</span>, MAX_KLOG_TAG, log_info.btag);
}

<span style="color: #F0DFAF; font-weight: bold;">if</span> ((log_target &amp; LOG_FILE) &amp;&amp; <span style="color: #F0DFAF; font-weight: bold;">!</span>file_path) {
    <span style="color: #5F7F5F;">/* </span><span style="color: #7F9F7F;">No file_path specified, clear the LOG_FILE bit </span><span style="color: #5F7F5F;">*/</span>
    log_target &amp;= ~LOG_FILE;
}

<span style="color: #F0DFAF; font-weight: bold;">if</span> (log_target &amp; LOG_FILE) {
    fd = open(file_path, O_WRONLY | O_CREAT, 0664);
    <span style="color: #F0DFAF; font-weight: bold;">if</span> (fd &lt; 0) {
        ERROR(<span style="color: #CC9393;">"Cannot log to file %s\n"</span>, file_path);
        log_target &amp;= ~LOG_FILE;
    } <span style="color: #F0DFAF; font-weight: bold;">else</span> {
        lseek(fd, 0, SEEK_END);
        log_info.fp = fdopen(fd, <span style="color: #CC9393;">"a"</span>);
    }
}

log_info.log_target = log_target;
log_info.abbreviated = abbreviated;

<span style="color: #F0DFAF; font-weight: bold;">while</span> (<span style="color: #F0DFAF; font-weight: bold;">!</span>found_child) {
    <span style="color: #F0DFAF; font-weight: bold;">if</span> (TEMP_FAILURE_RETRY(poll(poll_fds, ARRAY_SIZE(poll_fds), -1)) &lt; 0) {
        ERROR(<span style="color: #CC9393;">"poll failed\n"</span>);
        rc = -1;
        <span style="color: #F0DFAF; font-weight: bold;">goto</span> <span style="color: #BFEBBF;">err_poll</span>;
    }

    <span style="color: #F0DFAF; font-weight: bold;">if</span> (poll_fds[0].revents &amp; POLLIN) {
        sz = read(parent_read, &amp;buffer[b], <span style="color: #F0DFAF; font-weight: bold;">sizeof</span>(buffer) - 1 - b);

        sz += b;
        <span style="color: #5F7F5F;">// </span><span style="color: #7F9F7F;">Log one line at a time</span>
        <span style="color: #F0DFAF; font-weight: bold;">for</span> (b = 0; b &lt; sz; b++) {
            <span style="color: #F0DFAF; font-weight: bold;">if</span> (buffer[b] == <span style="color: #CC9393;">'\r'</span>) {
                <span style="color: #F0DFAF; font-weight: bold;">if</span> (abbreviated) {
                    buffer[b] = <span style="color: #CC9393;">'\n'</span>;
                } <span style="color: #F0DFAF; font-weight: bold;">else</span> {
                    buffer[b] = <span style="color: #CC9393;">'\0'</span>;
                }
            } <span style="color: #F0DFAF; font-weight: bold;">else</span> <span style="color: #F0DFAF; font-weight: bold;">if</span> (buffer[b] == <span style="color: #CC9393;">'\n'</span>) {
                buffer[b] = <span style="color: #CC9393;">'\0'</span>;
                log_line(&amp;log_info, &amp;buffer[a], b - a);
                a = b + 1;
            }
        }

        <span style="color: #F0DFAF; font-weight: bold;">if</span> (a == 0 &amp;&amp; b == <span style="color: #F0DFAF; font-weight: bold;">sizeof</span>(buffer) - 1) {
            <span style="color: #5F7F5F;">// </span><span style="color: #7F9F7F;">buffer is full, flush</span>
            buffer[b] = <span style="color: #CC9393;">'\0'</span>;
            log_line(&amp;log_info, &amp;buffer[a], b - a);
            b = 0;
        } <span style="color: #F0DFAF; font-weight: bold;">else</span> <span style="color: #F0DFAF; font-weight: bold;">if</span> (a != b) {
            <span style="color: #5F7F5F;">// </span><span style="color: #7F9F7F;">Keep left-overs</span>
            b -= a;
            memmove(buffer, &amp;buffer[a], b);
            a = 0;
        } <span style="color: #F0DFAF; font-weight: bold;">else</span> {
            a = 0;
            b = 0;
        }
    }

    <span style="color: #F0DFAF; font-weight: bold;">if</span> (poll_fds[0].revents &amp; POLLHUP) {
        <span style="color: #7CB8BB;">int</span> <span style="color: #DFAF8F;">ret</span>;

        ret = waitpid(pid, &amp;status, WNOHANG);
        <span style="color: #F0DFAF; font-weight: bold;">if</span> (ret &lt; 0) {
            rc = errno;
            ALOG(LOG_ERROR, <span style="color: #CC9393;">"logwrap"</span>, <span style="color: #CC9393;">"waitpid failed with %s\n"</span>, strerror(errno));
            <span style="color: #F0DFAF; font-weight: bold;">goto</span> <span style="color: #BFEBBF;">err_waitpid</span>;
        }
        <span style="color: #F0DFAF; font-weight: bold;">if</span> (ret &gt; 0) {
            found_child = <span style="color: #BFEBBF;">true</span>;
        }
    }
}
</pre>
</div>
<p>
parent()函数的主体是一个while()循环，当主设备中有数据可读时，将其读出，
并调用log_line()写入相应的log文件。
</p>
<div class="org-src-container">

<pre class="src src-c"><span style="color: #5F7F5F;">/* </span><span style="color: #7F9F7F;">Log directly to the specified log </span><span style="color: #5F7F5F;">*/</span>
<span style="color: #F0DFAF; font-weight: bold;">static</span> <span style="color: #7CB8BB;">void</span> <span style="color: #93E0E3;">do_log_line</span>(<span style="color: #F0DFAF; font-weight: bold;">struct</span> <span style="color: #7CB8BB;">log_info</span> *<span style="color: #DFAF8F;">log_info</span>, <span style="color: #7CB8BB;">char</span> *<span style="color: #DFAF8F;">line</span>) {
    <span style="color: #F0DFAF; font-weight: bold;">if</span> (log_info-&gt;log_target &amp; LOG_KLOG) {
        klog_write(6, log_info-&gt;klog_fmt, line);
    }
    <span style="color: #F0DFAF; font-weight: bold;">if</span> (log_info-&gt;log_target &amp; LOG_ALOG) {
        ALOG(LOG_INFO, log_info-&gt;btag, <span style="color: #CC9393;">"%s"</span>, line);
    }
    <span style="color: #F0DFAF; font-weight: bold;">if</span> (log_info-&gt;log_target &amp; LOG_FILE) {
        fprintf(log_info-&gt;fp, <span style="color: #CC9393;">"%s\n"</span>, line);
    }
}

<span style="color: #5F7F5F;">/* </span><span style="color: #7F9F7F;">Log to either the abbreviated buf, or directly to the specified log</span>
<span style="color: #7F9F7F;"> * via do_log_line() above.</span>
<span style="color: #7F9F7F;"> </span><span style="color: #5F7F5F;">*/</span>
<span style="color: #F0DFAF; font-weight: bold;">static</span> <span style="color: #7CB8BB;">void</span> <span style="color: #93E0E3;">log_line</span>(<span style="color: #F0DFAF; font-weight: bold;">struct</span> <span style="color: #7CB8BB;">log_info</span> *<span style="color: #DFAF8F;">log_info</span>, <span style="color: #7CB8BB;">char</span> *<span style="color: #DFAF8F;">line</span>, <span style="color: #7CB8BB;">int</span> <span style="color: #DFAF8F;">len</span>) {
    <span style="color: #F0DFAF; font-weight: bold;">if</span> (log_info-&gt;abbreviated) {
        add_line_to_abbr_buf(&amp;log_info-&gt;a_buf, line, len);
    } <span style="color: #F0DFAF; font-weight: bold;">else</span> {
        do_log_line(log_info, line);
    }
}

<span style="color: #F0DFAF; font-weight: bold;">static</span> <span style="color: #7CB8BB;">void</span> <span style="color: #93E0E3;">add_line_to_abbr_buf</span>(<span style="color: #F0DFAF; font-weight: bold;">struct</span> <span style="color: #7CB8BB;">abbr_buf</span> *<span style="color: #DFAF8F;">a_buf</span>, <span style="color: #7CB8BB;">char</span> *<span style="color: #DFAF8F;">linebuf</span>, <span style="color: #7CB8BB;">int</span> <span style="color: #DFAF8F;">linelen</span>) {
    <span style="color: #F0DFAF; font-weight: bold;">if</span> (<span style="color: #F0DFAF; font-weight: bold;">!</span>a_buf-&gt;beginning_buf_full) {
        a_buf-&gt;beginning_buf_full =
            add_line_to_linear_buf(&amp;a_buf-&gt;b_buf, linebuf, linelen);
    }
    <span style="color: #F0DFAF; font-weight: bold;">if</span> (a_buf-&gt;beginning_buf_full) {
        add_line_to_circular_buf(&amp;a_buf-&gt;e_buf, linebuf, linelen);
    }
}
</pre>
</div>
<p>
如果abbreviated没有被设置，则通过do_log_line()直接把log写入相应位置。
否则调用add_line_to_abbr_buf()，把log写入到log_info结构体的buf中。
</p>

<div class="org-src-container">

<pre class="src src-c">    <span style="color: #F0DFAF; font-weight: bold;">if</span> (chld_sts != <span style="color: #BFEBBF;">NULL</span>) {
        *chld_sts = status;
    } <span style="color: #F0DFAF; font-weight: bold;">else</span> {
      <span style="color: #F0DFAF; font-weight: bold;">if</span> (WIFEXITED(status))
        rc = WEXITSTATUS(status);
      <span style="color: #F0DFAF; font-weight: bold;">else</span>
        rc = -ECHILD;
    }

    <span style="color: #5F7F5F;">// </span><span style="color: #7F9F7F;">Flush remaining data</span>
    <span style="color: #F0DFAF; font-weight: bold;">if</span> (a != b) {
      buffer[b] = <span style="color: #CC9393;">'\0'</span>;
      log_line(&amp;log_info, &amp;buffer[a], b - a);
    }

    <span style="color: #5F7F5F;">/* </span><span style="color: #7F9F7F;">All the output has been processed, time to dump the abbreviated output </span><span style="color: #5F7F5F;">*/</span>
    <span style="color: #F0DFAF; font-weight: bold;">if</span> (abbreviated) {
        print_abbr_buf(&amp;log_info);
    }

    <span style="color: #F0DFAF; font-weight: bold;">if</span> (WIFEXITED(status)) {
      <span style="color: #F0DFAF; font-weight: bold;">if</span> (WEXITSTATUS(status)) {
        snprintf(tmpbuf, <span style="color: #F0DFAF; font-weight: bold;">sizeof</span>(tmpbuf),
                 <span style="color: #CC9393;">"%s terminated by exit(%d)\n"</span>, log_info.btag, WEXITSTATUS(status));
        do_log_line(&amp;log_info, tmpbuf);
      }
    } <span style="color: #F0DFAF; font-weight: bold;">else</span> {
      <span style="color: #F0DFAF; font-weight: bold;">if</span> (WIFSIGNALED(status)) {
        snprintf(tmpbuf, <span style="color: #F0DFAF; font-weight: bold;">sizeof</span>(tmpbuf),
                       <span style="color: #CC9393;">"%s terminated by signal %d\n"</span>, log_info.btag, WTERMSIG(status));
        do_log_line(&amp;log_info, tmpbuf);
      } <span style="color: #F0DFAF; font-weight: bold;">else</span> <span style="color: #F0DFAF; font-weight: bold;">if</span> (WIFSTOPPED(status)) {
        snprintf(tmpbuf, <span style="color: #F0DFAF; font-weight: bold;">sizeof</span>(tmpbuf),
                       <span style="color: #CC9393;">"%s stopped by signal %d\n"</span>, log_info.btag, WSTOPSIG(status));
        do_log_line(&amp;log_info, tmpbuf);
      }
    }

<span style="color: #BFEBBF;">err_waitpid</span>:
<span style="color: #BFEBBF;">err_poll</span>:
    <span style="color: #F0DFAF; font-weight: bold;">if</span> (log_target &amp; LOG_FILE) {
        fclose(log_info.fp); <span style="color: #5F7F5F;">/* </span><span style="color: #7F9F7F;">Also closes underlying fd </span><span style="color: #5F7F5F;">*/</span>
    }
    <span style="color: #F0DFAF; font-weight: bold;">if</span> (abbreviated) {
        free_abbr_buf(&amp;log_info.a_buf);
    }
    <span style="color: #F0DFAF; font-weight: bold;">return</span> rc;
</pre>
</div>
</div>
</div>
</div>
</div>
<div id="postamble" class="status">
<p class="postamble">Created At <span class="timestamp-wrapper"><span class="timestamp">&lt;2013-07-17 Wed 23:17&gt;</span></span> by Luis Xu. Email: <a href="mailto:xuzhengchaojob@gmail.com">xuzhengchaojob@gmail.com</a></p>
</div>
</body>
</html>
