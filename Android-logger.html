<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
"http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en">
<head>
<!-- 2016-08-16 Tue 19:06 -->
<meta  http-equiv="Content-Type" content="text/html;charset=utf-8" />
<meta  name="viewport" content="width=device-width, initial-scale=1" />
<title>Android Logger</title>
<meta  name="generator" content="Org-mode" />
<meta  name="author" content="Zhengchao Xu" />
<link rel="stylesheet" title="Standard" href="/style/worg.css" type="text/css" />
<link rel="alternate stylesheet" title="Zenburn" href="/style/worg-zenburn.css" type="text/css" />
<link rel="alternate stylesheet" title="Classic" href="/style/worg-classic.css" type="text/css" />
<link rel="SHORTCUT ICON" href="/org-mode-unicorn.ico" type="image/x-icon" />
<link rel="icon" href="/org-mode-unicorn.ico" type="image/ico" />
<script type="text/javascript">
/*
@licstart  The following is the entire license notice for the
JavaScript code in this tag.

Copyright (C) 2012-2013 Free Software Foundation, Inc.

The JavaScript code in this tag is free software: you can
redistribute it and/or modify it under the terms of the GNU
General Public License (GNU GPL) as published by the Free Software
Foundation, either version 3 of the License, or (at your option)
any later version.  The code is distributed WITHOUT ANY WARRANTY;
without even the implied warranty of MERCHANTABILITY or FITNESS
FOR A PARTICULAR PURPOSE.  See the GNU GPL for more details.

As additional permission under GNU GPL version 3 section 7, you
may distribute non-source (e.g., minimized or compacted) forms of
that code without the copy of the GNU GPL normally required by
section 4, provided you include this license notice and a URL
through which recipients can access the Corresponding Source.


@licend  The above is the entire license notice
for the JavaScript code in this tag.
*/
<!--/*--><![CDATA[/*><!--*/
 function CodeHighlightOn(elem, id)
 {
   var target = document.getElementById(id);
   if(null != target) {
     elem.cacheClassElem = elem.className;
     elem.cacheClassTarget = target.className;
     target.className = "code-highlighted";
     elem.className   = "code-highlighted";
   }
 }
 function CodeHighlightOff(elem, id)
 {
   var target = document.getElementById(id);
   if(elem.cacheClassElem)
     elem.className = elem.cacheClassElem;
   if(elem.cacheClassTarget)
     target.className = elem.cacheClassTarget;
 }
/*]]>*///-->
</script>
</head>
<body>
<div id="preamble" class="status">
<script type="text/javascript">

  var _gaq = _gaq || [];
  _gaq.push(['_setAccount', 'UA-7691209-1']);
  _gaq.push(['_trackPageview']);

  (function() {
    var ga = document.createElement('script'); ga.type = 'text/javascript'; ga.async = true;
    ga.src = ('https:' == document.location.protocol ? 'https://ssl' : 'http://www') + '.google-analytics.com/ga.js';
    var s = document.getElementsByTagName('script')[0]; s.parentNode.insertBefore(ga, s);
  })();

  document.addEventListener('DOMContentLoaded',function() {
      document.getElementById("table-of-contents").onclick = function() {
          var elem = document.getElementById("text-table-of-contents");
          elem.style.display = elem.style.display == "block" ? "none" : "block";
      }
  });
</script>
</div>
<div id="content">
<h1 class="title">Android Logger</h1>
<div id="table-of-contents">
<h2>Table of Contents</h2>
<div id="text-table-of-contents">
<ul>
<li><a href="#orgheadline1">打开Logger设备</a></li>
<li><a href="#orgheadline2">读logger</a></li>
<li><a href="#orgheadline3">Log write</a></li>
<li><a href="#orgheadline4">logger_poll</a></li>
</ul>
</div>
</div>
<p>
[logcat](../Android-logcat/) 和 [liblog](../Android-liblog/) 这两篇文章,讲到了android系统中如何读log和写log. 那么,log存放的位置在哪里? 本文就介绍一下android 系统中存放log的地方: logger device.
</p>

<p>
Android 在 kernel 层提供了四个虚拟的device 设备,用于存放log. 可以通过输入 `adb shell ls /dev/log/` 来查看系统的虚拟logger 设备. 这些设备是在系统启动的时候以内核模块的方式初始化.
</p>
<pre class="example">
device_initcall(logger_init);

static int __init logger_init(void)
{
	int ret;

	ret = create_log(LOGGER_LOG_MAIN, 256*1024);
	if (unlikely(ret))
		goto out;

	ret = create_log(LOGGER_LOG_EVENTS, 256*1024);
	if (unlikely(ret))
		goto out;

	ret = create_log(LOGGER_LOG_RADIO, 256*1024);
	if (unlikely(ret))
		goto out;

	ret = create_log(LOGGER_LOG_SYSTEM, 256*1024);
	if (unlikely(ret))
		goto out;

out:
	return ret;
}
</pre>
<p>
模块初始话函数通过create_log()生成四个device,并指定了每个device的大小.
</p>

<pre class="example">
	static int __init create_log(char *log_name, int size)
	{
		int ret = 0;
		struct logger_log *log;
		unsigned char *buffer;
	
		buffer = vmalloc(size);
		if (buffer == NULL)
			return -ENOMEM;
	
		log = kzalloc(sizeof(struct logger_log), GFP_KERNEL);
		if (log == NULL) {
			ret = -ENOMEM;
			goto out_free_buffer;
		}
		log-&gt;buffer = buffer;
	
		log-&gt;misc.minor = MISC_DYNAMIC_MINOR;
		log-&gt;misc.name = kstrdup(log_name, GFP_KERNEL);
		if (log-&gt;misc.name == NULL) {
			ret = -ENOMEM;
			goto out_free_log;
		}
	
		log-&gt;misc.fops = &amp;logger_fops;
		log-&gt;misc.parent = NULL;
	
		init_waitqueue_head(&amp;log-&gt;wq);
		INIT_LIST_HEAD(&amp;log-&gt;readers);
		mutex_init(&amp;log-&gt;mutex);
		log-&gt;w_off = 0;
		log-&gt;head = 0;
		log-&gt;size = size;
	
		INIT_LIST_HEAD(&amp;log-&gt;logs);
		list_add_tail(&amp;log-&gt;logs, &amp;log_list);
	
		/* finally, initialize the misc device for this log */
		ret = misc_register(&amp;log-&gt;misc);
		if (unlikely(ret)) {
			pr_err("failed to register misc device for log '%s'!\n",
					log-&gt;misc.name);
			goto out_free_log;
		}
	
		pr_info("created %luK log '%s'\n",
			(unsigned long) log-&gt;size &gt;&gt; 10, log-&gt;misc.name);
	
		return 0;
	
	out_free_log:
		kfree(log);
	
	out_free_buffer:
		vfree(buffer);
		return ret;
	}

对于每一个logger device,都对应一个核心的结构体: struct logger_log. create_log()函数的作用就是分配一个logger_log,初始化其变量,并通过misc_register()注册为misc设备.

对于之前介绍的 [logcat](../Android-logcat/) 和 [liblog](../Android-liblog/), 讲到都是通过read()/write()函数来读写log, read/write的实现则对应到driver层注册到file system的 fops.

	log-&gt;misc.fops = &amp;logger_fops;
	
	static const struct file_operations logger_fops = {
		.owner = THIS_MODULE,
		.read = logger_read,
		.aio_write = logger_aio_write,
		.poll = logger_poll,
		.unlocked_ioctl = logger_ioctl,
		.compat_ioctl = logger_ioctl,
		.open = logger_open,
		.release = logger_release,
	};
</pre>
<div id="outline-container-orgheadline1" class="outline-2">
<h2 id="orgheadline1">打开Logger设备</h2>
<div class="outline-text-2" id="text-orgheadline1">
<p>
在应用层通过调用open("/dev/log/main",O_RDWR)的方式可以打开一个logger设备,对应的kernel 层的实现是logger_open.
</p>

<pre class="example">
/* logger_open() */
log = get_log_from_minor(MINOR(inode-&gt;i_rdev));
if (!log)
	return -ENODEV;

if (file-&gt;f_mode &amp; FMODE_READ) {
	struct logger_reader *reader;

	reader = kmalloc(sizeof(struct logger_reader), GFP_KERNEL);
	if (!reader)
		return -ENOMEM;

	reader-&gt;log = log;
	reader-&gt;r_ver = 1;
	reader-&gt;r_all = in_egroup_p(inode-&gt;i_gid) ||
		capable(CAP_SYSLOG);

	INIT_LIST_HEAD(&amp;reader-&gt;list);

	mutex_lock(&amp;log-&gt;mutex);
	reader-&gt;r_off = log-&gt;head;
	list_add_tail(&amp;reader-&gt;list, &amp;log-&gt;readers);
	mutex_unlock(&amp;log-&gt;mutex);

	file-&gt;private_data = reader;
} else
	file-&gt;private_data = log;
</pre>
<p>
通过传入的inode节点的次设备号从log_list链表中找到对应的logger device的结构体. 接着会判断打开方式,如果打开方式中包含"read"(例如logcat)的话,会分配一个logger_read结构体被赋值给file的private_data变量,同时会把reader的读开始位置设为logger buffer的head位置(也就是从头开始读),然后把reader加入到logger的reader链表中.否则file的private_data变量直接指向logger.
</p>
</div>
</div>

<div id="outline-container-orgheadline2" class="outline-2">
<h2 id="orgheadline2">读logger</h2>
<div class="outline-text-2" id="text-orgheadline2">
<p>
read()函数对应logger_read.
</p>

<pre class="example">
.read = logger_read,

static ssize_t logger_read(struct file *file, char __user *buf,
			   size_t count, loff_t *pos)
{
	struct logger_reader *reader = file-&gt;private_data;
	struct logger_log *log = reader-&gt;log;
	ssize_t ret;
	DEFINE_WAIT(wait);

start:
	while (1) {
		mutex_lock(&amp;log-&gt;mutex);

		prepare_to_wait(&amp;log-&gt;wq, &amp;wait, TASK_INTERRUPTIBLE);

		ret = (log-&gt;w_off == reader-&gt;r_off);
		mutex_unlock(&amp;log-&gt;mutex);
		if (!ret)
			break;

		if (file-&gt;f_flags &amp; O_NONBLOCK) {
			ret = -EAGAIN;
			break;
		}

		if (signal_pending(current)) {
			ret = -EINTR;
			break;
		}

		schedule();
	}

	finish_wait(&amp;log-&gt;wq, &amp;wait);
	if (ret)
		return ret;
</pre>
<p>
首先程序会在一个while循环中做一些判断:如果w_off不等于r_off,表明目前logger中有log可读,跳出循环.否则,如果设备以非阻塞的方式打开,直接返回 -EAGAIN 的错误. 如果程序被信号打断,则返回 -EINTR. 如果这些条件都不满足,表示目前没有log可读,调用schedule()让出cpu.
</p>

<pre class="example">
/*logger_read()*/
mutex_lock(&amp;log-&gt;mutex);

if (!reader-&gt;r_all)
	reader-&gt;r_off = get_next_entry_by_uid(log,
		reader-&gt;r_off, current_euid());

/* is there still something to read or did we race? */
if (unlikely(log-&gt;w_off == reader-&gt;r_off)) {
	mutex_unlock(&amp;log-&gt;mutex);
	goto start;
}
</pre>
<p>
r_all部分目前还不太理解,以后再补充&#x2026;..(从代码来看,这个变量应该是与reader的权限有关,通过这个变量可以控制该reader是否有权限去读所有的log, 如果为0,表明reader没有该权限,只能读自己进程euid相等的log)
</p>

<pre class="example">
/*logger_read()*/
ret = get_user_hdr_len(reader-&gt;r_ver) +
	get_entry_msg_len(log, reader-&gt;r_off);
if (count &lt; ret) {
	ret = -EINVAL;
	goto out;
}
</pre>
<p>
通过get_user_hdr_len()及get_entry_msg_len()获取entry的header长度和entry长度,加起来就是一条log的长度.
</p>

<pre class="example">
static size_t get_user_hdr_len(int ver)
{
	if (ver &lt; 2)
		return sizeof(struct user_logger_entry_compat);
	else
		return sizeof(struct logger_entry);
}
</pre>
<p>
该函数会根据传入的reader成员r_ver的值来决定返回哪个长度的entry header值,因为在logger_open中该值被设定为1, 故该函数的返回值为 user_logger_entry_compat 的长度. 接着读取log entry的长度.
</p>

<pre class="example">
static __u32 get_entry_msg_len(struct logger_log *log, size_t off)
{
	struct logger_entry scratch;
	struct logger_entry *entry;

	entry = get_entry_header(log, off, &amp;scratch);
	return entry-&gt;len;
}


static struct logger_entry *get_entry_header(struct logger_log *log,
		size_t off, struct logger_entry *scratch)
{
	size_t len = min(sizeof(struct logger_entry), log-&gt;size - off);
	if (len != sizeof(struct logger_entry)) {
		memcpy(((void *) scratch), log-&gt;buffer + off, len);
		memcpy(((void *) scratch) + len, log-&gt;buffer,
			sizeof(struct logger_entry) - len);
		return scratch;
	}

	return (struct logger_entry *) (log-&gt;buffer + off);
}
</pre>
<p>
因为每个logger device的size都是固定大小,而系统中的log量要远远大于该size,故logger device都是采用 ring buffer的方式存放log. 这样就可能出现这个的情况,一条log的一部分在buffer尾部,而另一部分在buffer头部,所以每次从buffer读log都要考虑这种情况. 获得entry之后,通过entry的变量len就可以知道msg的长度. 调用 do_read_log_to_user()将entry+msg写到user的buf中.
</p>

<p>
ret = do_read_log_to_user(log, reader, buf, ret);
</p>
</div>
</div>

<div id="outline-container-orgheadline3" class="outline-2">
<h2 id="orgheadline3">Log write</h2>
<div class="outline-text-2" id="text-orgheadline3">
<p>
之前有讲,user space在写log的流程最后调用到了write()函数,对应到driver层的实现为 logger_aio_write(). 让我们一段一段的分析这个函数的实现.
</p>

<pre class="example">
static ssize_t logger_aio_write(struct kiocb *iocb, const struct iovec *iov,
			 unsigned long nr_segs, loff_t ppos)
{
	struct logger_log *log = file_get_log(iocb-&gt;ki_filp);
	size_t orig = log-&gt;w_off;
	struct logger_entry header;
	struct timespec now;
	ssize_t ret = 0;
</pre>
<p>
首先是调用file_get_log()函数获得这个文件结构体对应的logger设备. 在打开设备的代码中有讲,file结构体的private_data变量会存放两个值之一:logger或reader,所以这里会判断文件是否以FMODE_READ的方式打开,如果是,则private_data为reader,需要去reader中找logger,否则直接返回private_data.
</p>

<pre class="example">
static inline struct logger_log *file_get_log(struct file *file)
{
	if (file-&gt;f_mode &amp; FMODE_READ) {
		struct logger_reader *reader = file-&gt;private_data;
		return reader-&gt;log;
	} else
		return file-&gt;private_data;
}
</pre>
<p>
下面的代码通过系统参数初始化log entry的header.
</p>
<pre class="example">
now = current_kernel_time();

header.pid = current-&gt;tgid;
header.tid = current-&gt;pid;
header.sec = now.tv_sec;
header.nsec = now.tv_nsec;
header.euid = current_euid();
header.len = min_t(size_t, iocb-&gt;ki_left, LOGGER_ENTRY_MAX_PAYLOAD);
header.hdr_size = sizeof(struct logger_entry);

/* null writes succeed, return zero */
if (unlikely(!header.len))
	return 0;

mutex_lock(&amp;log-&gt;mutex);
</pre>
<p>
接下来调用fix_up_readers()函数,通过传入本次log的长度对该logger设备的readers进行修正.
</p>
<pre class="example">
	/*
	 * Fix up any readers, pulling them forward to the first readable
	 * entry after (what will be) the new write offset. We do this now
	 * because if we partially fail, we can end up with clobbered log
	 * entries that encroach on readable buffer.
	 */
	fix_up_readers(log, sizeof(struct logger_entry) + header.len);

static void fix_up_readers(struct logger_log *log, size_t len)
{
	size_t old = log-&gt;w_off;
	size_t new = logger_offset(log, old + len);
	struct logger_reader *reader;

	if (is_between(old, new, log-&gt;head))
		log-&gt;head = get_next_entry(log, log-&gt;head, len);

	list_for_each_entry(reader, &amp;log-&gt;readers, list)
		if (is_between(old, new, reader-&gt;r_off))
			reader-&gt;r_off = get_next_entry(log, reader-&gt;r_off, len);
}

static size_t get_next_entry(struct logger_log *log, size_t off, size_t len)
{
	size_t count = 0;

	do {
		size_t nr = sizeof(struct logger_entry) +
			get_entry_msg_len(log, off);
		off = logger_offset(log, off + nr);
		count += nr;
	} while (count &lt; len);

	return off;
}
</pre>
<p>
为什么要对reader进行修正?前面有讲过,logger buffer的size是固定的,系统采用ring buffer的方式写log,那么就会出现这样的情况,最新的logger会有机会覆盖前面的一条log,那么在这种情况下,对于reader来说,r_off这个参数就是无效的,因为下一条log(或者后面几条log)已经不存在了.
</p>

<p>
get_next_entry()的实现不难理解,因为新加入的log长度为len,即寻找从r_off+len位置之后的第一条有效log.
</p>

<p>
接下来就是真正把log的内容写入buffer
</p>
<pre class="example">
	do_write_log(log, &amp;header, sizeof(struct logger_entry));

	while (nr_segs-- &gt; 0) {
		size_t len;
		ssize_t nr;

		/* figure out how much of this vector we can keep */
		len = min_t(size_t, iov-&gt;iov_len, header.len - ret);

		/* write out this segment's payload */
		nr = do_write_log_from_user(log, iov-&gt;iov_base, len);
		if (unlikely(nr &lt; 0)) {
			log-&gt;w_off = orig;
			mutex_unlock(&amp;log-&gt;mutex);
			return nr;
		}

		iov++;
		ret += nr;
	}

	mutex_unlock(&amp;log-&gt;mutex);

	/* wake up any blocked readers */
	wake_up_interruptible(&amp;log-&gt;wq);

	return ret;
}
</pre>
<p>
首先会调用do_write_log()把header先写入buffer,这里直接调用memcpy(),header有可能被写到buffer的尾部和首部(ring buffer). 然后就是把user space传入的iovec数组的内容依次写入buffer. 如果写失败,会直接把logger的w_off位置roll back会之前的值.
</p>
</div>
</div>

<div id="outline-container-orgheadline4" class="outline-2">
<h2 id="orgheadline4">logger_poll</h2>
<div class="outline-text-2" id="text-orgheadline4">
<p>
在logcat的实现中曾讲到,logcat在打开logger设备后,会调用select()函数监控该logger设备,如果函数返回,表明有log可读,接下来就会调用read()读log.这里select对应的driver层函数就是logger_poll()
</p>

<pre class="example">
static unsigned int logger_poll(struct file *file, poll_table *wait)
{
	struct logger_reader *reader;
	struct logger_log *log;
	unsigned int ret = POLLOUT | POLLWRNORM;

	if (!(file-&gt;f_mode &amp; FMODE_READ))
		return ret;

	reader = file-&gt;private_data;
	log = reader-&gt;log;

	poll_wait(file, &amp;log-&gt;wq, wait);

	mutex_lock(&amp;log-&gt;mutex);
	if (!reader-&gt;r_all)
		reader-&gt;r_off = get_next_entry_by_uid(log,
			reader-&gt;r_off, current_euid());

	if (log-&gt;w_off != reader-&gt;r_off)
		ret |= POLLIN | POLLRDNORM;
	mutex_unlock(&amp;log-&gt;mutex);

	return ret;
}
</pre>
<p>
函数首先会判断是否以read的方式打开设备,如果不是,直接返回.(因为select()一般对应读操作,如果不读那么select()就没什么意义了).判断log是否可读的唯一条件就是w_off是否等于r_off.
</p>

<p>
OK,logger设备暂时就写到这里,以后有新的理解会继续补充.
</p>
</div>
</div>
</div>
<div id="postamble" class="status">
The code examples and css stylesheets are licensed under the <a href="http://www.gnu.org/licenses/gpl.html">GNU General Public License v3</a> or later.</p></div>
</div>
</body>
</html>
