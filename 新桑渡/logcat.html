<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
"http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en">
<head>
<!-- 2016-10-14 Fri 09:16 -->
<meta  http-equiv="Content-Type" content="text/html;charset=utf-8" />
<meta  name="viewport" content="width=device-width, initial-scale=1" />
<title>Android Logcat</title>
<meta  name="generator" content="Org-mode" />
<meta  name="author" content="Luis Xu" />
<link rel="stylesheet" title="Standard" href="/style/worg.css" type="text/css" />
<link rel="alternate stylesheet" title="Zenburn" href="/style/worg-zenburn.css" type="text/css" />
<link rel="alternate stylesheet" title="Classic" href="/style/worg-classic.css" type="text/css" />
<link rel="SHORTCUT ICON" href="/org-mode-unicorn.ico" type="image/x-icon" />
<link rel="icon" href="/org-mode-unicorn.ico" type="image/ico" />
<script type="text/javascript">
/*
@licstart  The following is the entire license notice for the
JavaScript code in this tag.

Copyright (C) 2012-2013 Free Software Foundation, Inc.

The JavaScript code in this tag is free software: you can
redistribute it and/or modify it under the terms of the GNU
General Public License (GNU GPL) as published by the Free Software
Foundation, either version 3 of the License, or (at your option)
any later version.  The code is distributed WITHOUT ANY WARRANTY;
without even the implied warranty of MERCHANTABILITY or FITNESS
FOR A PARTICULAR PURPOSE.  See the GNU GPL for more details.

As additional permission under GNU GPL version 3 section 7, you
may distribute non-source (e.g., minimized or compacted) forms of
that code without the copy of the GNU GPL normally required by
section 4, provided you include this license notice and a URL
through which recipients can access the Corresponding Source.


@licend  The above is the entire license notice
for the JavaScript code in this tag.
*/
<!--/*--><![CDATA[/*><!--*/
 function CodeHighlightOn(elem, id)
 {
   var target = document.getElementById(id);
   if(null != target) {
     elem.cacheClassElem = elem.className;
     elem.cacheClassTarget = target.className;
     target.className = "code-highlighted";
     elem.className   = "code-highlighted";
   }
 }
 function CodeHighlightOff(elem, id)
 {
   var target = document.getElementById(id);
   if(elem.cacheClassElem)
     elem.className = elem.cacheClassElem;
   if(elem.cacheClassTarget)
     target.className = elem.cacheClassTarget;
 }
/*]]>*///-->
</script>
<script type="text/x-mathjax-config">
    MathJax.Hub.Config({
        displayAlign: "center",
        displayIndent: "0em",

        "HTML-CSS": { scale: 100,
                        linebreaks: { automatic: "false" },
                        webFont: "TeX"
                       },
        SVG: {scale: 100,
              linebreaks: { automatic: "false" },
              font: "TeX"},
        NativeMML: {scale: 100},
        TeX: { equationNumbers: {autoNumber: "AMS"},
               MultLineWidth: "85%",
               TagSide: "right",
               TagIndent: ".8em"
             }
});
</script>
<script type="text/javascript"
        src="http://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS_HTML"></script>
</head>
<body>
<div id="preamble" class="status">
<script type="text/javascript">

  var _gaq = _gaq || [];
  _gaq.push(['_setAccount', 'UA-7691209-1']);
  _gaq.push(['_trackPageview']);

  (function() {
    var ga = document.createElement('script'); ga.type = 'text/javascript'; ga.async = true;
    ga.src = ('https:' == document.location.protocol ? 'https://ssl' : 'http://www') + '.google-analytics.com/ga.js';
    var s = document.getElementsByTagName('script')[0]; s.parentNode.insertBefore(ga, s);
  })();

  document.addEventListener('DOMContentLoaded',function() {
      document.getElementById("table-of-contents").onclick = function() {
          var elem = document.getElementById("text-table-of-contents");
          elem.style.display = elem.style.display == "block" ? "none" : "block";
      }
  });
</script>
</div>
<div id="content">
<h1 class="title">Android Logcat</h1>
<div id="table-of-contents">
<h2>Table of Contents</h2>
<div id="text-table-of-contents">
<ul>
<li><a href="#orgheadline1">test 参数</a></li>
<li><a href="#orgheadline2">"-s" 参数</a></li>
<li><a href="#orgheadline3">"-c" 参数</a></li>
<li><a href="#orgheadline4">"-d" "-t N" 参数</a></li>
<li><a href="#orgheadline5">"-g" 参数</a></li>
<li><a href="#orgheadline6">"-b device" 参数</a></li>
<li><a href="#orgheadline7">"-B" 参数</a></li>
<li><a href="#orgheadline8">"-f file" 参数</a></li>
<li><a href="#orgheadline9">"-r size" 参数</a></li>
<li><a href="#orgheadline10">"-n num" 参数</a></li>
<li><a href="#orgheadline11">"-v format" 参数</a></li>
<li><a href="#orgheadline12">读log</a></li>
</ul>
</div>
</div>
<p>
这篇文章介绍android系统中录log的工具 logcat.
</p>

<p>
Android 系统提供了一整套的API供Java层和Native层的程序写log,以方便调试及在系统出问题的时候有据可查. 
而logcat是把这些抓log的工具,可以通过logcat把log显示到标准输出或文件中,同时还可以对log进行过滤. 设定log level及只读取指定module的log. logcat 的详细用法可以在手机中输入"logcat &#x2013;help" 命令查看.
</p>

<p>
本文主要对logcat的源码进行分析,从main函数开始.从main函数开始遇到的第一个函数调用是.
</p>

<p>
g_logformat = android_log_format_new();
</p>

<p>
看下这个函数的定义:
</p>
<pre class="example">
/* android_log_format_new()*/
AndroidLogFormat *android_log_format_new()
{
    AndroidLogFormat *p_ret;

    p_ret = calloc(1, sizeof(AndroidLogFormat));

    p_ret-&gt;global_pri = ANDROID_LOG_VERBOSE;
    p_ret-&gt;format = FORMAT_BRIEF;

    return p_ret;
}
</pre>
<p>
这个函数通过malloc生成一个 AndroidLogFormat 的结构体,并将结构体的成员变量 'global_pri' 和 'format' 设置.先省略这个结构体的实现,继续看main 函数的代码.
</p>
<pre class="example">
    /* main()*/
if (argc == 2 &amp;&amp; 0 == strcmp(argv[1], "--test")) {
    logprint_run_tests();
    exit(0);
}
</pre>
<div id="outline-container-orgheadline1" class="outline-2">
<h2 id="orgheadline1">test 参数</h2>
<div class="outline-text-2" id="text-orgheadline1">
<p>
如果logcat只有一个参数"&#x2013;test",则执行logprint_run_tests()函数,从代码来看,这个函数主要是测试logcat的功能的.
</p>

<p>
    <i>* logprint_run_tests()*</i>
p_format = android_log_format_new();
fprintf(stderr, "running tests\n");
tag = "random";
android_log_addFilterRule(p_format,"*:i");
</p>

<p>
这个函数开始也call了一次 android_log_format_new()分配了一个结构体.并设置了tag变量,tag是每个module在打log时都需要设置一个tag,可以通过tag用来标志是该module输出的log. 接着call函数 android_log_addFilterRule(), 设置logcat的过滤机制.
</p>

<p>
    <i>* android_log_addFilterRule() *</i>
    android_LogPriority pri = ANDROID_LOG_DEFAULT;
    tagNameLength = strcspn(filterExpression, ":");
if(filterExpression[tagNameLength] == ':') {
    pri = filterCharToPri(filterExpression[tagNameLength+1]);
</p>

<p>
    if (pri == ANDROID_LOG_UNKNOWN) {
        goto error;
    }
}
</p>

<p>
该函数设置pri变量的值为 ANDROID_LOG_DEFAULT, 这个值被定义在一个enum中,如果log pririoty被设为 ANDROID_LOG_DEFAULT, 则表示输出所有等级的log.接着获得filter的tag的长度,根据前面的参数,"*:i"的返回结果是1, 接着调用filterCharToPri(),并传入参数"i"
. 这个函数把传入的字符形式的log level 转换为数字level,这些level和 ANDROID_LOG_DEFAULT一起定义在enum中.
</p>

<p>
} else if (c == 'i') {
    pri = ANDROID_LOG_INFO;
</p>

<p>
<i>* define *</i>
enum  {
    ANDROID_LOG_UNKNOWN = 0,
    ANDROID_LOG_DEFAULT,    <i>* only for SetMinPriority() *</i>
</p>

<p>
ANDROID_LOG_VERBOSE,
ANDROID_LOG_DEBUG,
ANDROID_LOG_INFO,
ANDROID_LOG_WARN,
ANDROID_LOG_ERROR,
ANDROID_LOG_FATAL,
</p>

<p>
ANDROID_LOG_SILENT,     <i>* only for SetMinPriority(); must be last *</i>
</p>

<p>
接下来判断是否有设置全局的log level,即传入的filter中是否包含"*:x"的字符串,如果是的话,就设置一个全局性的log level
</p>

<p>
<i>* android_log_addFilterRule() *</i>
    if(0 <code>= strncmp("*", filterExpression, tagNameLength)) {
        if (pri =</code> ANDROID_LOG_DEFAULT) {
    pri = ANDROID_LOG_DEBUG;
}
p_format-&gt;global_pri = pri;
</p>

<p>
这样,runtest()函数的filter设置就完成了,剩下都是一些基本的检查语句检查设置有没有成功.
</p>

<p>
assert (ANDROID_LOG_INFO == filterPriForTag(p_format, "random"));
</p>

<p>
这条语句检查tag "random"的priority是否是ANDROID_LOG_INFO,看下 filterPriForTag()函数实现
</p>

<p>
static android_LogPriority filterPriForTag(
        AndroidLogFormat *p_format, const char *tag)
{
    FilterInfo *p_curFilter;
    for (p_curFilter = p_format-&gt;filters
            ; p_curFilter != NULL
            ; p_curFilter = p_curFilter-&gt;p_next
    ) {
        if (0 <code>= strcmp(tag, p_curFilter-&gt;mTag)) {
	            if (p_curFilter-&gt;mPri =</code> ANDROID_LOG_DEFAULT) {
                return p_format-&gt;global_pri;
            } else {
                return p_curFilter-&gt;mPri;
            }
        }
    }
</p>

<p>
    return p_format-&gt;global_pri;
}
</p>

<p>
这段code很直观,首先遍历p_format的filter,检查有没有设置tag的priority, 如果没有找到,就返回全局的log level. 还有另一个需要检查的地方
</p>

<p>
assert(android_log_shouldPrintLine(p_format, tag, ANDROID_LOG_DEBUG) == 0);
</p>

<p>
在android中每条log都对应要一个priority,这个函数检查相应tag的这条log是否应该打印出来.
</p>

<p>
int android_log_shouldPrintLine (
        AndroidLogFormat *p_format, const char *tag, android_LogPriority pri)
{
    return pri &gt;= filterPriForTag(p_format, tag);
}
</p>

<p>
通过filterPriForTag()函数查找该tag的priority,然后跟传入的level做比较,判断是否需要打印该tag该level级别的log.
</p>

<p>
同时,可以通过 android_log_addFilterString()设定多个log filter.
</p>

<p>
err = android_log_addFilterString(p_format, "*:s random:d ");
</p>

<p>
int android_log_addFilterString(AndroidLogFormat *p_format,
        const char *filterString)
{
    // Yes, I'm using strsep
    while (NULL != (p_ret = strsep(&amp;p_cur, " \t,"))) {
        // ignore whitespace-only entries
        if(p_ret<sup><a id="fnr.1" class="footref" href="#fn.1">1</a></sup> != '\0') {
            err = android_log_addFilterRule(p_format, p_ret);
        }
    }
&#x2026;&#x2026;        
}
</p>

<p>
android_log_addFilterString()会循环遍历传入的filter string,并将其添加到filter 链表中.
ok, "&#x2013;test" 参数到这里就讲完了.
</p>
</div>
</div>

<div id="outline-container-orgheadline2" class="outline-2">
<h2 id="orgheadline2">"-s" 参数</h2>
<div class="outline-text-2" id="text-orgheadline2">
<p>
将全局的log level 设为 ANDROID_LOG_SILENT, 即不输出所有level的log
</p>

<p>
android_log_addFilterRule(g_logformat, "*:s");
</p>
</div>
</div>

<div id="outline-container-orgheadline3" class="outline-2">
<h2 id="orgheadline3">"-c" 参数</h2>
<div class="outline-text-2" id="text-orgheadline3">
<p>
该参数可以将log device中的log删除.
</p>

<p>
    case 'c':
   clearLog = 1;
   mode = O_WRONLY;
break;
</p>

<p>
if (clearLog) {
    int ret;
    ret = android::clearLog(dev-&gt;fd);
</p>

<p>
看下clearLog函数
</p>

<p>
static int clearLog(int logfd)
{
    return ioctl(logfd, LOGGER_FLUSH_LOG);
}
</p>

<p>
该函数向driver层下发 LOGGER_FLUSH_LOG 命令,告诉logger device的driver将logger中的log清除,关于logger device的实现在后面会讲到.
</p>
</div>
</div>

<div id="outline-container-orgheadline4" class="outline-2">
<h2 id="orgheadline4">"-d" "-t N" 参数</h2>
<div class="outline-text-2" id="text-orgheadline4">
<p>
这两个参数都会将g_nonblock变量设为true,表示把logger里的log读完就会立刻退出,而不会等待新log的写入. 同时"-t"参数后面还要跟着一个值N,表示只读最近的N条log.
</p>
</div>
</div>

<div id="outline-container-orgheadline5" class="outline-2">
<h2 id="orgheadline5">"-g" 参数</h2>
<div class="outline-text-2" id="text-orgheadline5">
<p>
给driver发送LOGGER_GET_LOG_BUF_SIZE, 获得logger device的大小.
</p>
</div>
</div>

<div id="outline-container-orgheadline6" class="outline-2">
<h2 id="orgheadline6">"-b device" 参数</h2>
<div class="outline-text-2" id="text-orgheadline6">
<p>
指定要从哪个buffer中读log, "-b"可以使用多次,例如" -b main -b radio"
</p>
</div>
</div>

<div id="outline-container-orgheadline7" class="outline-2">
<h2 id="orgheadline7">"-B" 参数</h2>
<div class="outline-text-2" id="text-orgheadline7">
<p>
以二进制方式打印log(目前默认会对log进行解析,以字符串形式打印)
</p>
</div>
</div>

<div id="outline-container-orgheadline8" class="outline-2">
<h2 id="orgheadline8">"-f file" 参数</h2>
<div class="outline-text-2" id="text-orgheadline8">
<p>
将log 输出到指定文件 file
</p>
</div>
</div>

<div id="outline-container-orgheadline9" class="outline-2">
<h2 id="orgheadline9">"-r size" 参数</h2>
<div class="outline-text-2" id="text-orgheadline9">
<p>
设定rotate size大小,rotate size 的含义是每种log 最多只有 size 大小. 录满后旧log会被覆盖
</p>
</div>
</div>

<div id="outline-container-orgheadline10" class="outline-2">
<h2 id="orgheadline10">"-n num" 参数</h2>
<div class="outline-text-2" id="text-orgheadline10">
<p>
设定每种log最大的log file数量,每个file的大小为 rotate_size/num
</p>
</div>
</div>

<div id="outline-container-orgheadline11" class="outline-2">
<h2 id="orgheadline11">"-v format" 参数</h2>
<div class="outline-text-2" id="text-orgheadline11">
<p>
设定输出的log 格式
</p>

<p>
err = setLogFormat (optarg);
static int setLogFormat(const char * formatString)
{
    static AndroidLogPrintFormat format;
</p>

<p>
format = android_log_formatFromString(formatString);
android_log_setPrintFormat(g_logformat, format);
</p>

<p>
    return 0;
}
</p>

<p>
AndroidLogPrintFormat android_log_formatFromString(const char * formatString)
{
    static AndroidLogPrintFormat format;
</p>

<p>
if (strcmp(formatString, "brief") <code>= 0) format = FORMAT_BRIEF;
	    else if (strcmp(formatString, "process") =</code> 0) format = FORMAT_PROCESS;
else if (strcmp(formatString, "tag") <code>= 0) format = FORMAT_TAG;
	    else if (strcmp(formatString, "thread") =</code> 0) format = FORMAT_THREAD;
else if (strcmp(formatString, "raw") <code>= 0) format = FORMAT_RAW;
	    else if (strcmp(formatString, "time") =</code> 0) format = FORMAT_TIME;
else if (strcmp(formatString, "threadtime") <code>= 0) format = FORMAT_THREADTIME;
	    else if (strcmp(formatString, "long") =</code> 0) format = FORMAT_LONG;
else format = FORMAT_OFF;
</p>

<p>
    return format;
}
</p>

<p>
第一个函数把字符串形式的format转换成整形表示,第二个参数把转换后的format设置到全局变量g_logformat中
</p>


<p>
OK, 到此为止,参数部分就解析完毕.接着执行下面的代码
</p>


<p>
如果没有指定"-b"参数的话,会默认打开 "main" 和 "system" 两个logger device
</p>

<p>
if (!devices) {
    devices = new log_device_t(strdup("<i>dev</i>"LOGGER_LOG_MAIN), false, 'm');
    android::g_devCount = 1;
    int accessmode =
              (mode &amp; O_RDONLY) ? R_OK : 0
</p>
<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">


<colgroup>
<col  class="org-left" />
</colgroup>
<tbody>
<tr>
<td class="org-left">(mode &amp; O_WRONLY) ? W_OK : 0;</td>
</tr>
</tbody>
</table>
<p>
    if (0 == access("<i>dev</i>"LOGGER_LOG_SYSTEM, accessmode)) {
        devices-&gt;next = new log_device_t(strdup("<i>dev</i>"LOGGER_LOG_SYSTEM), false, 's');
        android::g_devCount++;
    }
}
</p>

<p>
接下来是设定输出,如果没有指定"-f file"参数,默认输出到标准输出,否则打开file 文件.
</p>

<p>
static void setupOutput()
{
</p>

<p>
    if (g_outputFileName == NULL) {
        g_outFD = STDOUT_FILENO;
    } else {
        struct stat statbuf;
        g_outFD = openLogFile (g_outputFileName);
        fstat(g_outFD, &amp;statbuf);
        g_outByteCount = statbuf.st_size;
    }
}
</p>

<p>
如果有设定log filter的话,会解析字符串并加入到g_logformat的filter链表中 
</p>

<p>
for (int i = optind ; i &lt; argc ; i++) {
    err = android_log_addFilterString(g_logformat, argv[i]);
</p>

<p>
接下来会打开logger device,然后就是读log了.
</p>

<p>
android::readLogLines(devices);
</p>
</div>
</div>

<div id="outline-container-orgheadline12" class="outline-2">
<h2 id="orgheadline12">读log</h2>
<div class="outline-text-2" id="text-orgheadline12">
<p>
readLogLines()函数通过一个while loop不停的从kernel 层的logger device中读取log
</p>

<p>
while (1) {
    do {
        timeval timeout = { 0, 5000 <i>* 5ms *</i> }; // If we oversleep it's ok, i.e. ignore EINTR.
        FD_ZERO(&amp;readset);
        for (dev=devices; dev; dev = dev-&gt;next) {
            FD_SET(dev-&gt;fd, &amp;readset);
        }
        result = select(max + 1, &amp;readset, NULL, NULL, sleep ? NULL : &amp;timeout);
    } while (result <code>= -1 &amp;&amp; errno =</code> EINTR);
</p>

<p>
这里有设一个timeout,最开始这个值为false,标志一直等待有log产生. 如果为true, 表示这段时间内没有新的log产生,则会把以及读出来的log全部flush到输出.
</p>

<p>
如果select()返回,会检查是否有logger device可读,并尝试从device中读取一条log.
</p>
<pre class="example">
if (result &gt;= 0) {
    for (dev=devices; dev; dev = dev-&gt;next) {
        if (FD_ISSET(dev-&gt;fd, &amp;readset)) {
            queued_entry_t* entry = new queued_entry_t();
            ret = read(dev-&gt;fd, entry-&gt;buf, LOGGER_ENTRY_MAX_LEN);
</pre>
<p>
logger device read() 的实现是每次读取一条logger_entry, 并存放到结构体queued_entry_t 的成员变量 buf 中,queued_entry_t 的定义如下:
</p>
<pre class="example">
struct queued_entry_t {
    union {
	unsigned char buf[LOGGER_ENTRY_MAX_LEN + 1] __attribute__((aligned(4)));
	struct logger_entry entry __attribute__((aligned(4)));
    };
    queued_entry_t* next;

    queued_entry_t() {
	next = NULL;
    }
};
</pre>
<p>
可以看到buf和logger_entry被定义成union结构,所以读到buffer的内容同时是一条logger_entry.        该结构体的定义如下
</p>
<pre class="example">
struct logger_entry {
    uint16_t    len;    /* length of the payload */
    uint16_t    __pad;  /* no matter what, we get 2 bytes of padding */
    int32_t     pid;    /* generating process's pid */
    int32_t     tid;    /* generating process's tid */
    int32_t     sec;    /* seconds since Epoch */
    int32_t     nsec;   /* nanoseconds */
    char        msg[0]; /* the entry's payload */
};
</pre>
<p>
第一个变量len是字符串msg的长度,所以read()函数返回后会对返回值和len的值做比较,如果不相等,表示读的数据有错误.
</p>
<pre class="example">
else if (entry-&gt;entry.len != ret - sizeof(struct logger_entry)) {
   	fprintf(stderr, "read: unexpected length. Expected %d, got %d\n",
   	entry-&gt;entry.len, ret - sizeof(struct logger_entry));
   	exit(EXIT_FAILURE);
}
</pre>
<p>
接着会call device变量dev的enqueue()函数把刚读出来的log插入到dev的entry list中,并排序.
</p>
<pre class="example">
void enqueue(queued_entry_t* entry) {
    if (this-&gt;queue == NULL) {
        this-&gt;queue = entry;
    } else {
        queued_entry_t** e = &amp;this-&gt;queue;
        while (*e &amp;&amp; cmp(entry, *e) &gt;= 0) {
            e = &amp;((*e)-&gt;next);
        }
        entry-&gt;next = *e;
        *e = entry;
    }
}

    static int cmp(queued_entry_t* a, queued_entry_t* b) {
	int n = a-&gt;entry.sec - b-&gt;entry.sec;
	if (n != 0) {
	    return n;
	}
	return a-&gt;entry.nsec - b-&gt;entry.nsec;
    }
</pre>
<p>
插入的算法是从链表头开始已有entry与新entry的时间戳,如果新entry的产生时间比较晚,就继续与下一个entry比较. 其实理论上讲,晚到来的log总是产生时间晚的log,所以这种比较的比较次数一般要大于从尾部开始比较. 另外值得一提的是比较算法采用了指针的指针,比较简洁,避免插入时链表头的判断. Linus大婶曾经在一次访谈中说道"这才是指针的真正用法"&#x2026;&#x2026;.
</p>

<p>
接下来会打印log,需要说明的是没读出一次log就会判断是否需要打印log. 如果是select超时返回,会打印所有"需要"打印的log(这里加所有是因为如果使用"t"参数的话,只会打印最新的几条log),否则,会打印除最后一条log以外的所有log,剩一条log是为了下次时间戳的比较.
</p>
<pre class="example">
while (g_tail_lines == 0 || queued_lines &gt; g_tail_lines) {
chooseFirst(devices, &amp;dev);
if (dev == NULL || dev-&gt;queue-&gt;next == NULL) {
        break;
}
if (g_tail_lines == 0) {
        printNextEntry(dev);
} else {
    skipNextEntry(dev);
}
--queued_lines;
</pre>
<p>
chooseFirst()函数会把device链表中包含最新log的device选出来,这样对于多种类型的log输出到同一个文件的case,可以保证log按时间排序.
</p>
<pre class="example">
static void chooseFirst(log_device_t* dev, log_device_t** firstdev) {
    for (*firstdev = NULL; dev != NULL; dev = dev-&gt;next) {
	if (dev-&gt;queue != NULL &amp;&amp; (*firstdev == NULL || cmp(dev-&gt;queue, (*firstdev)-&gt;queue) &lt; 0)) {
	    *firstdev = dev;
	}
    }
}
</pre>
<p>
接着就是call printNextEntry()进行log输出.
</p>
<pre class="example">
static void printNextEntry(log_device_t* dev) {
    maybePrintStart(dev);
    if (g_printBinary) {
	printBinary(&amp;dev-&gt;queue-&gt;entry);
    } else {
	processBuffer(dev, &amp;dev-&gt;queue-&gt;entry);
    }
    skipNextEntry(dev);
}
</pre>
<p>
如果中指定了"B"参数,log将不会被解析,直接以二进制的方式输出,否则,调用 processBuffer()对log entry进行解析.
</p>
<pre class="example">
if (dev-&gt;binary) {
    err = android_log_processBinaryLogBuffer(buf, &amp;entry, g_eventTagMap,
            binaryMsgBuf, sizeof(binaryMsgBuf));
    //printf("&gt;&gt;&gt; pri=%d len=%d msg='%s'\n",
    //    entry.priority, entry.messageLen, entry.message);
} else {
    err = android_log_processLogBuffer(buf, &amp;entry);
}
</pre>
<p>
android log system目前有四种类型的log: main, system, radio, event. 其中前三种可以分为同一类型,log可以通过android_log_processLogBuffer()直接解析成人类可以读懂的文字. event log则稍有不同,解析后的log也要通过相应的文件才能读懂. 这里主要看一下常规log的解析.
</p>

<p>
android_log_processLogBuffer()的参数有两个,第一个是logger_entry变量,第二个是AndroidLogEntry变量,其实这两个结构体的内容大致相同,只不过后一个包含的信息更多一些.
</p>
<pre class="example">
struct logger_entry {
    uint16_t    len;    /* length of the payload */
    uint16_t    __pad;  /* no matter what, we get 2 bytes of padding */
    int32_t     pid;    /* generating process's pid */
    int32_t     tid;    /* generating process's tid */
    int32_t     sec;    /* seconds since Epoch */
    int32_t     nsec;   /* nanoseconds */
    char        msg[0]; /* the entry's payload */
};

typedef struct AndroidLogEntry_t {
    time_t tv_sec;
    long tv_nsec;
    android_LogPriority priority;
    int32_t pid;
    int32_t tid;
    const char * tag;
    size_t messageLen;
    const char * message;
} AndroidLogEntry;

int android_log_processLogBuffer(struct logger_entry *buf,
	                         AndroidLogEntry *entry)
{
    entry-&gt;tv_sec = buf-&gt;sec;
    entry-&gt;tv_nsec = buf-&gt;nsec;
    entry-&gt;pid = buf-&gt;pid;
    entry-&gt;tid = buf-&gt;tid;

    int msgStart = -1;
    int msgEnd = -1;

    int i;
    for (i = 1; i &lt; buf-&gt;len; i++) {
	if (buf-&gt;msg[i] == '\0') {
	    if (msgStart == -1) {
	        msgStart = i + 1;
	    } else {
	        msgEnd = i;
	        break;
	    }
	}
    }

    entry-&gt;priority = buf-&gt;msg[0];
    entry-&gt;tag = buf-&gt;msg + 1;
    entry-&gt;message = buf-&gt;msg + msgStart;
    entry-&gt;messageLen = msgEnd - msgStart;

    return 0;
}
</pre>
<p>
可以看到转换函数主要是把logger_entry的msg给分割成三个部分:priority, tag, message.
</p>

<p>
接着会调用android_log_shouldPrintLine()检查该该tag及该level的log是否应该被打印,如果是,则调用android_log_printLogLine()打印.
</p>
<pre class="example">
	/* android_log_printLogLine() */

    outBuffer = android_log_formatLogLine(p_format, defaultBuffer,
            sizeof(defaultBuffer), entry, &amp;totalLen);

    do {
        ret = write(fd, outBuffer, totalLen);
    } while (ret &lt; 0 &amp;&amp; errno == EINTR);

	......

    if (outBuffer != defaultBuffer) {
        free(outBuffer);
    }

前面讲过可以通过参数"-v"设置打印的log格式,所以android_log_formatLogLine()的作用就是将entry 转换为最终的打印格式.


	/* android_log_formatLogLine() */

    priChar = filterPriToChar(entry-&gt;priority);
    ptm = localtime(&amp;(entry-&gt;tv_sec));
    strftime(timeBuf, sizeof(timeBuf), "%m-%d %H:%M:%S", ptm);

    size_t prefixLen, suffixLen;

    switch (p_format-&gt;format) {
        case FORMAT_TAG:
            prefixLen = snprintf(prefixBuf, sizeof(prefixBuf),
                "%c/%-8s: ", priChar, entry-&gt;tag);
            strcpy(suffixBuf, "\n"); suffixLen = 1;
            break;
        case FORMAT_PROCESS:
            prefixLen = snprintf(prefixBuf, sizeof(prefixBuf),
                "%c(%5d) ", priChar, entry-&gt;pid);
            suffixLen = snprintf(suffixBuf, sizeof(suffixBuf),
                "  (%s)\n", entry-&gt;tag);
            break;
        case FORMAT_THREAD:
            prefixLen = snprintf(prefixBuf, sizeof(prefixBuf),
                "%c(%5d:%5d) ", priChar, entry-&gt;pid, entry-&gt;tid);
            strcpy(suffixBuf, "\n");
            suffixLen = 1;
            break;
        case FORMAT_RAW:
            prefixBuf[0] = 0;
            prefixLen = 0;
            strcpy(suffixBuf, "\n");
            suffixLen = 1;
            break;
        case FORMAT_TIME:
            prefixLen = snprintf(prefixBuf, sizeof(prefixBuf),
                "%s.%03ld %c/%-8s(%5d): ", timeBuf, entry-&gt;tv_nsec / 1000000,
                priChar, entry-&gt;tag, entry-&gt;pid);
            strcpy(suffixBuf, "\n");
            suffixLen = 1;
            break;
        case FORMAT_THREADTIME:
            prefixLen = snprintf(prefixBuf, sizeof(prefixBuf),
                "%s.%03ld %5d %5d %c %-8s: ", timeBuf, entry-&gt;tv_nsec / 1000000,
                entry-&gt;pid, entry-&gt;tid, priChar, entry-&gt;tag);
            strcpy(suffixBuf, "\n");
            suffixLen = 1;
            break;
        case FORMAT_LONG:
            prefixLen = snprintf(prefixBuf, sizeof(prefixBuf),
                "[ %s.%03ld %5d:%5d %c/%-8s ]\n",
                timeBuf, entry-&gt;tv_nsec / 1000000, entry-&gt;pid,
                entry-&gt;tid, priChar, entry-&gt;tag);
            strcpy(suffixBuf, "\n\n");
            suffixLen = 2;
            prefixSuffixIsHeaderFooter = 1;
            break;
        case FORMAT_BRIEF:
        default:
            prefixLen = snprintf(prefixBuf, sizeof(prefixBuf),
                "%c/%-8s(%5d): ", priChar, entry-&gt;tag, entry-&gt;pid);
            strcpy(suffixBuf, "\n");
            suffixLen = 1;
            break;
    }

    size_t numLines;
    size_t i;
    char *p;
    size_t bufferSize;
    const char *pm;


    ret[0] = '\0';       /* to start strcat off */

    p = ret;
    pm = entry-&gt;message;
</pre>
<p>
首先会将数字格式的priority转为字符格式,接着生成格式化时间字符串.然后进入switch判断当前的format形式,并生成对应的prefix. 因为snprintf/vsnprintf有个特点:虽然它们最多只会向buffer写入指定长度的字符串(也就是说,如果buffer不足,字符串会被截断),但是,它们的返回值确是理想情况下(buffer足够大)可以写入的字符串长度.所以程序接下来会判断返回值跟buffer size是否相等.
</p>

<pre class="example">
	/* android_log_formatLogLine() */
    if(prefixLen &gt;= sizeof(prefixBuf))
        prefixLen = sizeof(prefixBuf) - 1;
    if(suffixLen &gt;= sizeof(suffixBuf))
        suffixLen = sizeof(suffixBuf) - 1;

接着会遍历msg中的"\n"判断该条log需要分几行打出,每行打出的log都会有prefix字符串

	/* android_log_formatLogLine() */
    if (prefixSuffixIsHeaderFooter) {
        numLines = 1;
    } else {
        pm = entry-&gt;message;
        numLines = 0;

        while (pm &lt; (entry-&gt;message + entry-&gt;messageLen)) {
            if (*pm++ == '\n') numLines++;
        }
        if (pm &gt; entry-&gt;message &amp;&amp; *(pm-1) != '\n') numLines++;
    }
</pre>
<p>
在函数参数中已经传入了存log的buffer,但是,如果需要打印的log 长度超过了buffer size,则系统会重新malloc一个新的buffer,记住:这个buffer需要在函数外free掉!!!!(logcat的做法是判断函数返回值是否等于传入的buffer,如果不是,则表示有新buffer malloc,就会free掉)
</p>
<pre class="example">
    /* android_log_formatLogLine() */
bufferSize = (numLines * (prefixLen + suffixLen)) + entry-&gt;messageLen + 1;

if (defaultBufferSize &gt;= bufferSize) {
    ret = defaultBuffer;
} else {
    ret = (char *)malloc(bufferSize);

    if (ret == NULL) {
        return ret;
    }
}

    /* android_log_printLogLine() */
if (outBuffer != defaultBuffer) {
    free(outBuffer);
}
</pre>
<p>
最后是生成最终的log字符串.对于"long"格式的log format来讲,prefix只需打印一次,所以不需要遍历msg中的"\n".否则,对于每行log都要加上prefix.
</p>

<pre class="example">
if (prefixSuffixIsHeaderFooter) {
    strcat(p, prefixBuf);
    p += prefixLen;
    strncat(p, entry-&gt;message, entry-&gt;messageLen);
    p += entry-&gt;messageLen;
    strcat(p, suffixBuf);
    p += suffixLen;
} else {
    while(pm &lt; (entry-&gt;message + entry-&gt;messageLen)) {
        const char *lineStart;
        size_t lineLen;
        lineStart = pm;

        // Find the next end-of-line in message
        while (pm &lt; (entry-&gt;message + entry-&gt;messageLen)
                &amp;&amp; *pm != '\n') pm++;
        lineLen = pm - lineStart;

        strcat(p, prefixBuf);
        p += prefixLen;
        strncat(p, lineStart, lineLen);
        p += lineLen;
        strcat(p, suffixBuf);
        p += suffixLen;

        if (*pm == '\n') pm++;
    }
}

if (p_outLength != NULL) {
    *p_outLength = p - ret;
}

return ret;
</pre>
<p>
函数返回后,就把最终字符串写到输出. 
</p>

<p>
OK,logcat的用法及实现流程到这里就基本结束了.
</p>
</div>
</div>
<div id="footnotes">
<h2 class="footnotes">Footnotes: </h2>
<div id="text-footnotes">

<div class="footdef"><sup><a id="fn.1" class="footnum" href="#fnr.1">1</a></sup> <div class="footpara"><p class="footpara">
ignore 
</p></div></div>


</div>
</div></div>
<div id="postamble" class="status">
<p class="postamble">Created At <span class="timestamp-wrapper"><span class="timestamp">&lt;2013-07-10 Wed 23:15&gt;</span></span> by Luis Xu. Email: <a href="mailto:xuzhengchaojob@gmail.com">xuzhengchaojob@gmail.com</a></p>
</div>
</body>
</html>
