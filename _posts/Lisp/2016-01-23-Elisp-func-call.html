---
layout: post
title: Elisp 中的特殊函数调用
categories: [Lisp]
tag: [elisp]
---

<p>
Emacs lisp中最常见的函数调用即为List方式调用, 其形式为(name arg1..argn)
这种类型. 除此之外, Elisp还提供了其他的函数调用方式, 会在本文中进行介绍.
</p>

<div id="outline-container-orgheadline1" class="outline-2">
<h2 id="orgheadline1">funcall</h2>
<div class="outline-text-2" id="text-orgheadline1">
<p>
如果你实现不知道需要调用那个函数, 而是在运行时通过计算得出要调用的函数
名称(例如计算结果中包含函数名称). 那么可以通过funcall来调用函数.
funcall的用法为:
</p>
<pre class="example">
funcall function &amp;rest arguments
</pre>

<p>
funcall的参数function必须为lisp函数或基本函数, 不能为特殊函数(例如and)或宏.
funcall的所有参数都会在funcall被调用之前被处理. 所以如果要传函数,
函数名前面要带"'", 例如
</p>
<pre class="example">
(funcall 'list 'x 'y 'z)
</pre>
</div>
</div>
<div id="outline-container-orgheadline2" class="outline-2">
<h2 id="orgheadline2">apply</h2>
<div class="outline-text-2" id="text-orgheadline2">
<p>
apply跟<a href="#orgheadline1">funcall</a>很相似, 主要的区别就是apply的最后一个参数必须为list, apply会
将最后一个参数的元素拓展为其调用函数的参数. 例如下面的例子, 其调用的函数list的
参数为 x/y/z/a/b/c:
</p>
<pre class="example">
(apply 'list 'x 'y 'z '(a b c))
</pre>
</div>
</div>
<div id="outline-container-orgheadline3" class="outline-2">
<h2 id="orgheadline3">apply-partially</h2>
<div class="outline-text-2" id="text-orgheadline3">
<p>
该函数的定义为:
</p>
<pre class="example">
apply-partially func &amp;rest args
</pre>
<p>
该函数的返回值是一个新的函数, 当调用新返回的函数时, 实际是调用func函数, 
func函数的参数有args和新函数的参数组成. 通过下例可以说明apply-partially的用法,
当调用lxpa时, 实际调用的是list函数, 其参数为x, y, z.
</p>
<pre class="example">
;;将lxpa设为返回的新函数
(setq lxpa (apply-partially 'list 'x))

;;通过funcall调用lxpa, 传入参数 x, y
(funcall lxpa 'y 'z)
</pre>
</div>
</div>
<div id="outline-container-orgheadline4" class="outline-2">
<h2 id="orgheadline4">mapping类函数</h2>
<div class="outline-text-2" id="text-orgheadline4">
<p>
mapping类函数的一个特点就是会把函数参数映射到后面的"集合"中的每个元素,
这里的集合可以是list或其他集合类型. 下面是Elisp中常用的几个mapping函数.
</p>
</div>

<div id="outline-container-orgheadline5" class="outline-3">
<h3 id="orgheadline5">mapcar</h3>
<div class="outline-text-3" id="text-orgheadline5">
<p>
mapcar会将func依次映射到后面的集合参数中, 然后将结果合并成一个新的list
并返回. 这里的集合可以是除了char-table之外的所有参数.
例如下例, 将car函数作用于后面list的每个元素, 并将结果生成新的list,
结果为(a 1).
</p>
<pre class="example">
(mapcar 'car '((a b c) (1 2 3 4)) ==&gt; (a 1)
</pre>

<p>
官方文档给出了一个更复杂一些的例子, 结合mapcar和apply定义了一个更高级的函数,
</p>
<pre class="example">
          (defun mapcar* (function &amp;rest args)
            "Apply FUNCTION to successive cars of all ARGS.
          Return the list of results."
            ;; If no list is exhausted,
            (if (not (memq nil args))
                ;; apply function to CARs.
                (cons (apply function (mapcar 'car args))
                      (apply 'mapcar* function
                             ;; Recurse for rest of elements.
                             (mapcar 'cdr args)))))
;;函数效果
(mapcar* 'cons '(a b c) '(1 2 3 4)) ==&gt; ((a . 1) (b . 2) (c . 3))
(mapcar* '+ '(1 3 5) '(2 4 6 8)) ==&gt; (3 7 11)
</pre>

<p>
mapcar用来依次将func映射到后面list的每个参数里的元素, 直到某个参数遍历到
尾部.如两个示例所示.
</p>

<p>
下面是该函数主要代码的解释, *(apply function (mapcar 'car args))*这行代码
首付通过mapcar将car作用于每个参数, 获取其CAR槽位, 然后组合成list返回, 
然后通过apply将list的元素作为参数, 并调用func.具体到下面的实例, 在第一次调用
该函数时, 最后相当于调用(cons a 1). 然后通过递归调用mapcar*继续处理剩下的参数.
</p>
</div>
</div>
<div id="outline-container-orgheadline6" class="outline-3">
<h3 id="orgheadline6">mapc</h3>
<div class="outline-text-3" id="text-orgheadline6">
<p>
mapc的功能跟mapcar相同, 只是返回值不同, mapc的返回值为参数"集合".
因为返回值还为原来的"集合", 所以mapc一般适合对参数本身所代表的文件/数据
做处理. 例如可以将一个文件处理程序应用于多个文件.
</p>
<pre class="example">
(mapc 'file-proc 
   (list "file1" "file2" "file3"))
</pre>
</div>
</div>
<div id="outline-container-orgheadline7" class="outline-3">
<h3 id="orgheadline7">mapconcat</h3>
<div class="outline-text-3" id="text-orgheadline7">
<p>
mapconcat的定义如下, 它的function参数必须要返回一个字符串, 然后
会用separator将结果字符串拼接起来.
</p>
<pre class="example">
mapconcat function sequence separator

;;example
(mapconcat 'car '(("a" "b") ("c" "d")) "-") ==&gt; "a-c"
</pre>
</div>
</div>
</div>
