---
layout: post
title: Android Gradle Plugin User Guide 文档翻译 
tag: [Android, Gradle, Translate, TBD]
description: [Android Gradle插件用户文档中文翻译]
---

<p>
原文地址 <a href="http://tools.android.com/tech-docs/new-build-system/user-guide#TOC-Introduction">http://tools.android.com/tech-docs/new-build-system/user-guide#TOC-Introduction</a>.
</p>

<div id="outline-container-sec-1" class="outline-2">
<h2 id="sec-1">介绍</h2>
<div class="outline-text-2" id="text-1">
<p>
本文档针对&gt;=0.9版本的gradle插件,之前的插件不兼容.
</p>
</div>
<div id="outline-container-sec-1-1" class="outline-3">
<h3 id="sec-1-1">Android新编译系统的目标</h3>
<div class="outline-text-3" id="text-1-1">
<p>
包括:
</p>
<ul class="org-ul">
<li>代码和资源重用更方便.
</li>
<li>更容易生成应用的多个"形式", 例如多个APK文件或多个flavor.
</li>
<li>更容易配置/扩展/定制编译过程.
</li>
<li>更好的IDE整合.
</li>
</ul>
</div>
</div>

<div id="outline-container-sec-1-2" class="outline-3">
<h3 id="sec-1-2">为什么选择Gradle?</h3>
<div class="outline-text-3" id="text-1-2">
<p>
Gradle是个高级的编译系统,能够通过插件的方式建立客制化的编译逻辑.
Gradle的一些迷人特质包括:
</p>
<ul class="org-ul">
<li>使用DSL(Domain Specific Language)描述和操作编译逻辑.
</li>
<li>编译文件基于Groovy,通过混合DSL元素声明和代码操控来提供客制化逻辑.
</li>
<li>内置Maven/Ivy依赖.
</li>
<li>灵活性很高.
</li>
<li>插件可以提供自定义的DSL和API.
</li>
<li>提供了很好的IDE整合接口.
</li>
</ul>
</div>
</div>
</div>
<div id="outline-container-sec-2" class="outline-2">
<h2 id="sec-2">要求</h2>
<div class="outline-text-2" id="text-2">
<ol class="org-ol">
<li>Gradle1.10以上,插件0.11.1.
</li>
<li>Android SDK 19.
</li>
</ol>
</div>
</div>
<div id="outline-container-sec-3" class="outline-2">
<h2 id="sec-3">基础配置</h2>
<div class="outline-text-2" id="text-3">
<p>
在工程跟目录下定义了 build.gradle 描述工程的编译信息.
</p>
</div>
<div id="outline-container-sec-3-1" class="outline-3">
<h3 id="sec-3-1">简单配置文件</h3>
<div class="outline-text-3" id="text-3-1">
<ol class="org-ol">
<li>对于一个简单的java工程,需要在build.gradle里加入
<div class="org-src-container">

<pre class="src src-java">apply plugin: 'java'
</pre>
</div>
<p>
上述代码表示使用java插件,该插件随着Gradle包发布.可以使用该插件来
编译和测试java应用程序.
</p>
</li>
<li>对于一个简单的Android工程,build.gradle的内容一般为
(该文件一般位于每个模块的目录下面):
<div class="org-src-container">

<pre class="src src-java">buildscript {
    repositories {
	mavenCentral()
    }

    dependencies {
	classpath 'com.android.tools.build:gradle:0.11.1'
    }
}

apply plugin: 'android'

android {
    compileSdkVersion 19
    buildToolsVersion "19.0.0"
}
</pre>
</div>
<p>
上述代码描述了Android编译的三个方面:
</p>
<ul class="org-ul">
<li>buildscript{&#x2026;}: 配置编译驱动代码.
repositories描述了使用的仓库类型.这里使用MavenCentral()仓库.同时
dependencies描述了编译需要使用的依赖.这里使用0.11.1版本的build gradle.
注: 这里只是定义了编译相关的代码,与项目无关.项目需要定义自己的仓库和
依赖.
</li>
<li>apply plugin: 'android'. 定义使用android插件.
</li>
<li><a id="andriod" name="andriod"></a>{&#x2026;}段描述了android编译的所有参数.该段是Android DSL的入口.
默认情况下只需要定义编译目标和编译工具版本.即 compileSdkVersion 和
buildtoolsVersion字段.
<ul class="org-ul">
<li>注:这里只能定义 <i><b>android</b></i> plugin,如果使用 <i><b>java</b></i> plugin会报错.
</li>
<li>注:对于编译使用的sdk目录,可以在工程目录下定义 <b>local.properties</b> 文件
并在其中配置 <b>sdk.dir</b>.
或者也可以定义全局变量 ANDROID_HOME.
</li>
</ul>
</li>
</ul>
</li>
</ol>
</div>
</div>
<div id="outline-container-sec-3-2" class="outline-3">
<h3 id="sec-3-2">工程结构</h3>
<div class="outline-text-3" id="text-3-2">
</div><div id="outline-container-sec-3-2-1" class="outline-4">
<h4 id="sec-3-2-1">默认目录结构</h4>
<div class="outline-text-4" id="text-3-2-1">
<p>
上节描述的配置文件需要一个默认的目录结构.但是,gradle遵循
约定优于配置(convention over configuration)的概念,并在
需要的时候提供配置默认值.
source sets一般有两个目录:源码目录和测试目录.他们的位置:
</p>
<ul class="org-ul">
<li>src/main/
</li>
<li>src/androidTest/
</li>
</ul>
<p>
每个目录都如果下的一些子目录:
</p>
<ul class="org-ul">
<li>java/
</li>
<li>resources/ (这两个字段对Java和Android插件都适用)
</li>
</ul>
<p>
对于Android插件,还有一些额外的目录和文件:
</p>
<ul class="org-ul">
<li>AndroidManifest.xml
</li>
<li>res/
</li>
<li>assets/
</li>
<li>aidl/
</li>
<li>rs/
</li>
<li>jni/
</li>
</ul>
<p>
注: src/androidTest/AndroidManifest.xml并不需要,AS会自动创建.
</p>
</div>
</div>

<div id="outline-container-sec-3-2-2" class="outline-4">
<h4 id="sec-3-2-2">配置目录结构</h4>
<div class="outline-text-4" id="text-3-2-2">
<ol class="org-ol">
<li>java工程
gradle同时支持目录配置.例如对于一个java工程,可以使用如下配置:
<div class="org-src-container">

<pre class="src src-java">sourceSets {
    main {
	java {
	    srcDir 'src/java'
	}
	resources {
	    srcDir 'src/resources'
	}
    }
}
</pre>
</div>
<p>
注: srcDir会自动将目录添加到已存的"源码"列表中.
</p>

<p>
可以使用 <b>srcDirs</b> 关键字来替换默认的source目录.该字段后面跟着
路径数组,例如:
</p>
<div class="org-src-container">

<pre class="src src-java">sourceSets {
    main.java.srcDirs = ['src/java']
    main.resources.srcDirs = ['src/resources']
}
</pre>
</div>
</li>
<li>Android工程
android插件使用的语法跟上一节相同.但是会放在<a href="#andriod">2.3</a>字段中.
下面是一段实例代码,用于映射老的android架构到gradle中:
<div class="org-src-container">

<pre class="src src-android">android {
    sourceSets {
	main {
	    manifest.srcFile 'AndroidManifest.xml'
	    java.srcDirs = ['src']
	    resources.srcDirs = ['src']
	    aidl.srcDirs = ['src']
	    renderscript.srcDirs = ['src']
	    res.srcDirs = ['res']
	    assets.srcDirs = ['assets']
	}

	androidTest.setRoot('tests')
    }
}
</pre>
</div>
<p>
由于老架构将所有的源文件放到一个目录,所以这里需要设置所有组件的
路径为"src".
setRoot()函数可以将源码目录移动到新目录.例如这里将 src/androidTest/* 
移动到 test/*.
</p>
</li>
</ol>
</div>
</div>
</div>
<div id="outline-container-sec-3-3" class="outline-3">
<h3 id="sec-3-3">编译任务</h3>
<div class="outline-text-3" id="text-3-3">
</div><div id="outline-container-sec-3-3-1" class="outline-4">
<h4 id="sec-3-3-1">一般任务</h4>
<div class="outline-text-4" id="text-3-3-1">
<p>
使用插件会自动生成一个可以运行的任务集.一般的任务集包括:
</p>
<ul class="org-ul">
<li>assemble
生成工程的输出 outputs.
</li>
<li>check
执行所有的检查.
</li>
<li>build
同时执行assemble和check.
</li>
<li>clean 
清理工程的输出.
</li>
</ul>
<p>
assemble/check/build本身并不做什么实际工作.他们是一些"钩子"
任务,可以添加"真实"的任务来完成具体工作.这种特点可以实现对于
不同类型的工程(java/android/&#x2026;), 可以调用相同的任务.
例如:使用 <b>findbugs</b> 插件会创建一个新任务,并将 <b>check</b> 任务依赖
到新任务上,这样,当去调用check任务是会触发新任务.
</p>

<p>
在命令行: 可以使用下述命令运行 <b>高层次</b> 的任务: gradle task.
<b>gradlw tasks -all</b> 可以显示所有的任务及其依赖.
</p>
</div>
</div>
<div id="outline-container-sec-3-3-2" class="outline-4">
<h4 id="sec-3-3-2"><span class="todo TODO">TODO</span> Java工程任务</h4>
</div>
<div id="outline-container-sec-3-3-3" class="outline-4">
<h4 id="sec-3-3-3">Android工程任务</h4>
<div class="outline-text-4" id="text-3-3-3">
<p>
Android工程的任务一般包括:
</p>
<ul class="org-ul">
<li>assemble:  生成输出
</li>
<li>check: 检查
</li>
<li>connectedCheck: 执行检查动作,需要一个可以连接的设备或模拟器.该任务会同时
在机器上运行.
</li>
<li>deviceCheck: 使用API连接远程机器.
</li>
<li>build: 同时执行assemble和check.
</li>
<li>clean: 清理输出.
</li>
</ul>

<p>
每个Android工程,至少包含两个输出: debug APK和release APK. 这两种类型的APK分别
有对应的"钩子"任务可以分别编译:
</p>
<ul class="org-ul">
<li>assemble
<ul class="org-ul">
<li>assembleDebug
</li>
<li>assembleRelease
</li>
</ul>
</li>
</ul>
<p>
执行assemble任务会同时运行这两个子任务生成两个APK.
</p>

<p>
提示: Gradle支持"驼峰"格式的任务缩写.所有 "gradle assembleRelease"可以简写为
"gradle aR"(必须保证只有一个任务可以简写成这样).
</p>

<p>
对于check类型的任务,他们有自己的依赖:
</p>
<ul class="org-ul">
<li>check
<ul class="org-ul">
<li>lint
</li>
</ul>
</li>
<li>connectedCheck
<ul class="org-ul">
<li>connectedAndroidTest
</li>
<li>connectedUiAutomatorTest
</li>
</ul>
</li>
</ul>

<p>
同时,gradle插件对于所有的编译类型(debug/release/test),都创建了install/uninstall
任务.
</p>
</div>
</div>
</div>
<div id="outline-container-sec-3-4" class="outline-3">
<h3 id="sec-3-4">基础的编译客制化</h3>
<div class="outline-text-3" id="text-3-4">
<p>
Android插件提供了丰富的DSL语言来实现编译系统的客制化.
</p>
</div>
<div id="outline-container-sec-3-4-1" class="outline-4">
<h4 id="sec-3-4-1">Manifest项</h4>
<div class="outline-text-4" id="text-3-4-1">
<p>
使用DSL,可以配置如下的manifest项:
</p>
<ul class="org-ul">
<li>minSdkVersion
</li>
<li>targetSdkVersion
</li>
<li>versionCode
</li>
<li>versionName
</li>
<li>applicationId
</li>
<li>测试程序包名
</li>
<li>测试runner 方法
</li>
</ul>
<p>
例如: 
</p>
<div class="org-src-container">

<pre class="src src-android">android {
    compileSdkVersion 19
    buildToolsVersion "19.0.0"

    defaultConfig {
	versionCode 12
	versionName "2.0"
	minSdkVersion 16
	targetSdkVersion 16
    }
}
</pre>
</div>
<p>
上述所有的配置都放在 <b><i>android</i></b> 段的 <b>defaultConfig</b> 段中.
</p>

<p>
之前的android plugin版本,使用 <b>packageName</b> 字段来替代 manifest文件
中的 'packageName'字段.
从0.11.0开始,通过在build.gradle文件中定义 "applicationId"来实现上述替换.
以消除应用程序的包名和java包之间的混淆.
</p>

<p>
在build文件中进行上述配置的一个优势是灵活性高.例如,可以在其他文件或build文件
的其他地方定义一个函数并在defaultConfig中调用他.
</p>
<div class="org-src-container">

<pre class="src src-android">def computeVersionName() {
    ...
}

android {
    compileSdkVersion 19
    buildToolsVersion "19.0.0"

    defaultConfig {
	versionCode 12
	versionName computeVersionName()
	minSdkVersion 16
	targetSdkVersion 16
    }
}
</pre>
</div>

<p>
如果没有在配置文件中设置某个属性,会使用默认值.如果默认值是null(一些property的
默认值是null),则在编译过程中会使用manifest文件中定义的值.
</p>
</div>
</div>
<div id="outline-container-sec-3-4-2" class="outline-4">
<h4 id="sec-3-4-2">编译类型</h4>
<div class="outline-text-4" id="text-3-4-2">
<p>
Android插件默认会编译两个类型的应用程序:debug和release版本.
debug版本使用一个"已知"的name/password来签名应用(这样在编译过程
不会有提示).
</p>

<p>
可以使用<a id="BuildType" name="BuildType"></a>标签来对编译类型做配置,默认有debug和release段.
同时可以创建其他的编译类型.
</p>

<p>
例如下面有关buildType的DSL配置：
</p>
<div class="org-src-container">

<pre class="src src-android">android {
    buildTypes {
	debug {
	    applicationIdSuffix ".debug"
	}

	jnidebug.initWith(buildTypes.debug)
	jnidebug {
	    packageNameSuffix ".jnidebug"
	    jniDebuggable true
	}
    }
}
</pre>
</div>
<p>
上述配置实现了以下功能:
</p>
<ul class="org-ul">
<li>对默认的 debug 类型进行了定制:
<ul class="org-ul">
<li>将包名设置为 "applicationId.debug"(添加 debug 后缀).这样可以实现在一台机器上
同时安装 debug 包和 release 包.
</li>
</ul>
</li>
<li>创建新编译类型 jnidebug, 该类型复制了 debug 类型.
</li>
<li>客制化 jnidebug 类型,将后缀改为 "jnidebug",并开启 jni 调试功能.
</li>
</ul>
<p>
从上面是示例可以看到,创建一个新的编译类型就是在"buildType"下面创建新的元素.可以通过
调用initWith()复制,也可以用在后面跟大括号进行配置.
可以配置的属性包括:
TBD: 从原地址截图放在这里.
</p>

<p>
除了上述属性,还可以在编译代码或资源的时候使用编译类型,对于每个编译类型,默认都会在
src目录下创建一个同名目录(所以自定义编译类型不能为main或androidTest).
</p>

<p>
也可以使用如下代码重定向编译类型的sourceSets.
</p>
<div class="org-src-container">

<pre class="src src-android">android {
    sourceSets.jnidebug.setRoot('foo/jnidebug')
}
</pre>
</div>

<p>
同时,对于每个新的编译类型,都会创建一个相应的 assemble&lt;BuildTypeName&gt; 的任务.
所以上述示例会创建一个名为assembleJnidebug的任务.同时该任务也向assembleDebug和
assembleRelease一样,成为assemble任务的依赖.
注: 同样可以使用简写 "gradle aJ"来运行该任务.
</p>

<p>
关于编译类型的适用场景:
</p>
<ul class="org-ul">
<li>debug版本加入一些"权限", release版本去掉.
</li>
<li>自定义调试
</li>
<li>不同的模式使用不同的资源(例如在签名认证时使用不同的资源值).
</li>
</ul>

<p>
每个子目录下的代码/资源按照以下原则使用:
</p>
<ul class="org-ul">
<li>manifest文件跟app的manifest合并.
</li>
<li>代码作为另外一个源码目录.
</li>
<li>资源目录覆盖主目录中的相同值.
</li>
</ul>
</div>
</div>

<div id="outline-container-sec-3-4-3" class="outline-4">
<h4 id="sec-3-4-3">签名配置</h4>
<div class="outline-text-4" id="text-3-4-3">
<p>
对一个应用做签名需要以下东西:
</p>
<ul class="org-ul">
<li>一个keystore
</li>
<li>一个keystore 密码
</li>
<li>一个key别名
</li>
<li>一个key密码
</li>
<li>存储类型
</li>
</ul>
<p>
上述内容组成了签名配置,可以在buildType中使用"signingConfig"来引用.
</p>

<p>
默认情况下,会在$HOME/.android/目录下创建一个debug.keystore文件.该文件属于默认的
debug配置,即有一个已知的"keystore密码+别名+密码". "debug编译类型"默认使用这个
"debug签名配置".
</p>

<p>
Android插件支持签名配置的创建和客制化.通过<a id="signingConfigs" name="signingConfigs"></a>来实现.例如:
</p>
<div class="org-src-container">

<pre class="src src-android">android {
    signingConfigs {
	debug {
	    storeFile file("debug.keystore")
	}

	myConfig {
	    storeFile file("other.keystore")
	    storePassword "android"
	    keyAlias "androiddebugkey"
	    keyPassword "android"
	}
    }

    buildTypes {
	foo {
	    debuggable true
	    jniDebuggable true
	    signingConfig signingConfigs.myConfig
	}
    }
}
</pre>
</div>
<p>
上述代码修改了debug编译类型的keystore文件位置.并创建了一个新的签名配置和一个使用
该签名配置的新编译类型.
</p>

<p>
注:一般情况下,keystore文件存于工程的根目录下,但是也可以使用绝对路径(不推荐,可能会由于
操作系统的不同而导致问题.但是默认的debug编译类型除外).
</p>

<p>
注:如果工程使用版本控制系统.尽量不要将密码存在文件里.可以参考stackoverflow上的这个帖子.
<a href="http://stackoverflow.com/questions/18328730/how-to-create-a-release-signed-apk-file-using-gradle">http://stackoverflow.com/questions/18328730/how-to-create-a-release-signed-apk-file-using-gradle</a>.
</p>
</div>
</div>

<div id="outline-container-sec-3-4-4" class="outline-4">
<h4 id="sec-3-4-4">运行ProGuard混淆</h4>
<div class="outline-text-4" id="text-3-4-4">
<p>
Gradle插件支持4.10版本的ProGuard. ProGuard插件默认是启用的.如果在"编译类型"中设置了
<b>minifyEnable</b> 属性.会自动创建相关任务.例如在编译类型和flavor中使用ProGuard:
</p>
<div class="org-src-container">

<pre class="src src-android">android {
    buildTypes {
	release {
	    minifyEnabled true
	    proguardFile getDefaultProguardFile('proguard-android.txt')
	}
    }

    productFlavors {
	flavor1 {
	}
	flavor2 {
	    proguardFile 'some-other-rules.txt'
	}
    }
}
</pre>
</div>
<p>
默认有两个规则文件:
</p>
<ul class="org-ul">
<li>proguard-android.txt
</li>
<li>proguard-android-optimize.txt
</li>
</ul>
<p>
它们位于SDK中,可以通过getDefaultProguardFile()函数返回文件路径.除了启用优化功能外,
这两个文件的内容是一样的.
</p>
</div>
</div>

<div id="outline-container-sec-3-4-5" class="outline-4">
<h4 id="sec-3-4-5">压缩资源</h4>
<div class="outline-text-4" id="text-3-4-5">
<p>
可以在编译期间自动移除没用的资源.具体可以参考<a href="http://tools.android.com/tech-docs/new-build-system/resource-shrinking">http://tools.android.com/tech-docs/new-build-system/resource-shrinking</a>.
</p>
</div>
</div>
</div>
</div>

<div id="outline-container-sec-4" class="outline-2">
<h2 id="sec-4">依赖,库以及多工程设置</h2>
<div class="outline-text-2" id="text-4">
<p>
一个gradle工程可能会依赖其他的组件,这些组件可以是库或者其他gradle工程.
</p>
</div>
<div id="outline-container-sec-4-1" class="outline-3">
<h3 id="sec-4-1">依赖二进制包</h3>
<div class="outline-text-3" id="text-4-1">
</div><div id="outline-container-sec-4-1-1" class="outline-4">
<h4 id="sec-4-1-1">本地包</h4>
<div class="outline-text-4" id="text-4-1-1">
<p>
当需要使用外部的jar包时,需要在<a id="dependencies" name="dependencies"></a>段中添加<a id="compile" name="compile"></a>配置(dependencies是标准的DSL元素,不属于android段).
</p>
<div class="org-src-container">

<pre class="src src-android">dependencies {
    compile files('libs/foo.jar')
}

android {
    ...
}
</pre>
</div>
<p>
<b>compile</b> 配置一般用于配置主工程.这些jar包会被添加到编译路径并包入最后的APK中.
其他可以添加的依赖包括:
</p>
<ul class="org-ul">
<li>compile: 主工程
</li>
<li>androidTestCompile: 测试工程
</li>
<li>debugCompile: debug编译类型
</li>
<li>releaseCompile: release编译类型
</li>
</ul>
<p>
每创建一个新的类型,都会自动创建一个类似"&lt;buildtype&gt;Compile"的配置.
如果不同的编译类型需要不同的库依赖(或依赖库的不同版本),上述配置会很有用.
</p>
</div>
</div>
<div id="outline-container-sec-4-1-2" class="outline-4">
<h4 id="sec-4-1-2">远程组件</h4>
<div class="outline-text-4" id="text-4-1-2">
<p>
Gradle支持从Maven和Ivy库中下载依赖库.
首先将仓库添加到 <b>repositories</b> 段中.然后在 <b>dependencies</b> 中添加依赖.
</p>
<div class="org-src-container">

<pre class="src src-android">repositories {
    mavenCentral()
}

dependencies {
    compile 'com.google.guava:guava:11.0.2'
}
</pre>
</div>
<p>
注: Gradle支持本地和远端仓库.
注: 如果依赖自身也有依赖的话,都会被下载.
具体使用可以参考<a href="http://gradle.org/docs/current/userguide/artifact_dependencies_tutorial.html">http://gradle.org/docs/current/userguide/artifact_dependencies_tutorial.html</a>
和 <a href="http://gradle.org/docs/current/dsl/org.gradle.api.artifacts.dsl.DependencyHandler.html">http://gradle.org/docs/current/dsl/org.gradle.api.artifacts.dsl.DependencyHandler.html</a>.
</p>
</div>
</div>
</div>

<div id="outline-container-sec-4-2" class="outline-3">
<h3 id="sec-4-2">多工程设置</h3>
<div class="outline-text-3" id="text-4-2">
<p>
可以通过多工程设置来使一个gradle工程依赖其他的gradle工程.一般的多工程设置
是通过在项目根目录下添加子目录来实现的.例如:
</p>
<div class="org-src-container">

<pre class="src src-android">MyProject/
 + app/
 + libraries/
    + lib1/
    + lib2/
</pre>
</div>
<p>
上述代码设置了三个工程:
</p>
<ul class="org-ul">
<li>:app
</li>
<li>:libraries:lib1
</li>
<li>:libraries:lib2
</li>
</ul>
<p>
每个工程都有自己的"build.gradle"文件.另外,在根目录下需要定义"settings.gradle"
文件来声明这些工程.所以最后架构变为:
</p>
<ul class="org-ul">
<li>RootProject
<ul class="org-ul">
<li>settings.gradle
</li>
<li>app/
<ul class="org-ul">
<li>build.gradle
</li>
</ul>
</li>
<li>libraries
<ul class="org-ul">
<li>lib1/
<ul class="org-ul">
<li>build.gradle
</li>
</ul>
</li>
<li>lib2/
<ul class="org-ul">
<li>build.gradle
</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>

<p>
"settings.gradle"文件的内容为:"include ':app', ':libraries:lib1', ':libraries:lib2'";
文件定义了那些目录是一个gradle工程.
</p>

<p>
如果gradle工程之间有依赖的话,可以做如下设置.
</p>
<div class="org-src-container">

<pre class="src src-android">dependencies {
    compile project(':libraries:lib1')
}
</pre>
</div>
<p>
更多信息参考<a href="http://gradle.org/docs/current/userguide/multi_project_builds.html">http://gradle.org/docs/current/userguide/multi_project_builds.html</a>.
</p>
</div>
</div>
<div id="outline-container-sec-4-3" class="outline-3">
<h3 id="sec-4-3">库工程设置</h3>
<div class="outline-text-3" id="text-4-3">
<p>
在上一节中,":libraries:lib1"和":libraries:lib2"可以是java工程,":app"会
使用它们生成的jar包.
如果上面的库要使用android的API,应该将它们定义成Android库工程.
</p>
</div>
<div id="outline-container-sec-4-3-1" class="outline-4">
<h4 id="sec-4-3-1">创建Android库工程</h4>
<div class="outline-text-4" id="text-4-3-1">
<p>
创建一个android库工程需要使用一个不同的plugin.
</p>
<div class="org-src-container">

<pre class="src src-android">buildscript {
    repositories {
	mavenCentral()
    }

    dependencies {
	classpath 'com.android.tools.build:gradle:0.5.6'
    }
}

apply plugin: 'android-library'

android {
    compileSdkVersion 15
}
</pre>
</div>
</div>
</div>
<div id="outline-container-sec-4-3-2" class="outline-4">
<h4 id="sec-4-3-2">工程和库工程的区别</h4>
<div class="outline-text-4" id="text-4-3-2">
<p>
一个库工程会编译为"aar"(Android archive)包.该包整合了代码和资源.同时也可以在库工程中
编译测试APK来对库做测试.
</p>

<p>
其他的基本与正常的工程相同.
</p>
</div>
</div>
</div>
<div id="outline-container-sec-4-4" class="outline-3">
<h3 id="sec-4-4">引用库</h3>
<div class="outline-text-3" id="text-4-4">
<p>
库引用和其他的工程引用一样,需要在dependencies中添加 "compile project"即可.
</p>
</div>
<div id="outline-container-sec-4-4-1" class="outline-4">
<h4 id="sec-4-4-1">库发布</h4>
<div class="outline-text-4" id="text-4-4-1">
<p>
默认情况下,库只发布release版本,无论依赖该库的其他工程发布的是那个版本.
可以通过配置来控制发布那个版本:
</p>
<div class="org-src-container">

<pre class="src src-android">android {
    defaultPublishConfig "debug"
}
</pre>
</div>
<p>
需要注意的是配置名必须为全名,如果需要使用flavor,要写成"flavorDebug"的形式.
</p>

<p>
也可以通过配置来取消默认的发布.这样会导致生产所有版本的aar文件.
</p>
<div class="org-src-container">

<pre class="src src-android">android {
   publishNonDefault true
}
</pre>
</div>
</div>
</div>
</div>
</div>
<div id="outline-container-sec-5" class="outline-2">
<h2 id="sec-5">测试</h2>
<div class="outline-text-2" id="text-5">
<p>
Gradle插件在应用的工程中整合了测试工程.
</p>
</div>
<div id="outline-container-sec-5-1" class="outline-3">
<h3 id="sec-5-1">单元测试</h3>
<div class="outline-text-3" id="text-5-1">
<p>
在Android Studio1.1版本中引入了单元测试支持,不过目前还在试验阶段, 文档参考<a href="http://tools.android.com/tech-docs/unit-testing-support">http://tools.android.com/tech-docs/unit-testing-support</a>.
</p>
</div>
</div>
<div id="outline-container-sec-5-2" class="outline-3">
<h3 id="sec-5-2">基本配置</h3>
<div class="outline-text-3" id="text-5-2">
<p>
前面提到,在工程的src目录下一般包括main目录和androidTest目录.
该目录通过使用Android测试框架来生产可以安装在设备上的测试APK文件.
</p>

<p>
可以在测试目录下创建AndroidManifest.xml文件定义其他组件.
</p>

<p>
在build.gradle的android段中可以配置以下属性:
</p>
<div class="org-src-container">

<pre class="src src-android">android {
    defaultConfig {
	testPackageName "com.test.foo"
	testInstrumentationRunner "android.test.InstrumentationTestRunner"
	testHandleProfiling true
	testFunctionalTest true
    }
}
</pre>
</div>
<p>
targetPackage属性会自动被设置为test程序的package名称,即使通过defaultConfig或其他
编译选项进行配置.
</p>

<p>
另外,可以对test工程单独设置依赖,标签为"androidTestCompile". 
编译test工程使用"assembleTest"任务,该任务不是"assemble"任务的依赖.
目前默认情况下只有"debug编译类型"被测试.可以通过 "testBuildType name"来配置要测试的
编译类型.
</p>
</div>
</div>
<div id="outline-container-sec-5-3" class="outline-3">
<h3 id="sec-5-3"><span class="todo TODO">TODO</span> 运行测试</h3>
</div>
<div id="outline-container-sec-5-4" class="outline-3">
<h3 id="sec-5-4"><span class="todo TODO">TODO</span> 测试库</h3>
</div>
</div>
<div id="outline-container-sec-6" class="outline-2">
<h2 id="sec-6">编译变量</h2>
<div class="outline-text-2" id="text-6">
<p>
新编译系统的一个目标就是可以创建同一个程序的不同版本.
需要这么做的原因:
</p>
<ol class="org-ol">
<li>可能需要一个程序的不同版本:例如 免费/demo版 VS "专业"付费版.
</li>
<li>Google Play Store需要上传多个版本的APK文件,参考<a href="http://developer.android.com/google/play/publishing/multiple-apks.html">http://developer.android.com/google/play/publishing/multiple-apks.html</a>.
</li>
<li>同时需要做1和2.
</li>
</ol>

<p>
所以新版本的目标就是可以满足上述需要,能够使用一个工程生成不同APK.
而不是为了编译不同的APK创建多个工程.
</p>
</div>
<div id="outline-container-sec-6-1" class="outline-3">
<h3 id="sec-6-1">产品flavors</h3>
<div class="outline-text-3" id="text-6-1">
<p>
通过flavor可以客制化工程编译出来的产品.一个工程可以有多个flavor.
flavor这个概念通常用于改变非常小的场景.
</p>

<p>
使用DSL的 <b>productFlavor</b> 关键字来定义flavor.
</p>
<div class="org-src-container">

<pre class="src src-android">android {
    productFlavors {
	flavor1 {
	    ...
	}

	flavor2 {
	    ...
	}
    }
}
</pre>
</div>
<p>
上述代码创建了两个flavor: flavor1和flavor2.
记住flavor的名字不能与 <b>编译类型</b> 和 <b>androidTest的sourceSet</b> 混淆.
</p>
</div>
</div>
<div id="outline-container-sec-6-2" class="outline-3">
<h3 id="sec-6-2">编译变量=编译类型+产品flavor</h3>
<div class="outline-text-3" id="text-6-2">
<p>
前面讲过,每个编译类型都会生成一个APK.
Flavor可以完成同样的功能: 所以一个工程可以生成的APK是所有编译类型
和flavor的组合.每个组合被称作编译变量.
</p>

<p>
例如,前面定义的两个flavor,再加上系统默认的debug和release编译类型,可以生成
四种编译变量:
</p>
<ul class="org-ul">
<li>Flavor1-debug
</li>
<li>Flavor2-debug
</li>
<li>Flavor1-release
</li>
<li>Flavor2-release
</li>
</ul>
</div>
</div>
<div id="outline-container-sec-6-3" class="outline-3">
<h3 id="sec-6-3">Flavor配置</h3>
<div class="outline-text-3" id="text-6-3">
<p>
flavor的配置跟其他的配置一样,每个flavor都要用大括号括起来.
例如:
</p>
<div class="org-src-container">

<pre class="src src-android">android {
    ...

    defaultConfig {
	minSdkVersion 8
	versionCode 10
    }

    productFlavors {
	flavor1 {
	    packageName "com.example.flavor1"
	    versionCode 20
	}

	flavor2 {
	    packageName "com.example.flavor2"
	    minSdkVersion 14
	}
    }
}
</pre>
</div>
<p>
需要说明的是androd.productFlavors.*对象属于<a id="ProductFlavor" name="ProductFlavor"></a>类型,该类型
与前面提到的android.defaultConfig类型共享同样的属性.
所以每个flavor都可以重写<i>defaultConfig</i>提供的<a id="" name=""></a>配置.例如上面的代码最后创建了如
下两个flavor:
</p>
<ul class="org-ul">
<li>flavor1
<ul class="org-ul">
<li>packagName: com.example.flavor1
</li>
<li>minSdkVersion: 8
</li>
<li>versionCode: 20
</li>
</ul>
</li>
<li>flavor2
<ul class="org-ul">
<li>packageName: com.example.flavor2
</li>
<li>minSdkVersion: 14
</li>
<li>versionCode: 10
</li>
</ul>
</li>
</ul>
<p>
通常,编译类型的配置会和flavor的配置"合并', 例如在编译类型中配置了"packageNameSuffix",
那么最后生成的表名就等于flavor中配置的"packageName"加上该suffix.
</p>

<p>
对于编译类型和flavor都可以配置的属性, 要根据需求设置.例如signingConfig属性,如果
想要设置所有的release包使用同一个SigningConfig.可以设置 <b>android.buildTypes.release.signingConfig</b>,
或者为每个flavor单独设置该属性.
</p>
</div>
</div>
<div id="outline-container-sec-6-4" class="outline-3">
<h3 id="sec-6-4">资源集和依赖</h3>
<div class="outline-text-3" id="text-6-4">
<p>
和编译类型一样,Flavor同样也有自己的代码和资源目录.
例如上一节的例子创建出如下的资源集合:
</p>
<ul class="org-ul">
<li>android.sourceSets.flavor1
Location: src/flavor1
</li>
<li>android.sourceSets.flavor2
Location: src/flavor2
</li>
<li>android.sourceSets.androidTestFlavor1
Location: src/androidTestFlavor1
</li>
<li>android.sourceSets.androidTestFlavor2
Location: src/androidTestFlavor2
</li>
</ul>

<p>
这些资源集合与 <b>android.sourceSets.main+编译类型</b> 一起生成最后的APK文件.
这个过程会遵循如下规则:
</p>
<ol class="org-ol">
<li>使用所有的相关代码目录共同编译APK.
</li>
<li>所有的manifest文件被合并为一个文件.这使得flavors可以像编译类型一样,可以
有不同的组件和权限.
</li>
<li>资源使用"覆盖"策略,编译类型覆盖flavor, flavor覆盖main.
</li>
<li>每个编译变量都生成自己的R类. 编译变量之间不共享.
</li>
</ol>

<p>
同时,flavor也可以设置自己的依赖.例如,如果一个flavor版本需要生成一个有广告的版本
或一个收费版本,可以为该flavor设置依赖广告SDK.
</p>
<div class="org-src-container">

<pre class="src src-android">dependencies {
  flavor1Compile "..."
}
</pre>
</div>

<p>
每个编译变量都会生成相应的资源集合:
</p>
<ul class="org-ul">
<li>android.sourceSets.flavor1Debug
Location: src/flavor1Debug
</li>
<li>android.sourceSets.flavor2Debug
Location: src/flavor2Debug
</li>
</ul>
<p>
&#x2026;
这些目录的优先级要高于编译类型的优先级,并可以客制化.
</p>
</div>
</div>
<div id="outline-container-sec-6-5" class="outline-3">
<h3 id="sec-6-5">编译和任务</h3>
<div class="outline-text-3" id="text-6-5">
<p>
前面的内容说过,每个编译类型都有自己的 <b>assemble&lt;name&gt;</b> 任务,但是因为
编译变量是编译类型和flavor的组合.所以当使用flavor时,会有多个assemble类型
的任务被创建.它们是:
</p>
<ol class="org-ol">
<li>assemble&lt;编译变量&gt;
</li>
<li>assemble&lt;编译类型&gt;
</li>
<li>assemble&lt;Flavor&gt;
</li>
</ol>
<p>
使用可以生成一个APK. 使用2可以编译所有该编译类型的APK(例如flavorDebug和flavor2Debug).
使用3可以编译所有该flavor的APK(flavorDebug/flavorRelease).
</p>
</div>
</div>
<div id="outline-container-sec-6-6" class="outline-3">
<h3 id="sec-6-6">测试</h3>
<div class="outline-text-3" id="text-6-6">
<p>
测试多个flavor工程与测试单个工程和相似. 使用 <b>androidTest</b> 可以为所有的
flavor做一般测试.每个flavor还可以设置自己的测试.
</p>

<p>
每个flavor都会创建相应的资源集合:
</p>
<ul class="org-ul">
<li>android.sourceSets.androidTestFlavor1
Location: src/androidTestFlavor1
</li>
<li>android.sourceSets.androidTestFlavor2
Location: src/androidTestFlavor2
</li>
</ul>

<p>
同样, 它们可以配置相关的依赖:
</p>
<div class="org-src-container">

<pre class="src src-android">dependencies {
    androidTestFlavor1Compile "..."
}
</pre>
</div>

<p>
可以通过 <b>deviceCheck</b> 或 <b>androidTest</b> 任务来运行所有的测试任务.
每个flavor也有自己的测试任务 androidTest&lt;名称&gt;:
</p>
<ul class="org-ul">
<li>assembleFlavor1Test
</li>
<li>installFlavor1Debug
</li>
<li>installFlavor1Test
</li>
<li>uninstallFlavor1Debug
</li>
</ul>

<p>
任务完成生成的HTML结果支持flavor集合.测试结果的位子如下例所述,先是flavor版本,
然后是集合版本.可以对root目录(build)做客制化.
</p>
<ul class="org-ul">
<li>build/androidTest-results/flavors/&lt;FlavorName&gt;
</li>
<li>build/androidTest-results/all/
</li>
<li>build/reports/androidTests/flavors&lt;FlavorName&gt;
</li>
<li>build/reports/androidTests/all/
</li>
</ul>
</div>
</div>
<div id="outline-container-sec-6-7" class="outline-3">
<h3 id="sec-6-7"><span class="todo TODO">TODO</span> 多flavor变量</h3>
</div>
</div>
<div id="outline-container-sec-7" class="outline-2">
<h2 id="sec-7"><span class="todo TODO">TODO</span> 高级配置</h2>
</div>
