---
layout: post
title: \<The Roots of Lisp\> 阅读笔记
categories: [Lisp, Reading]
---

<p>
最近在阅读Paul Graham的Lisp相关系列文章,并做了一些笔记, 
原文章在这里可以找到: <a href="http://www.paulgraham.com/lisp.html">http://www.paulgraham.com/lisp.html</a>.
</p>

<p>
本文为 <a href="http://www.paulgraham.com/rootsoflisp.html">The Roots of Lisp</a> 的阅读笔记, 在这篇文章里, 
Paul Graham通过Common Lisp代码来讲解John McCarthy的Lisp论文,
通过对论文循序渐进的阐述, 来展现Lisp的魅力.
</p>

<p>
笔者对Common Lisp的语法并不熟悉, 故使用Elisp实验了本文中的
所有Common Lisp代码, Elisp跟Common Lisp的差异部分会标注出来.
</p>
<div id="outline-container-orgheadline3" class="outline-2">
<h2 id="orgheadline3">1. 基本概念和运算符</h2>
<div class="outline-text-2" id="text-orgheadline3">
</div><div id="outline-container-orgheadline1" class="outline-3">
<h3 id="orgheadline1">1.1 基本概念</h3>
<div class="outline-text-3" id="text-orgheadline1">
<p>
开始作者先定义了几个基本的概念:
</p>
<ul class="org-ul">
<li>atom: atom为一系列的字符, 例如foo.</li>
<li>表达式(expression): 表达式或者为一个atom, 或者为零个或多个
表达式的集合, 多个表达式之间用空格分开, 并用括号包住.
(这里使用了递归定义, 一个或多个表达式被称为list).</li>
</ul>
<p>
就像数学表达式 "1+1=2"一样, 这里定义的表达式同样可以表示一个值. 
</p>
</div>
</div>
<div id="outline-container-orgheadline2" class="outline-3">
<h3 id="orgheadline2">1.2 基本操作</h3>
<div class="outline-text-3" id="text-orgheadline2">
<p>
首先对list表达式进行了定义:
</p>
<blockquote>
<p>
即如果一个表达式为list(用括号包住),
那么把该list的第一个元素作为运算符, 剩下的元素作为运算符参数.
</p>
</blockquote>

<p>
基于上面的规则, 定义了最基本的7个操作符:
</p>
<ul class="org-ul">
<li>quote:
当第一个元素为quote时, 表达式的值为第二个参数. 即(quote x) = x.
quote只能接受一个参数.</li>
<li>atom: 
该操作符用来判断其参数是否为atom, 如果是返回"t"(表示真), 
否则返回"()"(表示假,在elisp中用"nil"表示假)</li>
<li>eq: 
判断两个参数是否相等. 相等的条件为两个参数为同一个atom或都为空列表.</li>
<li>car: 
返回参数的第一个元素, 参数必须为list</li>
<li>cdr: 
返回参数第一个元素后的元素, 参数必须为list.</li>
<li>cons:
接受两个参数, 第二个参数为list, 返回一个第一个参数和第二个参数合成的list.
(注: elisp上第二个参数也可以为atom).</li>
<li>cond:
cond可以接受多个参数, 形式为(cond (p1 e1) &#x2026; (pn en)), 
每个参数为一个list, cond会依次解析每个参数的
第一个元素, 如果其值为true, 然后该list的表达式返回对应的e表达式的值.</li>
</ul>

<p>
通过上述定义可以看到, 在Lisp中代码和数据的表示方式是一样的, 都是
通过list来表示, 那么如何对代码和数据进行区分呢, 答案就是quote.
由于quote返回其参数本身,所以用quote修饰的即可看做数据,否则即为代码
(即不用quote修饰的list, 其第一个元素为操作符). 例如:
</p>
<pre class="example">
(atom '(atom e)) =&gt; 值为false, 参数为一个list
(atom (atom e))  =&gt; 值为true, 参数会被认为是代码, 所以先解析参数表达式.
</pre>
</div>
</div>
</div>

<div id="outline-container-orgheadline4" class="outline-2">
<h2 id="orgheadline4">2. 函数定义</h2>
<div class="outline-text-2" id="text-orgheadline4">
<p>
这一节首先给出了函数的lambda定义, 其中p1-pn为atom参数, e为表达式.
如果一个表达式的第一个元素为lambda表达式, 则表示为函数调用.
a1-an会替换表达式中的p1-pn, 然后计算表达式的结果并返回.
</p>
<pre class="example">
;;函数定义
(lambda (p1...pn) e)

;;函数调用
((lambda (p1...pn) e) a1...an)
</pre>

<p>
根据上面的定义, 可以归纳出更一般的函数调用:
<b>如果表达式e的第一个元素是atom类型f, 且f不是<a href="#orgheadline3">基本概念和运算符</a>中定义的</b>
<b>基本运算符, 那么该元素f是一个函数,其形式为 (lambda (p1&#x2026;pn) e).</b>
</p>

<p>
基于上面的定义, 同样可以归纳出这个结论: 函数参数也可以为函数,
例如下面的表达式, 参数f也是一个lambda函数. 
注: 作者用的是common lisp版, 在elisp上需要使用funcall
函数, 见示例:
</p>
<pre class="example">
((lambda (f) (f '(b c))) '(lambda (x) (cons 'a x))) =&gt; common lisp
((lambda (f) (funcall f '(b c))) '(lambda (x) (cons 'a x))) =&gt; elisp
</pre>

<p>
该章节还解释了递归函数. 通过给函数命名, 可以实现函数的递归调用, 这个
跟基本的计算机理论中递归函数的定义是一样的.
</p>
</div>
</div>
<div id="outline-container-orgheadline5" class="outline-2">
<h2 id="orgheadline5">3. 基本函数</h2>
<div class="outline-text-2" id="text-orgheadline5">
<p>
前两节的内容给出了函数和基本操作符的一般形式, 
因此第三节定义了一些使用率非常频繁的基本函数, 
这些函数是由第一节定义了基本操作符组成的.
</p>
</div>
<div id="outline-container-orgheadline6" class="outline-3">
<h3 id="orgheadline6">cXr函数簇</h3>
<div class="outline-text-3" id="text-orgheadline6">
<p>
cXr不是一个函数, 而是一系列函数的缩写. X由
零个或多个a或b组成, 代表car和cdr.
例如 (cadr e) 表示 (car (cdr e)), 返回e的第二个元素.
(cadadr e) 表示 (car (cdr (car (cdr e)))).
</p>
</div>
</div>
<div id="outline-container-orgheadline7" class="outline-3">
<h3 id="orgheadline7">list函数</h3>
<div class="outline-text-3" id="text-orgheadline7">
<p>
还函数用于生成list, 其定义为 (list e1..en) = (cons e1 ..(cons en '())).
例如(list 'a 'b 'c) = (cons 'a (cons 'b (cons 'c '())))
</p>
</div>
</div>
<div id="outline-container-orgheadline8" class="outline-3">
<h3 id="orgheadline8">其他函数</h3>
<div class="outline-text-3" id="text-orgheadline8">
<ul class="org-ul">
<li>null. 判断参数是否为空list, 是返回true.</li>
<li>and. 判断两个参数是否都为true.</li>
<li>not. 判断参数是否返回false.</li>
<li>append. 连接两个参数, 参数必须为list.</li>
<li><p>
pair. 接受两个长度相等的list参数, 并交叉拼接在一个
</p>
<pre class="example">
(pair '(a b c) '(x y z)) ==&gt; ((x a) (y b) (z c))
</pre></li>
<li><p>
assoc 接受一个atom参数和pair生成的list参数.并查找
list中第一个元素为atom的元素.
</p>
<pre class="example">
(assoc 'x ((x a) (y b))) ==&gt; a
</pre></li>
</ul>
</div>
</div>
</div>
