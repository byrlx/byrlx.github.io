---
layout: post
title: Android项目使用Google Play Service
description: [Notes about how to use google play service]
tag: [Android, Google]
---

<div id="outline-container-sec-1" class="outline-2">
<h2 id="sec-1"><span class="section-number-2">1</span> 在 Android Studio 中使用 Google Play Service</h2>
<div class="outline-text-2" id="text-1">
<p>
在 Module 下的 build.gradle 的dependencies 中加入下面的代码.
</p>

<div class="org-src-container">

<pre class="src src-java">compile 'com.google.android.gms:play-services:6.5.87'
</pre>
</div>
</div>
</div>

<div id="outline-container-sec-2" class="outline-2">
<h2 id="sec-2"><span class="section-number-2">2</span> 解决引用 GMS 后函数数量超过65K 的问题.</h2>
<div class="outline-text-2" id="text-2">
<p>
由于整个 GMS 的包非常大,引用后非常容易导致整个应用程序的函数数量超过65K.
所以从 GMS6.5开始,可以有选择性的使用 <b>部分</b> API,要这样做, 将上一步中的
build.gradle 改成如下方式.
</p>


<div class="org-src-container">

<pre class="src src-java">compile 'com.google.android.gms:play-services-fitness:6.5.87'
compile 'com.google.android.gms:play-services-wearable:6.5.87'
</pre>
</div>

<p>
更多可以分类的 API 参考<a href="https://developer.android.com/google/play-services/setup.html#split">https://developer.android.com/google/play-services/setup.html#split</a>.
</p>
</div>
</div>
<div id="outline-container-sec-3" class="outline-2">
<h2 id="sec-3"><span class="section-number-2">3</span> GoogleApiClient</h2>
<div class="outline-text-2" id="text-3">
<p>
早期的 GMS, 不同的 API 有不同的 client. 在新版的 GMS 中,google 将所有 API
入口都整合到了 GoogleApiClient 中.
</p>

<p>
可以通过 GoogleApiClient.Builder()/build()方法以及 addApi()/addScope()来初始化一个
 GoogleApiClient 对象.同时应该实现相应的连接回调函数, 这样当你调用 GoogleApiClient.connect()来连接 GMS
 时,无论结果是成功/失败/暂停都会调用相应的回调函数.下面的代码是官方的示例:
</p>

<div class="org-src-container">

<pre class="src src-java">import gms.common.api.*;
import gms.drive.*;
import android.support.v4.app.FragmentActivity;

public class MyActivity extends FragmentActivity
	implements ConnectionCallbacks, OnConnectionFailedListener {
    private GoogleApiClient mGoogleApiClient;

    @Override
    protected void onCreate(Bundle savedInstanceState) {
	super.onCreate(savedInstanceState);

	// Create a GoogleApiClient instance
	mGoogleApiClient = new GoogleApiClient.Builder(this)
		.addApi(Drive.API)
		.addScope(Drive.SCOPE_FILE)
		.addConnectionCallbacks(this)
		.addOnConnectionFailedListener(this)
		.build();
	...
    }

    @Override
    public void onConnected(Bundle connectionHint) {
	// Connected to Google Play services!
	// The good stuff goes here.
    }

    @Override
    public void onConnectionSuspended(int cause) {
	// The connection has been interrupted.
	// Disable any UI components that depend on Google APIs
	// until onConnected() is called.
    }

    @Override
    public void onConnectionFailed(ConnectionResult result) {
	// This callback is important for handling errors that
	// may occur while attempting to connect with Google.
	//
	// More about this in the next section.
	...
    }
}
</pre>
</div>
</div>
</div>
<div id="outline-container-sec-4" class="outline-2">
<h2 id="sec-4"><span class="section-number-2">4</span> 处理错误</h2>
<div class="outline-text-2" id="text-4">
<p>
当调用 connect()函数去连接 GMS 时,有可能会失败,这种情况下会调用函数 onConnectionFailed().
并给出一个 ConnectionResult 类型的对象 result.
</p>

<p>
可以调用result 的 hasSolution()函数查看该错误是否可以 <b>解决</b>:
</p>
<ul class="org-ul">
<li>返回 true,表明该错误可解(e.g 登录).可以调用 result 的 startResolutionForResult()函数.
该函数会启动一个可以解决该问题的 Activity(e.g 登录界面).
</li>
<li>返回 false,该错误无法解决. 这时,可以调用 GooglePlayServiceUtil的 getErrorDialog()函数,
将 error code 穿给它. 可以显示该 dialog 给用户(该 dialog 可能只显示错误信息, 也可能会打开
相关的 activity(e.g 升级版本)).
</li>
</ul>

<p>
上面两种情况的函数调用完成都会触发 activity 的 onActivityResult()函数.
</p>
</div>

<div id="outline-container-sec-4-1" class="outline-3">
<h3 id="sec-4-1"><span class="section-number-3">4.1</span> 避免重复进行错误处理</h3>
<div class="outline-text-3" id="text-4-1">
<p>
官方文档还提及了错误处理的特殊情况: 假设你在 Activity 的 onStart()中去调用 connect()来连接
 GMS, 发生了连接失败. 这时候你旋转屏幕, activity 重启, 会再一次的调用 connect()去连接 GMS.
如果再次连接失败, 继续对失败做处理, 就出发生 <b>重复失败处理</b>. 这是不必要的.
</p>

<p>
可以通过设置一个 flag来监控当前是否正在进行错误处理.该 flag 可以在 onSavedInstance() 里存储. 
</p>
</div>
</div>
</div>
<div id="outline-container-sec-5" class="outline-2">
<h2 id="sec-5"><span class="section-number-2">5</span> 发送请求</h2>
<div class="outline-text-2" id="text-5">
<p>
基本方法: 构造一个 query对象, 然后调用相关 API 的 query()函数.
</p>

<div class="org-src-container">

<pre class="src src-java">Query query = new Query.Builder()
	.addFilter(Filters.eq(SearchableField.TITLE, filename));
PendingResult result = Drive.DriveApi.query(mGoogleApiClient, query);
</pre>
</div>
</div>

<div id="outline-container-sec-5-1" class="outline-3">
<h3 id="sec-5-1"><span class="section-number-3">5.1</span> 异步请求</h3>
<div class="outline-text-3" id="text-5-1">
<p>
对 query()函数返回的 PendingIntent 执行 setResultCall()函数.在该函数里
实现 ResultCallback()接口.
</p>
</div>
</div>
<div id="outline-container-sec-5-2" class="outline-3">
<h3 id="sec-5-2"><span class="section-number-3">5.2</span> 同步请求</h3>
<div class="outline-text-3" id="text-5-2">
<p>
对 PendingIntent 调用 await()函数知道请求完成. 不要在 UI 线程里做这件事.
</p>

<div class="org-src-container">

<pre class="src src-java">private class GetFileTask extends AsyncTask&lt;String, Void, Void&gt; {
    protected void doInBackground(String filename) {
	Query query = new Query.Builder()
		.addFilter(Filters.eq(SearchableField.TITLE, filename))
		.build();
	// Invoke the query synchronously
	DriveApi.MetadataBufferResult result =
		Drive.DriveApi.query(mGoogleApiClient, query).await();

	// Continue doing other stuff synchronously
	...
    }
}
</pre>
</div>
</div>
</div>
</div>
<div id="outline-container-sec-6" class="outline-2">
<h2 id="sec-6"><span class="section-number-2">6</span> Get ADID</h2>
<div class="outline-text-2" id="text-6">
<p>
对于安装 GMS 的手机来说, 可以通过 ADID 来唯一的标识一台手机.
ADID 是 GMS 中和广告相关的 ID.
 AdvertisingIdClient.Info getAdvertisingIdInfo
</p>
</div>
</div>
