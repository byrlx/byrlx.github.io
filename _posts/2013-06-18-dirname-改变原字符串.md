---
layout: post
title: dirname() 函数会修改原字符串
tag: [Tech]
description: [dirname() usage]
---

今天写一个创建目录的递归函数时一直不成功,每次递归传进去的参数都不是预期值. 
例如,我想创建目录 /a/b/c/d/e/f/g/, 系统中只有 /a/目录是存在的,因此需要递归
创建剩下的目录.
	
	int create_dir(char *whole_path)
	{
		if(!access(whole_path, F_OK))
			return;
	
		if(access(dirname(whole_path), F_OK) != 0){
			create_dir(dirname(whole_path));
		}
	
		if(mkdir(whole_path, 0700) != 0){
			printf("error:%s",strerror(errno));
			return 0;
		}
	
		return 1;
	}

结果一直不成功:只创建了目录a. 后来加入调试在函数开始出加了一个`printf("%s\n", whole_path)`,发现输出结果是这样的:
	
	(0)a/b/c/d/e/f/g/
	(1)a/b/c/d/e
	(2)a/b/c
	(3)a

每次调用递归传进来的参数都少了一个目录. 后来查dirname()的man, 发现这么一段话: 
> "Both dirname() and basename() may modify the contents of path, so it may be desirable to pass a copy when calling  one of these functions."

哈, 原来会改变原来的值, 修改后的代码试了下, 能正常运行

	int create_dir(char *whole_path)
	{
		char temp[255],temp2[255];
		if(!access(whole_path, NULL))
			return 0;
	
		strcpy(temp2, whole_path);
		strcpy(temp, dirname(temp2));
		if(access(temp) != 0){
			create_dir(temp);
		}

		if(mkdir(whole_path, 0700) != 0){
			return 0;
		}

		return 1;
	}

