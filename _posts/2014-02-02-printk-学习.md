---
layout: post
title: printk 学习
---

{{page.title}}
=====================

#### 概述

printk是linux kernel层的输出函数，相当与printf函数。用法：printk(LEVEL "msg"),
一般LEVEL和msg之间有一个空格。用printk输出的log可以通过“cat /proc/kmsg”或
“dmesg”命令查看。

	[    1.151187] ACPI: PCI Interrupt Link [LNKF] (IRQs 1 3 4 5 6 7 11 12 14 15) *10
	[    1.151240] ACPI: PCI Interrupt Link [LNKG] (IRQs 1 3 4 5 6 7 *10 12 14 15)
	[    1.151294] ACPI: PCI Interrupt Link [LNKH] (IRQs 1 3 4 5 6 7 11 12 14 15) *10
	[    1.151390] vgaarb: device added: PCI:0000:01:00.0,decodes=io+mem,owns=io+mem,locks=none
	[    1.151390] vgaarb: loaded
	[    1.151390] vgaarb: bridge control possible 0000:01:00.0
	[    1.151390] SCSI subsystem initialized
	[    1.151390] ACPI: bus type scsi registered

printk的LEVEL目前有8个（0～7），level的定义如下。其中KERN_EMERG最为严重，KERN_DEBUG级别最低。

	#define KERN_SOH    "\001"      /* ASCII Start Of Header */
	#define KERN_SOH_ASCII  '\001'
	
	#define KERN_EMERG  KERN_SOH "0"    /* system is unusable */
	#define KERN_ALERT  KERN_SOH "1"    /* action must be taken immediately */
	#define KERN_CRIT   KERN_SOH "2"    /* critical conditions */
	#define KERN_ERR    KERN_SOH "3"    /* error conditions */
	#define KERN_WARNING    KERN_SOH "4"    /* warning conditions */
	#define KERN_NOTICE KERN_SOH "5"    /* normal but significant condition */
	#define KERN_INFO   KERN_SOH "6"    /* informational */
	#define KERN_DEBUG  KERN_SOH "7"    /* debug-level messages */
	
	#define KERN_DEFAULT    KERN_SOH "d"    /* the default kernel loglevel */

#### printk流程

printk的简单流程是这样: 保存irq->格式化log字符串->处理log level->处理时间戳->将log插入buffer->如果需要,
将log送往console控制台->恢复irq. 

由于printk的log buffer是一个ring buffer,所以如果log量太多的话,也会导致覆盖现象. 同时,在插入的时候,也应该注意一条log横跨'buffer尾'和'buffer头'的现象. 

	static void emit_log_char(char c)
	{
	    LOG_BUF(log_end) = c;
        log_end++;
 		if (log_end - log_start > log_buf_len)
           log_start = log_end - log_buf_len;
        if (log_end - con_start > log_buf_len)
           con_start = log_end - log_buf_len;
        if (logged_chars < log_buf_len)
           logged_chars++;
	}

#### 读kernel log的流程

在linux环境下,读当前的kernel log可以通过打开/proc/kmsg文件或dmesg命令,这两种方式其实都调用到了do_syslog()函数. 该函数也位于kernel/prink.c文件. 在读kernel log时,因为该函数会修改log buffer的全局变量log_start,所以严格意义上讲"kernel log"只支持一个"读者", 即如果有多个程序读/proc/kmsg文件,那么这些程序会交叉修改log_start的值,导致每个程序读出的log内容是分散的.

      // do_syslog()                       
        case SYSLOG_ACTION_READ:        /* Read from log */
                error = -EINVAL;
                if (!buf || len < 0)
                        goto out;
                error = 0;
                if (!len)
                        goto out;
                if (!access_ok(VERIFY_WRITE, buf, len)) {
                        error = -EFAULT;
                        goto out;
                }
                error = wait_event_interruptible(log_wait,
                                                        (log_start - log_end));
                if (error)
                        goto out;
                i = 0;
                raw_spin_lock_irq(&logbuf_lock);
                while (!error && (log_start != log_end) && i < len) {
                        c = LOG_BUF(log_start);
                        log_start++;
                        raw_spin_unlock_irq(&logbuf_lock);
                        error = __put_user(c,buf);
                        buf++;
                        i++;
                        cond_resched();
                        raw_spin_lock_irq(&logbuf_lock);
                }
                raw_spin_unlock_irq(&logbuf_lock);
                if (!error)
                        error = i;
                break;

但是,有另一种读kernel log的方式,却能和读/proc/kmsg的程序同时存在. 这种方式就是通过console控制台读log. 之所以会这样,是因为在程序调用printk()打印log的时候,这条log在存入到log buffer的同时,也会直接输出到控制台.这个功能是在vprint()函数中实现的. 
    
    // vprint(), log就是在console_unlock()函数中被输出到console
    if (console_trylock_for_printk(this_cpu))
        console_unlock();
