---
layout: default
title: 一个有趣的bug
---

{{page.title}}
-------------------

##### 故事背景

在项目中，为了改良一个工具，有对android jelly bean版本的logger+liblog这块代码做二次加工。
其中有修改了system/core/include/cutils/logprint.h文件里的AndroidLogEntry这个结构体，
以及kernel/drivers/staging/android/logger.h
在其中添加了一个成员，如下所示。
{
	struct logger_entry {
		__u16		len;
		__u16		hdr_size;
		__s32		pid;
		__s32		tid;
		__s32		sec;
		__s32		my_modify; //这里是我添加的成员。
		__s32		nsec;
		kuid_t		euid;
		char		msg[0];
	};

	typedef struct AndroidLogEntry_t {
		time_t tv_sec;
		long tv_nsec;
		android_LogPriority priority;
		int32_t my_modify; //这里是我添加的成员。
		int32_t pid;
		int32_t tid;
		const char * tag;
		size_t messageLen;
		const char * message;
	} AndroidLogEntry;
}
后来Kitkat出来之后，就一股脑的把修改后的代码全都merge了过去。
结果build出来的版本一直报segmentfault。
后来我用diff比较了一下JB和KK从AP到kernel的相关代码，
完全是一样的，就觉得很奇怪为什么merge到KK上就不行了。

用gdb解析产生的core
dump文件，发现出问题的函数是liblog里的一个API。
{
	int android_log_processBinaryLogBuffer(struct logger_entry *buf,
			AndroidLogEntry *entry, const EventTagMap* map, char* messageBuf,
			int messageBufLen)
}
这个API的左右是把从kernel buffer里读出的一条log（用logger_entry表示）
转换为人类能读懂的log（用AndroidLogEntry表示）。传入的logger_entry是正确的，
但是转换出的AndroidLogEntry却发生了问题。从gdb里能看到，my_modify的值等于pid，
而pid等于tid...依次类推，tag变量指向了一个非法地址。
导致后面的代码在访问 entry->tag 时发生了问题。

为什么说这个bug有趣的呢？因为在KK上使用JB版本的log工具logcat，却能够正常运行，
而该工具也使用了同样的API及结构体，走了相同的解析流程。
而且，如果在logcat代码中该API后面人工造一个segment fault的话，
发现转换出来的AndroidLogEntry的成员也出现了相同的“偏移”，但是为什么logcat就没问题呢？
下面是logcat中的源码。
{
	if (dev->binary) {
		err = android_log_processBinaryLogBuffer(buf, &entry, g_eventTagMap,
				binaryMsgBuf, sizeof(binaryMsgBuf));
		//printf(">>> pri=%d len=%d msg='%s'\n",
		//    entry.priority, entry.messageLen, entry.message);
	} else {
		err = android_log_processLogBuffer(buf, &entry);
	}
	if (err < 0) {
		goto error;
	}

	if (android_log_shouldPrintLine(g_logformat, entry.tag, entry.priority)) {
		if (false && g_devCount > 1) {
			binaryMsgBuf[0] = dev->label;
			binaryMsgBuf[1] = ' ';
			bytesWritten = write(g_outFD, binaryMsgBuf, 2);
			if (bytesWritten < 0) {
				perror("output error");
				exit(-1);
			}
		}

		bytesWritten = android_log_printLogLine(g_logformat, g_outFD, &entry);

		if (bytesWritten < 0) {
			perror("output error");
			exit(-1);
		}
	}
}
可以看到在android_log_shouldPrintLine()函数中也使用了entry.tag当参数，根据上面的分析，
这个值是非法的，那为什么logcat没报错呢？

##### 为什么会有segment fault

在解释为什么logcat没报错之前，先来看下为什么会有segment fault发生。

原因很简单，在Kitkat版本上，liblog层使用的头文件有改动，
即在system/core/include下多了一个log目录。原先在system/core/include/cutils/下面相关的log
头文件logger.h/logprint.h/log.h/logd.h都移到了该目录下面。

而我们在从JB向KK的代码库做移植的时候，却把JB里cutils下面相关的头文件也移了过来，
这因为这样，我们的代码才没出现编译错误（否则，在刚开始编译就会因为找不到头文件报错），
结果就是，我们的代码使用的是cutils下面的结构体，而liblog使用的是log目录下的结构体。
就AndroidLogEntry来说，我们自己定义的变量并没有被改到log目录下logprint.h中。
{
	// system/core/include/log/logprint.h
	typedef struct AndroidLogEntry_t {
		time_t tv_sec;
		long tv_nsec;
		android_LogPriority priority;
		int32_t pid;
		int32_t tid;
		const char * tag;
		size_t messageLen;
		const char * message;
	} AndroidLogEntry;

	// system/core/include/cutils/logprint.h
	typedef struct AndroidLogEntry_t {
		time_t tv_sec;
		long tv_nsec;
		android_LogPriority priority;
		int32_t my_modify; //这里是我添加的成员。
		int32_t pid;
		int32_t tid;
		const char * tag;
		size_t messageLen;
		const char * message;
	} AndroidLogEntry;
}

