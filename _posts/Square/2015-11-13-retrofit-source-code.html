---
layout: post
title: Retrofit之源码解读 
tag: [Java, Android, Square]
description: [retrofit源码阅读笔记]
categories: [Square]
---

<p>
不了解Retrofit的人可以先参考这篇介绍文章<a href="http://xuzhengchao.com/2015/11/05/retrofit.html">Retrofit项目介绍</a>
</p>

<div id="outline-container-sec-1" class="outline-2">
<h2 id="sec-1">使用Retrofit的一般步骤.</h2>
<div class="outline-text-2" id="text-1">
<p>
在<a href="http://byrlx.github.io/2015-11/retrofit/">这篇</a> 文章里我们创建了一个最简单的Retrofit程序, 定义了一个用户GET请求的Service Client, 
并通过Retrofit来创建一个Client实例, 来实现具体的HTTP请求, 并将请求的结果转化为User对象.
所以一般来说, 使用retrofit的通常步骤为:
</p>
<ol class="org-ol">
<li>创建一个Retrofit实例.
</li>
<li>调用retrofit的create()函数创建一个接口的具体对象.
接口为用户自定义的HTTP接口类, 并将其作为参数传递给create().
</li>
<li>用2生成的对象调用其定义的http请求函数.该函数返回一个Call对象.
</li>
<li>执行上一步返回的call对象的execute().body()获取http结果, 该结果返回的是对象.
</li>
</ol>
</div>
</div>
<div id="outline-container-sec-2" class="outline-2">
<h2 id="sec-2">从示例代码入手追溯底层实现</h2>
<div class="outline-text-2" id="text-2">
</div><div id="outline-container-sec-2-1" class="outline-3">
<h3 id="sec-2-1">Retrofit类使用动态代理创建接口代理</h3>
<div class="outline-text-3" id="text-2-1">
<p>
Retrofit的一个超好用的特点就是高度封装性:我们只需定义一个抽象接口和一系列抽象的请求函数, 
retrofit就可以为我们生成一个该接口的具体类, 然后我们就可以用自己定义的接口函数实现具体的
Http请求, 而无需关心具体http的实现, 这些retrofit都帮我们做了. 下面看一下这个类的代码:
</p>
<ol class="org-ol">
<li>内部Builder类

<p>
Retrofit使用了Builder设计模式, 不能直接通过 "new Retrofit()" 来创建一个
retrofit对象, 而是需要调用其内部类Builder的build函数.
从下面的代码看(实现细节省略), 这是一个典型的Builder模式, Builder类内部定义和Retrofit相同的变量, 
并且其每一个setter()函数都会返回this. 最后通过build()函数new一个Retrofit
对象并返回.
</p>

<p>
<b>注</b>: 从代码中可以看到, 如果在builder中没有主动传入OkHttpClient的话,
Builder会创建一个默认的OkHttpClient.
</p>
<div class="org-src-container">

<pre class="src src-java">public static final class Builder {
  public Builder() {
    converterFactories.add(new BuiltInConverters());
  }

  public Builder client(OkHttpClient client) {...}
  public Builder baseUrl(String baseUrl) {...}
  ...
  public Builder addConverterFactory(Converter.Factory converterFactory) {}
  public Builder addCallAdapterFactory(CallAdapter.Factory factory) {}
  public Builder callbackExecutor(Executor callbackExecutor) {}
  public Builder validateEagerly() {}

  /** Create the {@link Retrofit} instances. */
  public Retrofit build() {
    if (baseUrl == null) {
      throw new IllegalStateException("Base URL required.");
    }

    OkHttpClient client = this.client;
    if (client == null) {
      client = new OkHttpClient();
    }

    // Make a defensive copy of the adapters and add the default Call adapter.
    List&lt;CallAdapter.Factory&gt; adapterFactories = new ArrayList&lt;&gt;(this.adapterFactories);
    adapterFactories.add(Platform.get().defaultCallAdapterFactory(callbackExecutor));

    // Make a defensive copy of the converters.
    List&lt;Converter.Factory&gt; converterFactories = new ArrayList&lt;&gt;(this.converterFactories);

    return new Retrofit(client, baseUrl, converterFactories, adapterFactories, callbackExecutor,
	validateEagerly);
  }
}
</pre>
</div>
</li>
<li>create()函数
该函数是Retrofit的 <b>精华</b>, 通过它, 我们可以将自定义的接口转化为一个具体的
该接口的对象.
<div class="org-src-container">

<pre class="src src-java">public &lt;T&gt; T create(final Class&lt;T&gt; service) {
  Utils.validateServiceInterface(service);
  if (validateEagerly) {
    eagerlyValidateMethods(service);
  }
  return (T) Proxy.newProxyInstance(service.getClassLoader(), new Class&lt;?&gt;[] { service },
      new InvocationHandler() {
	private final Platform platform = Platform.get();

	@Override public Object invoke(Object proxy, Method method, Object... args)
	    throws Throwable {
	  // If the method is a method from Object then defer to normal invocation.
	  if (method.getDeclaringClass() == Object.class) {
	    return method.invoke(this, args);
	  }
	  if (platform.isDefaultMethod(method)) {
	    return platform.invokeDefaultMethod(method, service, proxy, args);
	  }
	  return loadMethodHandler(method).invoke(args);
	}
      });
}
</pre>
</div>
<p>
上面的代码就是retrofit的实现, 代码比较短, 首先是调用validateServiceInterface()
来检查传入的类变量是否合法:
</p>
<pre class="example">
static &lt;T&gt; void validateServiceInterface(Class&lt;T&gt; service) {
  if (!service.isInterface()) {
    throw new IllegalArgumentException("API declarations must be interfaces.");
  }
  if (service.getInterfaces().length &gt; 0) {
    throw new IllegalArgumentException("API interfaces must not extend other interfaces.");
  }
}
</pre>
<p>
这里检查的地方有两个: 1, 传入的参数必须为一个interface类型. 2, 传入的参数
没有实现其他interface.
</p>

<p>
参数合法性检查完之后, 会条件性的执行eagerlyValidateMethods(), 这里先略过.
接下来是调用Proxy的newProxyInstance()函数为传入的参数生成动态代理. 
动态代理机制是Java的一个高级特性, 其主要功能就是可以为委托类对象生成代理类,
代理类可以将所有的方法调用分派到委托对象上反射执行. 动态代理的相关知识可参考
相关的Java书籍. 这里传入newProxyInstance()有三个参数: 1, 接口的classLoader. 2, 
只包含接口的class数组. 3, 自定义的InvocationHandler()对象, 该对象实现了invoke()
函数, 通常在该函数中实现对委托类函数的访问. 所以从create函数可以看出, *其实该函数
返回的是一个动态代理类对象(被转化成了我们自定义的接口), 当我们调用该接口的自定义
函数时, 我们调用的实际是invoke()函数.* 而要执行的方法被当作参数传给了invoke.
</p>

<p>
下面看下invoke()函数的具体实现:
</p>
<ul class="org-ul">
<li>判断要调用的方法是否是object类的方法(每个类都有), 如果是则直接在当前
类上调用.
</li>
<li>如果是平台的默认方法, 调用platform的相关函数(目前这段代码不会走到)
</li>
<li>否则, 调用loadMethodHandler()函数返回值的的invoke()方法实现函数调用.
这个方法就是retrofit替我们实现Http请求的地方.
</li>
</ul>
</li>
<li>loadMethodHandler()函数
<div class="org-src-container">

<pre class="src src-java">MethodHandler&lt;?&gt; loadMethodHandler(Method method) {
  MethodHandler&lt;?&gt; handler;
  synchronized (methodHandlerCache) {
    handler = methodHandlerCache.get(method);
    if (handler == null) {
      handler = MethodHandler.create(this, method);
      methodHandlerCache.put(method, handler);
    }
  }
  return handler;
}
</pre>
</div>
<p>
这个函数的实现比较简单, 就是从cache中寻找调用函数的MethodHandler, 如果找到就
返回, 否则创建一个新的返回. 下面就看下这个类的实现.
</p>
</li>
</ol>
</div>
</div>
<div id="outline-container-sec-2-2" class="outline-3">
<h3 id="sec-2-2">MethodHandler类实现接口函数调用</h3>
<div class="outline-text-3" id="text-2-2">
<p>
在上一小节说过, 我们通过retrofit.create()创造出一个自定义接口的实例,
然后调用实例方法实际上最后是对MethodHandler的invoke()函数的调用, 这一节
就具体看一下这个类及相关方法的具体实现.
</p>
<ol class="org-ol">
<li>对象创建.
<div class="org-src-container">

<pre class="src src-java">final class MethodHandler&lt;T&gt; {
  @SuppressWarnings("unchecked")
  static MethodHandler&lt;?&gt; create(Retrofit retrofit, Method method) {
    CallAdapter&lt;Object&gt; callAdapter = (CallAdapter&lt;Object&gt;) createCallAdapter(method, retrofit);
    Type responseType = callAdapter.responseType();
    Converter&lt;ResponseBody, Object&gt; responseConverter =
	(Converter&lt;ResponseBody, Object&gt;) createResponseConverter(method, retrofit, responseType);
    RequestFactory requestFactory = RequestFactoryParser.parse(method, responseType, retrofit);
    return new MethodHandler&lt;&gt;(retrofit, requestFactory, callAdapter, responseConverter);
  }
  ...
</pre>
</div>
<p>
该类的构造函数为私有函数, 所以只能通过静态函数create()来创造一个Methodhandler
对象.该函数首先基于mothod和retrofit创建一个CallAdapter的对象, 然后基于该对象
创建一个Converter对象, 接着生成一个RequestFactory对象, 然后把这些对象作为
参数传递给构造函数生成一个MethodHandler实例.
</p>
</li>
<li>创建CallAdapter实例
<div class="org-src-container">

<pre class="src src-java">private static CallAdapter&lt;?&gt; createCallAdapter(Method method, Retrofit retrofit) {
  Type returnType = method.getGenericReturnType();
  if (Utils.hasUnresolvableType(returnType)) {
    throw Utils.methodError(method,
	"Method return type must not include a type variable or wildcard: %s", returnType);
  }
  if (returnType == void.class) {
    throw Utils.methodError(method, "Service methods cannot return void.");
  }
  Annotation[] annotations = method.getAnnotations();
  try {
    return retrofit.callAdapter(returnType, annotations);
  } catch (RuntimeException e) { // Wide exception range because factories are user code.
    throw Utils.methodError(e, method, "Unable to create call adapter for %s", returnType);
  }
}
</pre>
</div>
<p>
首先调用method的getGenericReturnType()获取该函数的返回类型, 如果该类型不能
被解析或为void, 报错. 然后通过getAnnotations()函数获取我们在定义函数时使用的注解(GET/POST..)
最后基于返回值和注解调用retrofit的callAdapter()生成对象.
</p>
<div class="org-src-container">

<pre class="src src-java">//retrofit.java
public CallAdapter&lt;?&gt; callAdapter(Type returnType, Annotation[] annotations) {
   return nextCallAdapter(null, returnType, annotations);
 }

 public CallAdapter&lt;?&gt; nextCallAdapter(CallAdapter.Factory skipPast, Type returnType,
     Annotation[] annotations) {
   checkNotNull(returnType, "returnType == null");
   checkNotNull(annotations, "annotations == null");

   int start = adapterFactories.indexOf(skipPast) + 1;
   for (int i = start, count = adapterFactories.size(); i &lt; count; i++) {
     CallAdapter&lt;?&gt; adapter = adapterFactories.get(i).get(returnType, annotations, this);
     if (adapter != null) {
       return adapter;
     }
   }
    ....
 }
</pre>
</div>
<p>
callAdapter函数就是从retrofit的adapterFactories变量中找到与该函数和返回值相关的
adapter, 如果找不到则报错. 从前面Retrofit的builder代码可以看到, 如果用户没用显示声明
Adapter的话, 默认会创建一个defaultAdapterFactory的实例加入到adapterFactories中.
</p>
</li>
<li>invoke()函数
invoke()函数是MethodHandler/对象/的唯一函数, 该函数实际是调用了callAdapter.adapt()
函数, 该函数的参数为一个OkHttpCall对象, 从这里就可以看成该函数是Http请求的
实际函数, 后面在看CallAdapter代码会再详细介绍其功能.
<div class="org-src-container">

<pre class="src src-java">Object invoke(Object... args) {
  return callAdapter.adapt(new OkHttpCall&lt;&gt;(retrofit, requestFactory, responseConverter, args));
}
</pre>
</div>
</li>
</ol>
</div>
</div>

<div id="outline-container-sec-2-3" class="outline-3">
<h3 id="sec-2-3">CallAdapter和DefaultCallAdapter</h3>
<div class="outline-text-3" id="text-2-3">
<p>
前面的小节讲过, 当我们在程序中定义了一个retrofit接口, 然后通过retrofit.create()
生成一个实例, 并调用该实例的函数时, 会得到一个Call类型的返回值(因此用户自定义的
接口中的函数返回值应该都为Call类型). 对实例函数的调用最终是调用到了retrofit的
callAdapter的adapt()函数. 这个函数(返回Call)是在DefaultCallAdapter中实现的.
</p>
<ol class="org-ol">
<li>DefaultCallAdapter
<div class="org-src-container">

<pre class="src src-java">final class DefaultCallAdapter implements CallAdapter&lt;Call&lt;?&gt;&gt; {
  static final Factory FACTORY = new Factory() {
    @Override
    public CallAdapter&lt;?&gt; get(Type returnType, Annotation[] annotations, Retrofit retrofit) {
      if (Utils.getRawType(returnType) != Call.class) {
	return null;
      }
      Type responseType = Utils.getCallResponseType(returnType);
      return new DefaultCallAdapter(responseType);
    }
  };

  private final Type responseType;

  DefaultCallAdapter(Type responseType) {
    this.responseType = responseType;
  }

  @Override public Type responseType() {
    return responseType;
  }

  @Override public &lt;R&gt; Call&lt;R&gt; adapt(Call&lt;R&gt; call) {
    return call;
  }
}
</pre>
</div>
<p>
可以看到adapt()函数返回了一个Call类型的结果, 跟我们在例子中定义的一样.
DefaultCallAdapter的父类是CallAdapter. 所以如果要实现自己的Adapter, 同样
需要继承此类.
</p>
</li>
</ol>
</div>
</div>
<div id="outline-container-sec-2-4" class="outline-3">
<h3 id="sec-2-4">Call和OkHttpCall 实现真正请求</h3>
<div class="outline-text-3" id="text-2-4">
<p>
在MethodHandler一节可以看到invoke中调用adapt()函数时传入了一个OkHttpCall类型, 
所以实例中用户调用自定义函数返回的也是一个OkHttpCall类型的结果.
</p>

<ol class="org-ol">
<li>Call接口定义.
Call是retrofit定义的一个接口规范, 该类主要用于进行Http请求.
代码注释阐明了该接口的几个功能和约束:
<ul class="org-ul">
<li>使用execute()进行同步调用.
</li>
<li>使用enqueue()进行异步调用.
</li>
<li>无论同步还是异步, 都可以在任何时候使用cancel取消.
</li>
<li>使用clone()进行一个功能的多次请求.(例如失败后的轮询).
</li>
</ul>
<div class="org-src-container">

<pre class="src src-java">public interface Call&lt;T&gt; extends Cloneable {
  Response&lt;T&gt; execute() throws IOException;
  void enqueue(Callback&lt;T&gt; callback);
  void cancel();
  Call&lt;T&gt; clone();
}
</pre>
</div>
</li>
<li>OkHttpCall.    
OkHttpCall是基于OkHttp的Call接口的一个实现, 可以通过这个类看一下具体它是怎样
遵循Call接口的规范的. 下面是其几个主要函数的实现:
<ul class="org-ul">
<li>execute().
<div class="org-src-container">

<pre class="src src-java">public Response&lt;T&gt; execute() throws IOException {
  synchronized (this) {
    if (executed) throw new IllegalStateException("Already executed");
    executed = true;
  }

  com.squareup.okhttp.Call rawCall = createRawCall();
  if (canceled) {
    rawCall.cancel();
  }
  this.rawCall = rawCall;

  return parseResponse(rawCall.execute());
}
</pre>
</div>
<p>
前面讲过该函数是Call的同步请求函数, 直接返回请求结果. 从代码中可以看出.
由于executed变量被设为true后其值一直不变, 所以execute的"请求"代码只会
执行一次. 该函数使用了OkHttp的Call类来执行具体的执行动作. 最后调用
parseResponse()处理请求结果.
</p>
</li>
<li>enqueue().
该函数是Call的异步请求函数, 需要向该函数传递一个Callback类型的参数.Callback是一个
接口, 提供了两个函数onResponse()表示成功, onFailure()表示失败.
在Android中,这两个函数需要在UI线程中执行.
<div class="org-src-container">

<pre class="src src-java">public interface Callback&lt;T&gt; {
  /** Successful HTTP response. */
  void onResponse(Response&lt;T&gt; response, Retrofit retrofit);

  /** Invoked when a network or unexpected exception occurred during the HTTP request. */
  void onFailure(Throwable t);
}
</pre>
</div>

<p>
在enqueue()中创建了一个com.squareup.okhttp.Call实例,
http请求动作实际是这个实例的enqueue()函数来执行的.
</p>
<div class="org-src-container">

<pre class="src src-java">@Override public void enqueue(final Callback&lt;T&gt; callback) {
    synchronized (this) {
      if (executed) throw new IllegalStateException("Already executed");
      executed = true;
    }

    com.squareup.okhttp.Call rawCall;
    try {
      rawCall = createRawCall();
    } catch (Throwable t) {
      callback.onFailure(t);
      return;
    }
    ...
    rawCall.enqueue(new com.squareup.okhttp.Callback() {
      private void callFailure(Throwable e) {
	try {
	  callback.onFailure(e);
	} catch (Throwable t) {
	  t.printStackTrace();
	}
      }

      private void callSuccess(Response&lt;T&gt; response) {
	try {
	  callback.onResponse(response, retrofit);
	} catch (Throwable t) {
	  t.printStackTrace();
	}
      }

      @Override public void onFailure(Request request, IOException e) {
	callFailure(e);
      }

      @Override public void onResponse(com.squareup.okhttp.Response rawResponse) {
	Response&lt;T&gt; response;
	try {
	  response = parseResponse(rawResponse);
	} catch (Throwable e) {
	  callFailure(e);
	  return;
	}
	callSuccess(response);
      }
    });
}
</pre>
</div>
</li>
<li>cancel(). 
取消请求, 实际是调用com.squareup.okhttp.Call的cancel()函数.
</li>
<li>clone().
由于一个对象只能执行一次请求, 所以同一请求的多次执行, 需要通过clone()来
复制, 该函数实际上是创建了一个新的OkHttpCall对象.
</li>
<li>parseResponse().
该函数用来将execute()或enqueue()返回的结果转换为一个Response对象并返回, 前面讲到
实际的请求是由OkHttp完成的, OkHttp请求也是返回一个com.squareup.okhttp.Response的对象, 
这个函数就是将该对象转换为一个retrofit的Response对象.

<p>
看一下这个函数的代码. 首先调用response的body()函数获取一个ResponseBody类型,
然后基于response的contentType和length生成一个新的rawResponse. 
</p>
<div class="org-src-container">

<pre class="src src-java"> ResponseBody rawBody = rawResponse.body();

// Remove the body's source (the only stateful object) so we can pass the response along.
rawResponse = rawResponse.newBuilder()
    .body(new NoContentResponseBody(rawBody.contentType(), rawBody.contentLength()))
    .build();

int code = rawResponse.code();
if (code &lt; 200 || code &gt;= 300) {
  try {
    // Buffer the entire body to avoid future I/O.
    ResponseBody bufferedBody = Utils.readBodyToBytesIfNecessary(rawBody);
    return Response.error(bufferedBody, rawResponse);
  } finally {
    closeQuietly(rawBody);
  }
}
</pre>
</div>

<p>
接着处理"错误"返回和无内容的成功返回. 对于小于200或大于300的"错误码", 会先
尝试生成一个errBody, 然后返回一个"携带错误内容"的Response. 204或205的状态码
表示请求成功但无返回内容, 会简单调用success函数返回一个成功的Response.
Response是retrofit的请求结果类, 后面会介绍.
</p>
<div class="org-src-container">

<pre class="src src-java">    int code = rawResponse.code();
    if (code &lt; 200 || code &gt;= 300) {
      try {
	// Buffer the entire body to avoid future I/O.
	ResponseBody bufferedBody = Utils.readBodyToBytesIfNecessary(rawBody);
	return Response.error(bufferedBody, rawResponse);
      } finally {
	closeQuietly(rawBody);
      }
    }

    if (code == 204 || code == 205) {
      return Response.success(null, rawResponse);
    }

//error和success的代码
  public static &lt;T&gt; Response&lt;T&gt; success(T body, com.squareup.okhttp.Response rawResponse) {
    return new Response&lt;&gt;(rawResponse, body, null);
  }

  public static &lt;T&gt; Response&lt;T&gt; error(ResponseBody body, com.squareup.okhttp.Response rawResponse) {
    return new Response&lt;&gt;(rawResponse, null, body);
  }
</pre>
</div>

<p>
如果状态码不在这两个范围, 则尝试处理body并将其转化为最终我们需要的类型.
代码中的responseConverter就是我们在示例中构建retrofit时通过调用
addConverterFactory()传入的converter. 
所以如果我们传回的结果为一个类的json表示, 就可以通过这个函数传入一个GsonConverter.
它就会自动将返回内容转换为结果类型对象并存放到Response的body中.
我们直接调用body()函数就可有获得这个结果.
</p>
<div class="org-src-container">

<pre class="src src-java">ExceptionCatchingRequestBody catchingBody = new ExceptionCatchingRequestBody(rawBody);
try {
  T body = responseConverter.convert(catchingBody);
  return Response.success(body, rawResponse);
} catch (RuntimeException e) {
  catchingBody.throwIfCaught();
  throw e;
}
</pre>
</div>
</li>
</ul>
</li>
</ol>
</div>
</div>
<div id="outline-container-sec-2-5" class="outline-3">
<h3 id="sec-2-5">Request相关类处理请求</h3>
<div class="outline-text-3" id="text-2-5">
<p>
在retrofit示例中讲到,使用retrofit一般首先要定义了一个接口,
并在接口里用retrofit提供的注解定义了一系列请求函数. 下面的
代码展示一个基本的接口和函数定义, 通过注解可以看出, 该函数
是一个POST请求, 并使用了表单, 定义了属性user和pass,
这两个属性的值通过函数参数传进来. 
</p>
<div class="org-src-container">

<pre class="src src-java">public interface CHHttpService {
    @FormUrlEncoded
    @POST("/p/checkState.do")
    Call&lt;CHIMEI&gt;  checkState(@Field("user") String user, @Field("pass") String pass);
}
</pre>
</div>

<p>
这一部分的内容就是讲解retrofit如何通过解析注解来生成一个完整的
OkHttp请求(request). 这一切的入口就是MethodHandler的create()函数中的
一行代码. 
</p>
<pre class="example">
static MethodHandler&lt;?&gt; create(Retrofit retrofit, Method method) {
  ...
  RequestFactory requestFactory = RequestFactoryParser.parse(method, responseType, retrofit);  //&lt;====here
  return new MethodHandler&lt;&gt;(retrofit, requestFactory, callAdapter, responseConverter);
}
</pre>
</div>

<div id="outline-container-sec-2-5-1" class="outline-4">
<h4 id="sec-2-5-1">RequestFactoryParser &amp; RequestFactory</h4>
<div class="outline-text-4" id="text-2-5-1">
<p>
在MethodHandler的create()函数中调用RequestFactoryParser的parse()函数
生成了一个RequestFactory实例, 下面看下这个函数的主要功能.
</p>
<div class="org-src-container">

<pre class="src src-java">static RequestFactory parse(Method method, Type responseType, Retrofit retrofit) {
  RequestFactoryParser parser = new RequestFactoryParser(method);
  parser.parseMethodAnnotations(responseType);
  parser.parseParameters(retrofit);
  return parser.toRequestFactory(retrofit.baseUrl());
}
</pre>
</div>
<p>
该函数先创建一个RequestFactoryParser的实例, 然后调用parseMethodAnnotations()
和parseParameters()两个函数, 从这两个函数的名称上可以看出它们的功能,分别是
处理*接口函数*的注解和参数的注解.最后调用toRequestFactory()生成一个
RequestFactory实例返回. 下面是这两个函数的实现:
</p>
<ul class="org-ul">
<li>parseMethodAnnotations().
该函数通过Method类的getAnnotations()函数返回要解析的函数的所有注解, 然后
遍历这些注解. 大部分请求相关的注解都调用了parseHttpMethodAndPath()这个函数
<b>Headers</b> 注解调用了parseHeaders()函数. 其他的注解则设置了相关的标志位.
<div class="org-src-container">

<pre class="src src-java"> private void parseMethodAnnotations(Type responseType) {
  for (Annotation annotation : method.getAnnotations()) {
    if (annotation instanceof POST) { //同样适用于GET/DELET/HEAD/PATCH/, 第三个参数可能不同
      parseHttpMethodAndPath("POST", ((POST) annotation).value(), true);
    } else if (annotation instanceof Headers) {
      String[] headersToParse = ((Headers) annotation).value();
      if (headersToParse.length == 0) {throw methodError(method, "@Headers annotation is empty.");}
      headers = parseHeaders(headersToParse);
    } else if (annotation instanceof Multipart) {
      if (isFormEncoded) {throw methodError(method, "Only one encoding annotation is allowed.");}
      isMultipart = true;
    } else if (annotation instanceof FormUrlEncoded) {
      if (isMultipart) {throw methodError(method, "Only one encoding annotation is allowed.");}
      isFormEncoded = true;
    }
  }
  ...
}
</pre>
</div>
</li>
<li>parseParameters
该函数先调用Method的函数geGenericParameterTypes()获取每个参数的类型, 然后
调用getParameterAnnotations()获取每个参数的注解.然后解析每个注解, 并将解析的
结果存放到requestBuilderActions变量中.
</li>
</ul>
</div>
</div>
<div id="outline-container-sec-2-5-2" class="outline-4">
<h4 id="sec-2-5-2">RequestBuilder &amp; RequestBuilderAction</h4>
<div class="outline-text-4" id="text-2-5-2">
<p>
在OkHttpCall类中, 创建一个OkHttp的call实例会传入一个OkHttp的
Request的参数, 这个Request变量是通过调用ReqeustFactory的create()
函数生成的. create()函数首先通过已经处理完成的所有请求参数生成一个
RequestBuilder实例, 然后再进一步处理上一部分还未完成的参数处理, 即
将参数和注解结果结合起来.这个是通过调用RequestBuilderAction的perform()
函数完成的.
</p>
<div class="org-src-container">

<pre class="src src-java">public Response&lt;T&gt; execute() throws IOException {
  com.squareup.okhttp.Call rawCall = createRawCall();
  return parseResponse(rawCall.execute());
}
private com.squareup.okhttp.Call createRawCall() {
  return retrofit.client().newCall(requestFactory.create(args));
}

Request create(Object... args) {
  RequestBuilder requestBuilder =
      new RequestBuilder(method, baseUrl.url(), relativeUrl, headers, contentType, hasBody,
	  isFormEncoded, isMultipart);

  if (args != null) {
    RequestBuilderAction[] actions = requestBuilderActions;
    if (actions.length != args.length) {throw new IllegalArgumentException("Argument count (" + args.length + ") doesn't match action count (" + actions.length + ")");}
    for (int i = 0, count = args.length; i &lt; count; i++) {
      actions[i].perform(requestBuilder, args[i]);
    }
  }
  return requestBuilder.build();
}
</pre>
</div>
</div>
</div>
</div>
<div id="outline-container-sec-2-6" class="outline-3">
<h3 id="sec-2-6">Response处理返回结果</h3>
<div class="outline-text-3" id="text-2-6">
<p>
Response是execute和enqueue函数的返回值, Reponse的实现思想是:
如果请求成功并有结果返回, 则尝试将结果转化为最终的类, 
否则保存OkHttp请求的返回结果(rawResponse)并交给使用者处理.
Response的实现比较简单, 只有100行代码, 主要的两个函数为success()和
error(), 这两个函数会生成一个包含请求结果的Response对象, 然后是一系列
的getter()函数, 用来获取请求结果(头, 状态码, body等&#x2026;).
</p>
<div class="org-src-container">

<pre class="src src-java">public final class Response&lt;T&gt; {
  private final com.squareup.okhttp.Response rawResponse;
  private final T body;
  private final ResponseBody errorBody;
  private Response(com.squareup.okhttp.Response rawResponse, T body, ResponseBody errorBody) { ... }

  public static &lt;T&gt; Response&lt;T&gt; success(T body, com.squareup.okhttp.Response rawResponse) {return new Response&lt;&gt;(rawResponse, body, null);}
  public static &lt;T&gt; Response&lt;T&gt; error(ResponseBody body, com.squareup.okhttp.Response rawResponse) {return new Response&lt;&gt;(rawResponse, null, body);}

  public com.squareup.okhttp.Response raw() {return rawResponse;}
  public int code() {return rawResponse.code();}
  public String message() {return rawResponse.message();}
  public Headers headers() {return rawResponse.headers();}
  public boolean isSuccess() {return rawResponse.isSuccessful();}
  public T body() {return body;}
  public ResponseBody errorBody() {return errorBody;}
}
</pre>
</div>
</div>
</div>
</div>
