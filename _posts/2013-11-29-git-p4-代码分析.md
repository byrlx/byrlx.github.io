---
layout: default
title: git-p4 代码分析
---

{{page.title}}
-------------------------

公司的代码管理一直使用perforce，一款商业软件。因为一直在学习用git，所以就像可不可以通过git来管理perforce的代码库，然后就找到了git-p4这款软件，果然是只有你想不到，没有git社区做不到。

在前一篇文档中已经介绍了怎样用git来管理perforce服务器的代码。这篇文章通过分析git-p4的代码来深入学习这款软件的原理。
git-p4的代码是用python实现的。

#### git p4 submit 流程

在本地修改完文件后，要把本地的git commit提交到perforce服务器，使用git p4 submit, 通常情况下，会弹出一个文本编辑器，让用户编辑要提交的内容，编辑完成后,该命令就成功提交了该次修改的内容。这边通过代码分析整个的submit流程。

不过，在那之前，先从main()函数开始看起，这是任何程序都无法逾越的“鸿沟”。

	def main():
	    if len(sys.argv[1:]) == 0:
	        printUsage(commands.keys())
	        sys.exit(2)
	
	    cmdName = sys.argv[1]
	    try:
	        klass = commands[cmdName]
	        cmd = klass()
	    except KeyError:
	        print "unknown command %s" % cmdName
	        print ""
	        printUsage(commands.keys())

这部分代码检查参数的合法行，这里传入了submit，得到commands这个字典中查找是否存在这个key。commands中的每个key都对应一个class，如果传入的key存在，会生成一个相应class的对象。commands的定义如下：

	commands = {
	    "debug" : P4Debug,
	    "submit" : P4Submit,
	    "commit" : P4Submit,
	    "sync" : P4Sync,
	    "rebase" : P4Rebase,
	    "clone" : P4Clone,
	    "rollback" : P4RollBack,
	    "branches" : P4Branches
	}

后面是使用optparse设置添加一些选项。先略过，接着看main()下面的内容。

    if cmd.needsGit:
        if cmd.gitdir == None:
            cmd.gitdir = os.path.abspath(".git")
            if not isValidGitDir(cmd.gitdir):
                cmd.gitdir = read_pipe("git rev-parse --git-dir").strip()
                if os.path.exists(cmd.gitdir):
                    cdup = read_pipe("git rev-parse --show-cdup").strip()
                    if len(cdup) > 0:
                        chdir(cdup);

        if not isValidGitDir(cmd.gitdir):
            if isValidGitDir(cmd.gitdir + "/.git"):
                cmd.gitdir += "/.git"
            else:
                die("fatal: cannot locate git repository at %s" % cmd.gitdir)

        os.environ["GIT_DIR"] = cmd.gitdir
        
上面的代码用来设置系统的GIT_DIR环境，因为P4Submit这个类继承自Command类，而父类中needsGit 默认色true，
所以上面的代码会执行到。并首先假设".git"目录就在当前工作目录下，所以会cmd.gitdir最初被赋值为当前目录后面加上".git".
然后通过isValidGitDir()函数检查这个“假设”的目录是否正确，如果在子目录下，这个值就是非法的。系统会执行"git rev-parse --git-dir"获得正确的".git"路径。然后通过执行 'git rev-parse --show-cdup' 得到'.git'跟当前目录的相对路径.
并调用chdir()切换到该路径，最后设置GIT_DIR变量。到这里，预备工作就做完了，接下来就要进入“正题”了。

从run()函数开始执行submit流程。

	def run(self, args):
		if len(args) == 0:
			self.master = currentGitBranch()
			if len(self.master) == 0 or not gitBranchExists("refs/heads/%s" % self.master):
				die("Detecting current git branch failed!")
		elif len(args) == 1:
			self.master = args[0]
			if not branchExists(self.master):
				die("Branch %s does not exist" % self.master)
		else:
			return False
	
函数首先看是否有参数传入，如果没有，使用当前git目录下的master作为提交的branch。否则，使用参数作为提交的branch。所以，
可以使用git p4 submit branchname 的方式提交指定的branch。继续走。

	[upstream, settings] = findUpstreamBranchPoint() #run()
	
	def findUpstreamBranchPoint(head = "HEAD"):
		branches = p4BranchesInGit()
		# map from depot-path to branch name
		branchByDepotPath = {}
		for branch in branches.keys():
			tip = branches[branch]
			log = extractLogMessageFromGitCommit(tip)
			settings = extractSettingsGitLog(log)
			if settings.has_key("depot-paths"):
				paths = ",".join(settings["depot-paths"])
				branchByDepotPath[paths] = "remotes/p4/" + branch

该函数会查找该git目录下的代码对应的perforce上代码位置，通过执行"git rev-parse --symbolic --remotes"可以得到相关的p4 remote branch的内容，以”p4/”开头，我们要找的则是"p4/master", 通过"git rev-parse p4/master"可以获得该ref对应的commit id并返回。
这就是p4BranchesInGit()函数做的工作。在获得这个commit id之后，通过函数extractLogMessageFromGitCommit(id)获得该commit对应的log信息(该函数执行 git cat-file commit id 命令), 一般来说，该log信息中会包含相应的perforce目录的信息。
而extractSettingsGitLog(log)则是从log中解析出这个目录值。
这个目录的值就是上面的函数要返回的内容。
