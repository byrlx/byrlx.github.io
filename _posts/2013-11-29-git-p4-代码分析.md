---
layout: default
title: git-p4 代码分析
---

{{page.title}}
-------------------------

在[前一篇](http://byrlx.github.io/2013/11/30/%E4%BD%BF%E7%94%A8git%E7%AE%A1%E7%90%86perforce.html)文档中已经介绍了怎样用git来管理perforce服务器的代码。这篇文章通过分析git-p4的代码来深入学习这款软件的原理。
git-p4的代码是用python实现的。

#### 实验环境

p4上代码位置为 "//AB/C/D/", 映射到本地目录为 "~/p4local/AB/C/D/", git p4 clone的代码位置为 "~/gitp4/test/"

	git p4 clone //AB/C/D...@all ~/gitp4/test

#### git p4 submit 流程

在本地修改完文件后，要把本地的git commit提交到perforce服务器，使用git p4 submit, 通常情况下，会弹出一个文本编辑器，让用户编辑要提交的内容，编辑完成后,该命令就成功提交了该次修改的内容。这边通过代码分析整个的submit流程。

不过，在那之前，先从main()函数开始看起，这是任何程序都无法逾越的“鸿沟”。

	def main():
	    if len(sys.argv[1:]) == 0:
	        printUsage(commands.keys())
	        sys.exit(2)
	
	    cmdName = sys.argv[1]
	    try:
	        klass = commands[cmdName]
	        cmd = klass()
	    except KeyError:
	        print "unknown command %s" % cmdName
	        print ""
	        printUsage(commands.keys())

这部分代码检查参数的合法行，这里传入了submit，得到commands这个字典中查找是否存在这个key。commands中的每个key都对应一个class，如果传入的key存在，会生成一个相应class的对象。commands的定义如下：

	commands = {
	    "debug" : P4Debug,
	    "submit" : P4Submit,
	    "commit" : P4Submit,
	    "sync" : P4Sync,
	    "rebase" : P4Rebase,
	    "clone" : P4Clone,
	    "rollback" : P4RollBack,
	    "branches" : P4Branches
	}

后面是使用optparse设置添加一些选项。先略过，接着看main()下面的内容。

    if cmd.needsGit:
        if cmd.gitdir == None:
            cmd.gitdir = os.path.abspath(".git")
            if not isValidGitDir(cmd.gitdir):
                cmd.gitdir = read_pipe("git rev-parse --git-dir").strip()
                if os.path.exists(cmd.gitdir):
                    cdup = read_pipe("git rev-parse --show-cdup").strip()
                    if len(cdup) > 0:
                        chdir(cdup);

        if not isValidGitDir(cmd.gitdir):
            if isValidGitDir(cmd.gitdir + "/.git"):
                cmd.gitdir += "/.git"
            else:
                die("fatal: cannot locate git repository at %s" % cmd.gitdir)

        os.environ["GIT_DIR"] = cmd.gitdir
        
上面的代码用来设置系统的GIT_DIR环境，因为P4Submit这个类继承自Command类，而父类中needsGit 默认色true，
所以上面的代码会执行到。并首先假设".git"目录就在当前工作目录下，所以会cmd.gitdir最初被赋值为当前目录后面加上".git".
然后通过isValidGitDir()函数检查这个“假设”的目录是否正确，如果在子目录下，这个值就是非法的。系统会执行"git rev-parse --git-dir"获得正确的".git"路径。然后通过执行 'git rev-parse --show-cdup' 得到'.git'跟当前目录的相对路径.
并调用chdir()切换到该路径，最后设置GIT_DIR变量。到这里，预备工作就做完了，接下来就要进入“正题”了。

从run()函数开始执行submit流程。
	
	# class P4Sumbit
	def run(self, args):
		if len(args) == 0:
			self.master = currentGitBranch()
			if len(self.master) == 0 or not gitBranchExists("refs/heads/%s" % self.master):
				die("Detecting current git branch failed!")
		elif len(args) == 1:
			self.master = args[0]
			if not branchExists(self.master):
				die("Branch %s does not exist" % self.master)
		else:
			return False
	
函数首先看是否有参数传入，如果没有，使用当前git目录下的master作为提交的branch。否则，使用参数作为提交的branch。所以，
可以使用git p4 submit branchname 的方式提交指定的branch。继续走。

	# run()
	[upstream, settings] = findUpstreamBranchPoint() #run()
	
	def findUpstreamBranchPoint(head = "HEAD"):
		branches = p4BranchesInGit()
		# map from depot-path to branch name
		branchByDepotPath = {}
		for branch in branches.keys():
			tip = branches[branch]
			log = extractLogMessageFromGitCommit(tip)
			settings = extractSettingsGitLog(log)
			if settings.has_key("depot-paths"):
				paths = ",".join(settings["depot-paths"])
				branchByDepotPath[paths] = "remotes/p4/" + branch

	# result of 'git rev-parse --symbolic --remotes' 
	p4/HEAD
	p4/master
	
	# result of 'git rev-parse p4/master'
	abce....wxyz
	
	# result of 'git cat-file commit abcd....wxyz'
	tree 07f11e5ec798cef1fbc0f98f7a2cd6ffbf9369ee
	parent 26d3a4768940f0055c074e68b11793a9c01d41af
	author xxx 1385704741 +0800
	committer xxx  1385704741 +0800

	Add b

	[git-p4: depot-paths = "//AB/C/D/": change = 2079605]
	
该函数会查找该git目录下的代码对应的perforce上代码位置，通过执行"git rev-parse --symbolic --remotes"可以得到相关的p4 remote branch的内容，以”p4/”开头，我们要找的则是"p4/master", 通过"git rev-parse p4/master"可以获得该ref对应的commit id并返回。
这就是p4BranchesInGit()函数做的工作。在获得这个commit id之后，通过函数extractLogMessageFromGitCommit(id)获得该commit对应的log信息(该函数执行 git cat-file commit id 命令), 一般来说，该log信息中会包含相应的perforce目录的信息。
而extractSettingsGitLog(log)则是从log中解析出这个目录值。
这个目录的值(//AB/C/D/)就是上面的函数要返回的内容。

run()函数继续往下走。

 	self.clientPath = p4Where(self.depotPath)
        # ensure the clientPath exists
        new_client_dir = False
        if not os.path.exists(self.clientPath):
            new_client_dir = True
            os.makedirs(self.clientPath)

        chdir(self.clientPath, is_client_path=True)
        if self.dry_run:
            print "Would synchronize p4 checkout in %s" % self.clientPath
        else:
            print "Synchronizing p4 checkout..."
            if new_client_dir:
                # old one was destroyed, and maybe nobody told p4
                p4_sync("...", "-f")
            else:
                p4_sync("...")
        self.check()
            
p4Where()这个函数通过 'p4 where //AB/C/D' 获得远程目录(//AB/C/D/)对应的本地机器上目录的位置(~/p4local/AB/C/D)。
当然这里返回的只是一个映射关系，本地目录未必是存在的，如果不存在，会创建该目录。然后会切换到该目录，执行'p4 sync ...' 命令，把服务器上的代码同步到本地。
