---
layout: post
title: git-p4 代码分析
category: [技术]
tag: [Python, Git]
description: [Git-p4 source code learn]
---

在[前一篇](http://byrlx.github.io/2013/11/30/%E4%BD%BF%E7%94%A8git%E7%AE%A1%E7%90%86perforce.html)文档中已经介绍了怎样用git来管理perforce服务器的代码。这篇文章通过分析git-p4的代码来深入学习这款软件的原理。
git-p4的代码是用python实现的。

#### 实验环境

p4上代码位置为 "//AB/C/D/", 映射到本地目录为 "~/p4local/AB/C/D/", git p4 clone的代码位置为 "~/gitp4/test/"

	git p4 clone //AB/C/D...@all ~/gitp4/test

#### git p4 submit 流程

在本地修改完文件后，要把本地的git commit提交到perforce服务器，使用git p4 submit, 通常情况下，会弹出一个文本编辑器，让用户编辑要提交的内容，编辑完成后,该命令就成功提交了该次修改的内容。这边通过代码分析整个的submit流程。

不过，在那之前，先从main()函数开始看起，这是任何程序都无法逾越的“鸿沟”。

	def main():
	    if len(sys.argv[1:]) == 0:
	        printUsage(commands.keys())
	        sys.exit(2)
	
	    cmdName = sys.argv[1]
	    try:
	        klass = commands[cmdName]
	        cmd = klass()
	    except KeyError:
	        print "unknown command %s" % cmdName
	        print ""
	        printUsage(commands.keys())

这部分代码检查参数的合法行，这里传入了submit，得到commands这个字典中查找是否存在这个key。commands中的每个key都对应一个class，如果传入的key存在，会生成一个相应class的对象。commands的定义如下：

	commands = {
	    "debug" : P4Debug,
	    "submit" : P4Submit,
	    "commit" : P4Submit,
	    "sync" : P4Sync,
	    "rebase" : P4Rebase,
	    "clone" : P4Clone,
	    "rollback" : P4RollBack,
	    "branches" : P4Branches
	}

后面是使用optparse设置添加一些选项。先略过，接着看main()下面的内容。

    if cmd.needsGit:
        if cmd.gitdir == None:
            cmd.gitdir = os.path.abspath(".git")
            if not isValidGitDir(cmd.gitdir):
                cmd.gitdir = read_pipe("git rev-parse --git-dir").strip()
                if os.path.exists(cmd.gitdir):
                    cdup = read_pipe("git rev-parse --show-cdup").strip()
                    if len(cdup) > 0:
                        chdir(cdup);

        if not isValidGitDir(cmd.gitdir):
            if isValidGitDir(cmd.gitdir + "/.git"):
                cmd.gitdir += "/.git"
            else:
                die("fatal: cannot locate git repository at %s" % cmd.gitdir)

        os.environ["GIT_DIR"] = cmd.gitdir
        
上面的代码用来设置系统的GIT_DIR环境，因为P4Submit这个类继承自Command类，而父类中needsGit 默认色true，
所以上面的代码会执行到。并首先假设".git"目录就在当前工作目录下，所以会cmd.gitdir最初被赋值为当前目录后面加上".git".
然后通过isValidGitDir()函数检查这个“假设”的目录是否正确，如果在子目录下，这个值就是非法的。系统会执行"git rev-parse --git-dir"获得正确的".git"路径。然后通过执行 'git rev-parse --show-cdup' 得到'.git'跟当前目录的相对路径.
并调用chdir()切换到该路径，最后设置GIT_DIR变量。到这里，预备工作就做完了，接下来就要进入“正题”了。

从run()函数开始执行submit流程。
	
	# class P4Sumbit
	def run(self, args):
		if len(args) == 0:
			self.master = currentGitBranch()
			if len(self.master) == 0 or not gitBranchExists("refs/heads/%s" % self.master):
				die("Detecting current git branch failed!")
		elif len(args) == 1:
			self.master = args[0]
			if not branchExists(self.master):
				die("Branch %s does not exist" % self.master)
		else:
			return False
	
函数首先看是否有参数传入，如果没有，使用当前git目录下的master作为提交的branch。否则，使用参数作为提交的branch。所以，
可以使用git p4 submit branchname 的方式提交指定的branch。继续走。

	# run()
	[upstream, settings] = findUpstreamBranchPoint() #run()
	
	def findUpstreamBranchPoint(head = "HEAD"):
		branches = p4BranchesInGit()
		# map from depot-path to branch name
		branchByDepotPath = {}
		for branch in branches.keys():
			tip = branches[branch]
			log = extractLogMessageFromGitCommit(tip)
			settings = extractSettingsGitLog(log)
			if settings.has_key("depot-paths"):
				paths = ",".join(settings["depot-paths"])
				branchByDepotPath[paths] = "remotes/p4/" + branch

	# result of 'git rev-parse --symbolic --remotes' 
	p4/HEAD
	p4/master
	
	# result of 'git rev-parse p4/master'
	abce....wxyz
	
	# result of 'git cat-file commit abcd....wxyz'
	tree 07f11e5ec798cef1fbc0f98f7a2cd6ffbf9369ee
	parent 26d3a4768940f0055c074e68b11793a9c01d41af
	author xxx 1385704741 +0800
	committer xxx  1385704741 +0800

	Add b

	[git-p4: depot-paths = "//AB/C/D/": change = 2079605]
	
该函数会查找该git目录下的代码对应的perforce上代码位置，通过执行"git rev-parse --symbolic --remotes"可以得到相关的p4 remote branch的内容，以”p4/”开头，我们要找的则是"p4/master", 通过"git rev-parse p4/master"可以获得该ref对应的commit id并返回。
这就是p4BranchesInGit()函数做的工作。在获得这个commit id之后，通过函数extractLogMessageFromGitCommit(id)获得该commit对应的log信息(该函数执行 git cat-file commit id 命令), 一般来说，该log信息中会包含相应的perforce目录的信息。
而extractSettingsGitLog(log)则是从log中解析出这个目录值。
这个目录的值(//AB/C/D/)就是上面的函数要返回的内容。

run()函数继续往下走。

 	self.clientPath = p4Where(self.depotPath)
        # ensure the clientPath exists
        new_client_dir = False
        if not os.path.exists(self.clientPath):
            new_client_dir = True
            os.makedirs(self.clientPath)

        chdir(self.clientPath, is_client_path=True)
        if self.dry_run:
            print "Would synchronize p4 checkout in %s" % self.clientPath
        else:
            print "Synchronizing p4 checkout..."
            if new_client_dir:
                # old one was destroyed, and maybe nobody told p4
                p4_sync("...", "-f")
            else:
                p4_sync("...")
        self.check()
            
p4Where()这个函数通过 'p4 where //AB/C/D' 获得远程目录(//AB/C/D/)对应的本地机器上目录的位置(~/p4local/AB/C/D)。
当然这里返回的只是一个映射关系，本地目录未必是存在的，如果不存在，会创建该目录。然后会切换到该目录，执行'p4 sync ...' 命令，把服务器上的代码同步到本地。run()函数继续往下走。

	commits = []
        for line in read_pipe_lines(["git", "rev-list", "--no-merges", "%s..%s" % (self.origin, self.master)]):
            commits.append(line.strip())
        commits.reverse()
        
        for i, commit in enumerate(commits):
            if self.dry_run:
                print " ", read_pipe(["git", "show", "-s",
                                      "--format=format:%h %s", commit])
                ok = True
            else:
                ok = self.applyCommit(commit)
            if ok:
                applied.append(commit)
            else:
                if self.prepare_p4_only and i < last:
                    print "Processing only the first commit due to option" \
                          " --prepare-p4-only"
                    break
                if i < last:
                    quit = False
                    while True:
                        # prompt for what to do, or use the option/variable
                        if self.conflict_behavior == "ask":
                            print "What do you want to do?"
                            response = raw_input("[s]kip this commit but apply"
                                                 " the rest, or [q]uit? ")
                            if not response:
                                continue
                        elif self.conflict_behavior == "skip":
                            response = "s"
                        elif self.conflict_behavior == "quit":
                            response = "q"
                        else:
                            die("Unknown conflict_behavior '%s'" %
                                self.conflict_behavior)

                        if response[0] == "s":
                            print "Skipping this commit, but applying the rest"
                            break
                        if response[0] == "q":
                            print "Quitting"
                            quit = True
                            break
                    if quit:
                        break
                        


第一段代码是获得当前git目录中未提交到p4中的commits，使用的命令为'git rev-list --no-merges p4/master..master'.
(前面的代码有将 self.origin 设为 p4/master)。因为这个命令获得值是从新到旧，所以后面会做一次 reverse().

获得commits之后，就透过一个for循环依次提交每一个commit，如果提交失败并且还有commit未提交，
系统会询问你是'skip掉这次提交但是继续提交剩下的commit' 还是'退出'。如果选's'，会skip掉这次提交但是继续剩下提交。
如果选择'q'的话，P4Submit过程就终止了。
这段代码的核心就是'applyCommit(commit)'这个函数，所以接下来就看一下这个函数的实现。

    def applyCommit(self, id):
        (p4User, gitEmail) = self.p4UserForCommit(id)

        diff = read_pipe_lines("git diff-tree -r %s \"%s^\" \"%s\"" % (self.diffOpts, id, id))

        for line in diff:
            diff = parseDiffTreeEntry(line)
            modifier = diff['status']
            path = diff['src']
            if modifier == "M":
                p4_edit(path)
                if isModeExecChanged(diff['src_mode'], diff['dst_mode']):
                    filesToChangeExecBit[path] = diff['dst_mode']
                editedFiles.add(path)
            elif modifier == "A":
                filesToAdd.add(path)
                filesToChangeExecBit[path] = diff['dst_mode']
                if path in filesToDelete:
                    filesToDelete.remove(path)
            elif modifier == "D":
                filesToDelete.add(path)
                if path in filesToAdd:
                    filesToAdd.remove(path)
            
                                
        for f in filesToAdd:
            p4_add(f)
        for f in filesToDelete:
            p4_revert(f)
            p4_delete(f)
	
	# example of 'git diff -r -M head~ head'
	# 格式解析：":/1源文件权限/2 目标文件权限/3 源文件shal/4 目标文件shal/ 文件状态[D/A/M]/6状态数值(一般没有)/7 
 			源文件/8 目标文件/9 
 	:100755 000000 f960e22062b2fc97a8c127a663a475aa294c8dbc 0000000000000000000000000000000000000000 D     README.md
	:000000 100644 0000000000000000000000000000000000000000 e69de29bb2d1d6434b8b29ae775ad8c2e48c5391 A     a
	:100755 100755 ec37145ad67a00cb0c7c9b3d2cb4124ffa652b63 587be6b4c3f93f93c489c0111bba5596147a26cb M     cq.js

程序刚开始会使用'git diff-tree' 命令查看这次提交都修改了那些文件，上面的代码中给出了典型的一个输出的例子。
平常最常见的就是添加/删除/修改这三个操作，所以这边只分析这三种操作。获得修改的结果后，会执行一个for循环，
在每次循环开始调用parseDiffTreeEntry()解析这次修改的内容。然后把本次修改对应的文件添加到对应的set中(editeaFiles,
filesToAdd, filesToDelete)。然后对set中的每个文件都执行相应的p4命令(p4 add/revert/delete)。

看下parseDiffTerrEntry()实现：

	def diffTreePattern():
	    pattern = re.compile(':(\d+) (\d+) (\w+) (\w+) ([A-Z])(\d+)?\t(.*?)((\t(.*))|$)')
	    while True:
	        yield pattern
	
	def parseDiffTreeEntry(entry):
	    match = diffTreePattern().next().match(entry)
	    if match:
	        return {
	            'src_mode': match.group(1),
	            'dst_mode': match.group(2),
	            'src_sha1': match.group(3),
	            'dst_sha1': match.group(4),
	            'status': match.group(5),
	            'status_score': match.group(6),
	            'src': match.group(7),
	            'dst': match.group(10)
	        }
	    return None
	    
parseDiffTerrEntry()用正则表达式的方式解析每次修改的内容。严格按照前面的格式解析，如果没有该项则返回NONE.

前面讲了会对每个set中的文件执行相应的p4命令，那么接下来就要真正开始做提交动作了。

        logMessage = extractLogMessageFromGitCommit(id)
        logMessage = logMessage.strip()
        (logMessage, jobs) = self.separate_jobs_from_description(logMessage)
        template = self.prepareSubmitTemplate()
        submitTemplate = self.prepareLogMessage(template, logMessage, jobs)
        for editedFile in editedFiles:
            diff += p4_read_pipe(['diff', '-du', wildcard_encode(editedFile)])
        for newFile in filesToAdd:
            newdiff += "==== new file ====\n"
            newdiff += "--- /dev/null\n"
            newdiff += "+++ %s\n" % newFile
            f = open(newFile, "r")
            for line in f.readlines():
                newdiff += "+" + line
            f.close()
        (handle, fileName) = tempfile.mkstemp()
        tmpFile = os.fdopen(handle, "w+")
        tmpFile.write(submitTemplate + separatorLine + diff + newdiff)
        tmpFile.close()

        if self.edit_template(fileName):
            p4_write_pipe(['submit', '-i'], submitTemplate)

上面的代码就是提交流程，前面一大段代码的目的只有一个：把'p4 change -o'和'git diff'的结果合并，生成最后的提交模板，
保存到一个临时文件中，然后打开vim，让用户编辑该模板，最后，调用'p4 submit -i content'提交到perforce服务器。
（当然用户也可以选择放弃提交，此处代码略过）。

该次commit提交到perforce，就接着执行同样的流程提交下一个commit。
