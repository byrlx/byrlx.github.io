---
layout: post
title: Square开源系列(3) Retrofit 源码解读 
tag: [Java, Android, Square]
description: [retrofit源码阅读笔记]
---

<p>
(持续更新)
</p>

<p>
不了解Retrofit的人可以先参考这篇介绍文章 <a href="http://byrlx.github.io/2015-11/retrofit/">http://byrlx.github.io/2015-11/retrofit/</a>
</p>

<div id="outline-container-sec-1" class="outline-2">
<h2 id="sec-1">使用Retrofit的一般步骤.</h2>
<div class="outline-text-2" id="text-1">
<p>
在<a href="http://byrlx.github.io/2015-11/retrofit/">这篇</a> 文章里我们创建了一个最简单的Retrofit程序, 定义了一个用户GET请求的Service Client, 
并通过Retrofit来创建一个Client实例, 来实现具体的HTTP请求, 并将请求的结果转化为User对象.
所以一般来说, 使用retrofit的通常步骤为:
</p>
<ol class="org-ol">
<li>创建一个Retrofit实例.
</li>
<li>调用retrofit的create()函数创建一个接口的具体对象.
接口为用户自定义的HTTP接口类, 并将其作为参数传递给create().
</li>
<li>用2生成的对象调用其定义的http请求函数.该函数返回一个Call对象.
</li>
<li>执行上一步返回的call对象的execute().body()获取http结果, 该结果返回的是对象.
</li>
</ol>
</div>
</div>
<div id="outline-container-sec-2" class="outline-2">
<h2 id="sec-2">从示例代码入手追溯底层实现</h2>
<div class="outline-text-2" id="text-2">
</div><div id="outline-container-sec-2-1" class="outline-3">
<h3 id="sec-2-1">Retrofit类</h3>
<div class="outline-text-3" id="text-2-1">
<p>
Retrofit的一个超好用的特点就是高度封装性:我们只需定义一个抽象接口和一系列抽象的请求函数, 
retrofit就可以为我们生成一个该接口的具体类, 然后我们就可以用自己定义的接口函数实现具体的
Http请求, 而无需关心具体http的实现, 这些retrofit都帮我们做了. 下面看一下这个类的代码:
</p>
<ol class="org-ol">
<li>内部Builder类

<p>
Retrofit使用了Builder设计模式, 不能直接通过 "new Retrofit()" 来创建一个
retrofit对象, 而是需要调用其内部类Builder的build函数.
从下面的代码看(实现细节省略), 这是一个典型的Builder模式, Builder类内部定义和Retrofit相同的变量, 
并且其每一个setter()函数都会返回this. 最后通过build()函数new一个Retrofit
对象并返回.
</p>

<p>
<b>注</b>: 从代码中可以看到, 如果在builder中没有主动传入OkHttpClient的话,
Builder会创建一个默认的OkHttpClient.
</p>
<div class="org-src-container">

<pre class="src src-java">public static final class Builder {
  public Builder() {
    converterFactories.add(new BuiltInConverters());
  }

  public Builder client(OkHttpClient client) {...}
  public Builder baseUrl(String baseUrl) {...}
  ...
  public Builder addConverterFactory(Converter.Factory converterFactory) {}
  public Builder addCallAdapterFactory(CallAdapter.Factory factory) {}
  public Builder callbackExecutor(Executor callbackExecutor) {}
  public Builder validateEagerly() {}

  /** Create the {@link Retrofit} instances. */
  public Retrofit build() {
    if (baseUrl == null) {
      throw new IllegalStateException("Base URL required.");
    }

    OkHttpClient client = this.client;
    if (client == null) {
      client = new OkHttpClient();
    }

    // Make a defensive copy of the adapters and add the default Call adapter.
    List&lt;CallAdapter.Factory&gt; adapterFactories = new ArrayList&lt;&gt;(this.adapterFactories);
    adapterFactories.add(Platform.get().defaultCallAdapterFactory(callbackExecutor));

    // Make a defensive copy of the converters.
    List&lt;Converter.Factory&gt; converterFactories = new ArrayList&lt;&gt;(this.converterFactories);

    return new Retrofit(client, baseUrl, converterFactories, adapterFactories, callbackExecutor,
	validateEagerly);
  }
}
</pre>
</div>
</li>
<li>create()函数
该函数是Retrofit的 <b>精华</b>, 通过它, 我们可以将自定义的接口转化为一个具体的
该接口的对象.
<div class="org-src-container">

<pre class="src src-java">public &lt;T&gt; T create(final Class&lt;T&gt; service) {
  Utils.validateServiceInterface(service);
  if (validateEagerly) {
    eagerlyValidateMethods(service);
  }
  return (T) Proxy.newProxyInstance(service.getClassLoader(), new Class&lt;?&gt;[] { service },
      new InvocationHandler() {
	private final Platform platform = Platform.get();

	@Override public Object invoke(Object proxy, Method method, Object... args)
	    throws Throwable {
	  // If the method is a method from Object then defer to normal invocation.
	  if (method.getDeclaringClass() == Object.class) {
	    return method.invoke(this, args);
	  }
	  if (platform.isDefaultMethod(method)) {
	    return platform.invokeDefaultMethod(method, service, proxy, args);
	  }
	  return loadMethodHandler(method).invoke(args);
	}
      });
}
</pre>
</div>
<p>
上面的代码就是retrofit的实现, 代码比较短, 首先是调用validateServiceInterface()
来检查传入的类变量是否合法:
</p>
<pre class="example">
static &lt;T&gt; void validateServiceInterface(Class&lt;T&gt; service) {
  if (!service.isInterface()) {
    throw new IllegalArgumentException("API declarations must be interfaces.");
  }
  if (service.getInterfaces().length &gt; 0) {
    throw new IllegalArgumentException("API interfaces must not extend other interfaces.");
  }
}
</pre>
<p>
这里检查的地方有两个: 1, 传入的参数必须为一个interface类型. 2, 传入的参数
没有实现其他interface.
</p>

<p>
参数合法性检查完之后, 会条件性的执行eagerlyValidateMethods(), 这里先略过.
接下来是调用Proxy的newProxyInstance()函数为传入的参数生成动态代理. 
动态代理机制是Java的一个高级特性, 其主要功能就是可以为委托类对象生成代理类,
代理类可以将所有的方法调用分派到委托对象上反射执行. 动态代理的相关知识可参考
相关的Java书籍. 这里传入newProxyInstance()有三个参数: 1, 接口的classLoader. 2, 
只包含接口的class数组. 3, 自定义的InvocationHandler()对象, 该对象实现了invoke()
函数, 通常在该函数中实现对委托类函数的访问. 所以从create函数可以看出, *其实该函数
返回的是一个动态代理类对象(被转化成了我们自定义的接口), 当我们调用该接口的自定义
函数时, 我们调用的实际是invoke()函数.* 而要执行的方法被当作参数传给了invoke.
</p>

<p>
下面看下invoke()函数的具体实现:
</p>
<ul class="org-ul">
<li>判断要调用的方法是否是object类的方法(每个类都有), 如果是则直接在当前
类上调用.
</li>
<li>如果是平台的默认方法, 调用platform的相关函数(目前这段代码不会走到)
</li>
<li>否则, 调用loadMethodHandler()函数返回值的的invoke()方法实现函数调用.
这个方法就是retrofit替我们实现Http请求的地方.
</li>
</ul>
</li>
<li>loadMethodHandler()函数
<div class="org-src-container">

<pre class="src src-java">MethodHandler&lt;?&gt; loadMethodHandler(Method method) {
  MethodHandler&lt;?&gt; handler;
  synchronized (methodHandlerCache) {
    handler = methodHandlerCache.get(method);
    if (handler == null) {
      handler = MethodHandler.create(this, method);
      methodHandlerCache.put(method, handler);
    }
  }
  return handler;
}
</pre>
</div>
<p>
这个函数的实现比较简单, 就是从cache中寻找调用函数的MethodHandler, 如果找到就
返回, 否则创建一个新的返回. 下面就看下这个类的实现.
</p>
</li>
</ol>
</div>
</div>
<div id="outline-container-sec-2-2" class="outline-3">
<h3 id="sec-2-2">MethodHandler类</h3>
<div class="outline-text-3" id="text-2-2">
<p>
在上一小节说过, 我们通过retrofit.create()创造出一个自定义接口的实例,
然后调用实例方法实际上最后是对MethodHandler的invoke()函数的调用, 这一节
就具体看一下这个类及相关方法的具体实现.
</p>
<ol class="org-ol">
<li>对象创建.
<div class="org-src-container">

<pre class="src src-java">final class MethodHandler&lt;T&gt; {
  @SuppressWarnings("unchecked")
  static MethodHandler&lt;?&gt; create(Retrofit retrofit, Method method) {
    CallAdapter&lt;Object&gt; callAdapter = (CallAdapter&lt;Object&gt;) createCallAdapter(method, retrofit);
    Type responseType = callAdapter.responseType();
    Converter&lt;ResponseBody, Object&gt; responseConverter =
	(Converter&lt;ResponseBody, Object&gt;) createResponseConverter(method, retrofit, responseType);
    RequestFactory requestFactory = RequestFactoryParser.parse(method, responseType, retrofit);
    return new MethodHandler&lt;&gt;(retrofit, requestFactory, callAdapter, responseConverter);
  }
  ...
</pre>
</div>
<p>
该类的构造函数为私有函数, 所以只能通过静态函数create()来创造一个Methodhandler
对象.该函数首先基于mothod和retrofit创建一个CallAdapter的对象, 然后基于该对象
创建一个Converter对象, 接着生成一个RequestFactory对象, 然后把这些对象作为
参数传递给构造函数生成一个MethodHandler实例.
</p>
</li>
<li>创建CallAdapter实例
<div class="org-src-container">

<pre class="src src-java">private static CallAdapter&lt;?&gt; createCallAdapter(Method method, Retrofit retrofit) {
  Type returnType = method.getGenericReturnType();
  if (Utils.hasUnresolvableType(returnType)) {
    throw Utils.methodError(method,
	"Method return type must not include a type variable or wildcard: %s", returnType);
  }
  if (returnType == void.class) {
    throw Utils.methodError(method, "Service methods cannot return void.");
  }
  Annotation[] annotations = method.getAnnotations();
  try {
    return retrofit.callAdapter(returnType, annotations);
  } catch (RuntimeException e) { // Wide exception range because factories are user code.
    throw Utils.methodError(e, method, "Unable to create call adapter for %s", returnType);
  }
}
</pre>
</div>
<p>
首先调用method的getGenericReturnType()获取该函数的返回类型, 如果该类型不能
被解析或为void, 报错. 然后通过getAnnotations()函数获取我们在定义函数时使用的注解(GET/POST..)
最后基于返回值和注解调用retrofit的callAdapter()生成对象.
</p>
<div class="org-src-container">

<pre class="src src-java">//retrofit.java
public CallAdapter&lt;?&gt; callAdapter(Type returnType, Annotation[] annotations) {
   return nextCallAdapter(null, returnType, annotations);
 }

 public CallAdapter&lt;?&gt; nextCallAdapter(CallAdapter.Factory skipPast, Type returnType,
     Annotation[] annotations) {
   checkNotNull(returnType, "returnType == null");
   checkNotNull(annotations, "annotations == null");

   int start = adapterFactories.indexOf(skipPast) + 1;
   for (int i = start, count = adapterFactories.size(); i &lt; count; i++) {
     CallAdapter&lt;?&gt; adapter = adapterFactories.get(i).get(returnType, annotations, this);
     if (adapter != null) {
       return adapter;
     }
   }
    ....
 }
</pre>
</div>
<p>
callAdapter函数就是从retrofit的adapterFactories变量中找到与该函数和返回值相关的
adapter, 如果找不到则报错. 从前面Retrofit的builder代码可以看到, 如果用户没用显示声明
Adapter的话, 默认会创建一个defaultAdapterFactory的实例加入到adapterFactories中.
</p>
</li>
<li>invoke()函数
invoke()函数是MethodHandler/对象/的唯一函数, 该函数实际是调用了callAdapter.adapt()
函数, 该函数的参数为一个OkHttpCall对象, 从这里就可以看成该函数是Http请求的
实际函数, 后面在看CallAdapter代码会再详细介绍其功能.
<div class="org-src-container">

<pre class="src src-java">Object invoke(Object... args) {
  return callAdapter.adapt(new OkHttpCall&lt;&gt;(retrofit, requestFactory, responseConverter, args));
}
</pre>
</div>
</li>
</ol>
</div>
</div>

<div id="outline-container-sec-2-3" class="outline-3">
<h3 id="sec-2-3">CallAdapter和DefaultCallAdapter</h3>
<div class="outline-text-3" id="text-2-3">
<p>
前面的小节讲过, 当我们在程序中定义了一个retrofit接口, 然后通过retrofit.create()
生成一个实例, 并调用该实例的函数时, 会得到一个Call类型的返回值(因此用户自定义的
接口中的函数返回值应该都为Call类型). 对实例函数的调用最终是调用到了retrofit的
callAdapter的adapt()函数. 这个函数(返回Call)是在DefaultCallAdapter中实现的.
</p>
<ol class="org-ol">
<li>DefaultCallAdapter
<div class="org-src-container">

<pre class="src src-java">final class DefaultCallAdapter implements CallAdapter&lt;Call&lt;?&gt;&gt; {
  static final Factory FACTORY = new Factory() {
    @Override
    public CallAdapter&lt;?&gt; get(Type returnType, Annotation[] annotations, Retrofit retrofit) {
      if (Utils.getRawType(returnType) != Call.class) {
	return null;
      }
      Type responseType = Utils.getCallResponseType(returnType);
      return new DefaultCallAdapter(responseType);
    }
  };

  private final Type responseType;

  DefaultCallAdapter(Type responseType) {
    this.responseType = responseType;
  }

  @Override public Type responseType() {
    return responseType;
  }

  @Override public &lt;R&gt; Call&lt;R&gt; adapt(Call&lt;R&gt; call) {
    return call;
  }
}
</pre>
</div>
<p>
可以看到adapt()函数返回了一个Call类型的结果, 跟我们在例子中定义的一样.
DefaultCallAdapter的父类是CallAdapter. 所以如果要实现自己的Adapter, 同样
需要继承此类.
</p>
</li>
</ol>
</div>
</div>
<div id="outline-container-sec-2-4" class="outline-3">
<h3 id="sec-2-4">Call和OkHttpCall</h3>
<div class="outline-text-3" id="text-2-4">
<p>
在MethodHandler一节可以看到invoke中调用adapt()函数时传入了一个OkHttpCall类型, 
所以实例中用户调用自定义函数返回的也是一个OkHttpCall类型的结果.
</p>

<ol class="org-ol">
<li>Call接口定义.
Call是retrofit定义的一个接口规范, 该类主要用于进行Http请求.
代码注释阐明了该接口的几个功能和约束:
<ul class="org-ul">
<li>使用execute()进行同步调用.
</li>
<li>使用enqueue()进行异步调用.
</li>
<li>无论同步还是异步, 都可以在任何时候使用cancel取消.
</li>
<li>使用clone()进行一个功能的多次请求.(例如失败后的轮询).
</li>
</ul>
<div class="org-src-container">

<pre class="src src-java">public interface Call&lt;T&gt; extends Cloneable {
  Response&lt;T&gt; execute() throws IOException;
  void enqueue(Callback&lt;T&gt; callback);
  void cancel();
  Call&lt;T&gt; clone();
}
</pre>
</div>
</li>
<li>OkHttpCall.    
OkHttpCall是基于OkHttp的Call接口的一个实现, 可以通过这个类看一下具体它是怎样
遵循Call接口的规范的. 下面是其几个主要函数的实现:
<ul class="org-ul">
<li>execute().
<div class="org-src-container">

<pre class="src src-java">public Response&lt;T&gt; execute() throws IOException {
  synchronized (this) {
    if (executed) throw new IllegalStateException("Already executed");
    executed = true;
  }

  com.squareup.okhttp.Call rawCall = createRawCall();
  if (canceled) {
    rawCall.cancel();
  }
  this.rawCall = rawCall;

  return parseResponse(rawCall.execute());
}
</pre>
</div>
<p>
前面讲过该函数是Call的同步请求函数, 直接返回请求结果. 从代码中可以看出.
由于executed变量被设为true后其值一直不变, 所以execute的"请求"代码只会
执行一次. 该函数使用了OkHttp的Call类来执行具体的执行动作. 最后调用
parseResponse()处理请求结果.
</p>
</li>
<li>enqueue().
该函数是Call的异步请求函数, 需要向该函数传递一个Callback类型的参数.Callback是一个
接口, 提供了两个函数onResponse()表示成功, onFailure()表示失败.
在Android中,这两个函数需要在UI线程中执行.
<div class="org-src-container">

<pre class="src src-java">public interface Callback&lt;T&gt; {
  /** Successful HTTP response. */
  void onResponse(Response&lt;T&gt; response, Retrofit retrofit);

  /** Invoked when a network or unexpected exception occurred during the HTTP request. */
  void onFailure(Throwable t);
}
</pre>
</div>

<p>
在enqueue()中创建了一个com.squareup.okhttp.Call实例,
http请求动作实际是这个实例的enqueue()函数来执行的.
</p>
<div class="org-src-container">

<pre class="src src-java">@Override public void enqueue(final Callback&lt;T&gt; callback) {
    synchronized (this) {
      if (executed) throw new IllegalStateException("Already executed");
      executed = true;
    }

    com.squareup.okhttp.Call rawCall;
    try {
      rawCall = createRawCall();
    } catch (Throwable t) {
      callback.onFailure(t);
      return;
    }
    ...
    rawCall.enqueue(new com.squareup.okhttp.Callback() {
      private void callFailure(Throwable e) {
	try {
	  callback.onFailure(e);
	} catch (Throwable t) {
	  t.printStackTrace();
	}
      }

      private void callSuccess(Response&lt;T&gt; response) {
	try {
	  callback.onResponse(response, retrofit);
	} catch (Throwable t) {
	  t.printStackTrace();
	}
      }

      @Override public void onFailure(Request request, IOException e) {
	callFailure(e);
      }

      @Override public void onResponse(com.squareup.okhttp.Response rawResponse) {
	Response&lt;T&gt; response;
	try {
	  response = parseResponse(rawResponse);
	} catch (Throwable e) {
	  callFailure(e);
	  return;
	}
	callSuccess(response);
      }
    });
}
</pre>
</div>
</li>
<li>cancel() 
取消请求, 实际是调用com.squareup.okhttp.Call的cancel()函数.
</li>
<li>clone()
由于一个对象只能执行一次请求, 所以同一请求的多次执行, 需要通过clone()来
复制, 该函数实际上是创建了一个新的OkHttpCall对象.
</li>
</ul>
</li>
</ol>
</div>
</div>
</div>
