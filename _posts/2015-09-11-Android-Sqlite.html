---
layout: post
title: Android Sqlite源码笔记
tag: [Android]
---

<p>
(持续更新)
</p>

<p>
代码阅读笔记, 散乱无章, 亟需整理.
</p>

<div id="outline-container-sec-1" class="outline-2">
<h2 id="sec-1">mind</h2>
<div class="outline-text-2" id="text-1">
<ol class="org-ol">
<li>在类中设入口函数的好处?
</li>
</ol>
</div>
</div>
<div id="outline-container-sec-2" class="outline-2">
<h2 id="sec-2">SQLiteDatabaseConfiguration</h2>
<div class="outline-text-2" id="text-2">
<p>
  定义SQLite数据库的配置, 包括路径/是否为内存数据库/打开权限/最大连接数.
打开权限存放在openFlags变量,详细的权限在SQLiteDatabase中定义
</p>

<p>
<b>该类被声明为final</b>
</p>

<div class="org-src-container">

<pre class="src src-java">//SQLiteDatabase.java

  public static final int OPEN_READWRITE = 0x00000000;          // update native code if changing

    /**
     * Open flag: Flag for {@link #openDatabase} to open the database for reading only.
     * This is the only reliable way to open a database if the disk may be full.
     */
    public static final int OPEN_READONLY = 0x00000001;           // update native code if changing

    private static final int OPEN_READ_MASK = 0x00000001;         // update native code if changing
</pre>
</div>
</div>
</div>

<div id="outline-container-sec-3" class="outline-2">
<h2 id="sec-3">SQLiteConnectionPool</h2>
<div class="outline-text-2" id="text-3">
<p>
sqlite数据库连接池, 维护一定数量的数据库连接.
</p>

<p>
<b>该类被声明为final</b>
</p>
</div>

<div id="outline-container-sec-3-1" class="outline-3">
<h3 id="sec-3-1">初始化</h3>
<div class="outline-text-3" id="text-3-1">
<p>
该类的构造函数为private, 因此只能通过入口函数open()来初始化.后者会创建一个新的SQLiteConnectionPool对象,
并调用该对象的open()函数进行初始化操作. 
初始化阶段, 类的open()函数会生成一个SQLiteConnection对象, 并将该对象作为主要的连接.
</p>

<pre class="example">
private SQLiteConnectionPool(SQLiteDatabaseConfiguration configuration) {
    mConfiguration = new SQLiteDatabaseConfiguration(configuration);
    setMaxConnectionPoolSizeLocked();
}

/**
 * Opens a connection pool for the specified database.
 *
 * @param configuration The database configuration.
 * @return The connection pool.
 *
 * @throws SQLiteException if a database error occurs.
 */
public static SQLiteConnectionPool open(SQLiteDatabaseConfiguration configuration) {
    if (configuration == null) {
        throw new IllegalArgumentException("configuration must not be null.");
    }

    // Create the pool.
    SQLiteConnectionPool pool = new SQLiteConnectionPool(configuration);
    pool.open(); // might throw
    return pool;
}

private void open() {
    // Open the primary connection.
    // This might throw if the database is corrupt.
    mAvailablePrimaryConnection = openConnectionLocked(mConfiguration,
            true /*primaryConnection*/); // might throw

    // Mark the pool as being open for business.
    mIsOpen = true;
    mCloseGuard.open("close");
}
</pre>
</div>
</div>
<div id="outline-container-sec-3-2" class="outline-3">
<h3 id="sec-3-2">获取连接</h3>
<div class="outline-text-3" id="text-3-2">
<p>
获取连接的入口为acquireConnection(), 但主要实现在waitForConnection()函数中.
</p>

<p>
对该函数的理解看下面的代码标注
</p>
<pre class="example">
    public SQLiteConnection acquireConnection(String sql, int connectionFlags, CancellationSignal cancellationSignal) {
        return waitForConnection(sql, connectionFlags, cancellationSignal);
    }

 // Might throw.
    private SQLiteConnection waitForConnection(String sql, int connectionFlags, CancellationSignal cancellationSignal) {
        final boolean wantPrimaryConnection =
                (connectionFlags &amp; CONNECTION_FLAG_PRIMARY_CONNECTION_AFFINITY) != 0;

        final ConnectionWaiter waiter;
        final int nonce;
        synchronized (mLock) {
            throwIfClosedLocked();

            // Abort if canceled.
            //在等锁的过程中,有可能通过设置CancellationSignal来取消这次动作.
            if (cancellationSignal != null) {
                cancellationSignal.throwIfCanceled();
            }

            // Try to acquire a connection.
            SQLiteConnection connection = null;
            if (!wantPrimaryConnection) {
//获取一个非Primary的连接.看下一节
                connection = tryAcquireNonPrimaryConnectionLocked(
                        sql, connectionFlags); // might throw
            }
//获取非primary失败, 视图获取primary, 实现在下面小节
            if (connection == null) {
                connection = tryAcquirePrimaryConnectionLocked(connectionFlags); // might throw
            }
            if (connection != null) {
                return connection;
            }

//代码走到这里,说明已经没有可用连接, 则生成一个带优先级的waiter来插入到waiter链表中.
//waiter的优先级有两种: 如果申请的连接是交互性的(被UI线程需要), 则其优先级比较高.
            final int priority = getPriority(connectionFlags);
            final long startTime = SystemClock.uptimeMillis();
            waiter = obtainConnectionWaiterLocked(Thread.currentThread(), startTime,
                    priority, wantPrimaryConnection, sql, connectionFlags);
            ConnectionWaiter predecessor = null;
            ConnectionWaiter successor = mConnectionWaiterQueue;
            while (successor != null) {
                if (priority &gt; successor.mPriority) {
                    waiter.mNext = successor;
                    break;
                }
                predecessor = successor;
                successor = successor.mNext;
            }
            if (predecessor != null) {
                predecessor.mNext = waiter;
            } else {
                mConnectionWaiterQueue = waiter;
            }

            nonce = waiter.mNonce;
        }

//如果cancelationListener不为空, 则在对连接请求进行cancel时, 将相应的waiter从waiter链表中
//移除.
        if (cancellationSignal != null) {
            cancellationSignal.setOnCancelListener(new CancellationSignal.OnCancelListener() {
                @Override
                public void onCancel() {
                    synchronized (mLock) {
                        if (waiter.mNonce == nonce) {
                            cancelConnectionWaiterLocked(waiter);
                        }
                    }
                }
            });
        }

//下面的代码循环等待, 知道创建出一个新的connection(或者连接池被关闭)
        try {
            long busyTimeoutMillis = CONNECTION_POOL_BUSY_MILLIS;
            long nextBusyTimeoutTime = waiter.mStartTime + busyTimeoutMillis;
            for (;;) {
                // Detect and recover from connection leaks.
                if (mConnectionLeaked.compareAndSet(true, false)) {
                    synchronized (mLock) {
                        wakeConnectionWaitersLocked();
                    }
                }

//暂停thread直到timeout或被唤醒
                LockSupport.parkNanos(this, busyTimeoutMillis * 1000000L);

//清楚interrupt标志
                Thread.interrupted();

                // Check whether we are done waiting yet.
                synchronized (mLock) {
//如果这段时间连接池被关闭, 抛异常
                    throwIfClosedLocked();

//如果已经等到连接, 将waiter移除, 并返回连接
                    final SQLiteConnection connection = waiter.mAssignedConnection;
                    final RuntimeException ex = waiter.mException;
                    if (connection != null || ex != null) {
                        recycleConnectionWaiterLocked(waiter);
                        if (connection != null) {
                            return connection;
                        }
                        throw ex; // rethrow!
                    }
//如果还没等到, 继续等待.
                    final long now = SystemClock.uptimeMillis();
                    if (now &lt; nextBusyTimeoutTime) {
                        busyTimeoutMillis = now - nextBusyTimeoutTime;
                    } else {
                        logConnectionPoolBusyLocked(now - waiter.mStartTime, connectionFlags);
                        busyTimeoutMillis = CONNECTION_POOL_BUSY_MILLIS;
                        nextBusyTimeoutTime = now + busyTimeoutMillis;
                    }
                }
            }
        } finally {
            // Remove the cancellation listener.
            if (cancellationSignal != null) {
                cancellationSignal.setOnCancelListener(null);
            }
        }
    }
</pre>
</div>
</div>

<div id="outline-container-sec-3-3" class="outline-3">
<h3 id="sec-3-3">获取一个非Primary的连接.</h3>
<div class="outline-text-3" id="text-3-3">
<p>
   调用tryAcquireNonPrimaryConnectionLocked()来获取一个非Primary的连接.
连接池中的非primary的连接都缓存在tryAcquireNonPrimaryConnectionLocked变量中.
</p>

<pre class="example">
    private SQLiteConnection tryAcquireNonPrimaryConnectionLocked(
            String sql, int connectionFlags) {
        // Try to acquire the next connection in the queue.
        SQLiteConnection connection;
        final int availableCount = mAvailableNonPrimaryConnections.size();
//下面if代码的意思:如果已经存在一个跟传入的sql相关联的连接, 则返回该连接.
//返回连接之前,要将其从未用链表(强引用)中移除, 放入已用链表中(弱引用).
        if (availableCount &gt; 1 &amp;&amp; sql != null) {
            for (int i = 0; i &lt; availableCount; i++) {
                connection = mAvailableNonPrimaryConnections.get(i);
                if (connection.isPreparedStatementInCache(sql)) {
                    mAvailableNonPrimaryConnections.remove(i);
                    finishAcquireConnectionLocked(connection, connectionFlags); // might throw
                    return connection;
                }
            }
        }
//上面代码失败,则直接从连接池中取出一个可用的返回
        if (availableCount &gt; 0) {
            connection = mAvailableNonPrimaryConnections.remove(availableCount - 1);
            finishAcquireConnectionLocked(connection, connectionFlags); // might throw
            return connection;
        }

//如果没有可用的, 视图扩展连接池(生成一个新的连接), 如果连接池目前已用连接数量已达到
//上限, 则失败.
        int openConnections = mAcquiredConnections.size();
        if (mAvailablePrimaryConnection != null) {
            openConnections += 1;
        }
        if (openConnections &gt;= mMaxConnectionPoolSize) {
            return null;
        }
        connection = openConnectionLocked(mConfiguration,
                false /*primaryConnection*/); // might throw
        finishAcquireConnectionLocked(connection, connectionFlags); // might throw
        return connection;
    }
</pre>
</div>
</div>
<div id="outline-container-sec-3-4" class="outline-3">
<h3 id="sec-3-4">获取primary连接</h3>
<div class="outline-text-3" id="text-3-4">
<p>
规则: 
</p>
<ol class="org-ol">
<li>如果存在且可用, 返回.
</li>
<li>如果被别人占用着, 返回null
</li>
<li>如果不存在,生成一个新的返回.
</li>
</ol>
<pre class="example">
private SQLiteConnection tryAcquirePrimaryConnectionLocked(int connectionFlags) {
    SQLiteConnection connection = mAvailablePrimaryConnection;
    if (connection != null) {
        mAvailablePrimaryConnection = null;
        finishAcquireConnectionLocked(connection, connectionFlags); // might throw
        return connection;
    }

    // Make sure that the primary connection actually exists and has just been acquired.
    for (SQLiteConnection acquiredConnection : mAcquiredConnections.keySet()) {
        if (acquiredConnection.isPrimaryConnection()) {
            return null;
        }
    }

    // Uhoh.  No primary connection!  Either this is the first time we asked
    // for it, or maybe it leaked?
    connection = openConnectionLocked(mConfiguration,
            true /*primaryConnection*/); // might throw
    finishAcquireConnectionLocked(connection, connectionFlags); // might throw
    return connection;
}
</pre>
</div>
</div>
</div>
