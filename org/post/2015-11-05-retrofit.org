#+OPTIONS: ^nil
#+OPTIONS: toc:nil
#+AUTHOR: Zhengchao Xu
#+EMAIL: xuzhengchaojob@gmail.com

#+BEGIN_HTML
---
layout: post
title: Square开源系列(2) Retrofit 项目 
tag: [Java, Android, Square]
description: [retrofit源码阅读笔记]
---
#+END_HTML

未完成!!!

该项目官网 [[http://square.github.io/retrofit/]], github地址: [[https://github.com/square/retrofit]]

* 项目介绍
官网对retrofit介绍是这是一个"类型安全(type-safe)"的Android/Java http客户端. 
目前retrofit的最新正式版本为1.9.0. 2.0版本预计2015年底发布, 相较于之前版本, 
2.0版本在架构上做了很大改变, 本文代码相关的内容都是基于retrofit2.0.

/注: 在编程语言的语法中, type-safe通常指编译器在编译时检查变量的类型, 如果试图向/
/变量分配一个错误的类型,编译器就会报错./

* 在项目中使用retrofit
+ Maven
  #+BEGIN_SRC xml
<dependency>
  <groupId>com.squareup.retrofit</groupId>
  <artifactId>retrofit</artifactId>
  <version>2.0.0-beta2</version>
</dependency>
  #+END_SRC
+ Gradle
  #+BEGIN_SRC 
 compile 'com.squareup.retrofit:retrofit:2.0.0-beta2' 
  #+END_SRC
+ 混淆配置
  如果项目中使用混淆的话, 需要在混淆文件中假如如下配置
  #+BEGIN_SRC 
-dontwarn retrofit.**
-keep class retrofit.** { *; }
-keepattributes Signature
-keepattributes Exceptions
  
  #+END_SRC
* 程序示例
这部分从一个简单的程序开始, 展示retrofit的使用,并通过对这个程序的进一步介绍retrofit的各种功能.
** 一个简单的retrofit程序
   场景:通过GET请求向服务器返回用户信息, 服务器通过Json格式返回一个或多个用户的信息.基于这个例子
介绍一下retrofit的使用步骤:
1. 用户代码
   #+BEGIN_SRC java
public class User {
    private int id;
    private String name;
    private int age;
}
#+END_SRC
   这段代码定义了用户类User, 每个用户包含三个基本信息:id, name, age;
2. 定义Client和GET请求接口
   #+BEGIN_SRC java
public interface Client {
    @GET("users")
    Call<List<User>>  getUsers();
}
#+END_SRC
   这段代码定义了一个接口Client, 并定义了一个GET函数getUsers(), 该函数用户向服务器发送get请求获取所有的
   用户信息. 定义GET请求需要用GET注解来修饰函数, 注解的参数为uri的相对路径, 下一部分会定义URL的地址, 在
   发送GET请求时, retrofit会将GET的参数和服务器拼接.
   后面会在该接口中实现其他的POST和GET函数.

   *注:在retrofit2.0中,要注意GET和POST注解的参数,如果参数以"/"开头,那么在跟base地址拼接时,会将base地址中
   的相对地址全部覆盖掉. 举例: base地址为"http://a/b", GET参数为"/c/d", 那么最后的请求地址为"http://a/c/d",
   因此,如果base地址本身已经是相对地址, 那么GET/POST的参数不能以"/"开头.*

3. 主程序中实现get请求
   #+BEGIN_SRC 
public class MainActivity {
    ....
    public static final String SERVER_URL = "http://10.10.10.10/account";
    private OkHttpClient okHttpClient = new OkHttpClient();
    private Retrofit.Builder builder = new Retrofit.Builder()
	.base_url(SERVER_URL)
	.client(okHttpClient)
	.addConvertFactory(GsonConvertFactory.create());

    Retrofit retrofit = builder.build();
    Client client = retrofit.create(Client.class);
    Client call = client.getUsers();
    List<Users> result = call.execute().body();
    ....
}
   
   #+END_SRC
   上述代码用来做实际的请求动作, 首先通过Retrofit Builder来基于各种参数(服务器地址, httpclient, converter)
   生成一个builder对象, 让后调用builder的build()函数生成一个retrofit对象.
   
   接着,调用retrofit的create()函数,传入上一步中定义的接口作为参数来实例化一个具体的接口对象, 然后调用
   该对象的具体http请求函数(这里为getUsers())来实现http请求. 请求的结果是Json数据,会通过GsonConverter转化为具体的
   对象(即User). 由于是多个对象,所以需要放到一个List中.

上述三步即为retrofit的基本使用方法.
* test
** test2
