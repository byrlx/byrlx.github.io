#+OPTIONS: num:nil
#+OPTIONS: ^:nil
#+OPTIONS: H:nil
#+OPTIONS: toc:nil
#+AUTHOR: Zhengchao Xu
#+EMAIL: xuzhengchaojob@gmail.com

#+BEGIN_HTML
---
layout: post
title: Square开源系列(2) Retrofit 项目 
tag: [Java, Android, Square]
description: [retrofit源码阅读笔记]
---
#+END_HTML

未完成!!!

该项目官网 [[http://square.github.io/retrofit/]], github地址: [[https://github.com/square/retrofit]]

* 项目介绍
官网对retrofit介绍是这是一个"类型安全(type-safe)"的Android/Java http客户端. 
目前retrofit的最新正式版本为1.9.0. 2.0版本预计2015年底发布, 相较于之前版本, 
2.0版本在架构上做了很大改变, 本文代码相关的内容都是基于retrofit2.0.

/注: 在编程语言的语法中, type-safe通常指编译器在编译时检查变量的类型, 如果试图向/
/变量分配一个错误的类型,编译器就会报错./

* 在项目中使用retrofit
+ Maven
  #+BEGIN_SRC xml
<dependency>
  <groupId>com.squareup.retrofit</groupId>
  <artifactId>retrofit</artifactId>
  <version>2.0.0-beta2</version>
</dependency>
  #+END_SRC
+ Gradle
  #+BEGIN_SRC 
 compile 'com.squareup.retrofit:retrofit:2.0.0-beta2' 
  #+END_SRC
+ 混淆配置
  如果项目中使用混淆的话, 需要在混淆文件中假如如下配置
  #+BEGIN_SRC 
-dontwarn retrofit.**
-keep class retrofit.** { *; }
-keepattributes Signature
-keepattributes Exceptions
  
  #+END_SRC
* 程序示例
  这部分从一个简单的程序开始, 展示retrofit的使用,并通过对这个程序的进一步介绍retrofit的各种功能.
** 一个简单的retrofit程序
   场景:通过GET请求向服务器返回用户信息, 服务器通过Json格式返回一个或多个用户的信息.基于这个例子
介绍一下retrofit的使用步骤:
1. 用户代码
   #+BEGIN_SRC java
public class User {
    private int id;
    private String name;
    private int age;
}
#+END_SRC
   这段代码定义了用户类User, 每个用户包含三个基本信息:id, name, age;
2. 定义Client和GET请求接口
   #+BEGIN_SRC java
public interface Client {
    @GET("users")
    Call<List<User>>  getUsers();
}
#+END_SRC
   这段代码定义了一个接口Client, 并定义了一个GET函数getUsers(), 该函数用户向服务器发送get请求获取所有的
   用户信息. 定义GET请求需要用GET注解来修饰函数, 注解的参数为uri的相对路径, 下一部分会定义URL的地址, 在
   发送GET请求时, retrofit会将GET的参数和服务器拼接.
   后面会在该接口中实现其他的POST和GET函数.

   *注:在retrofit2.0中,要注意GET和POST注解的参数,如果参数以"/"开头,那么在跟base地址拼接时,会将base地址中
   的相对地址全部覆盖掉. 举例: base地址为"http://a/b", GET参数为"/c/d", 那么最后的请求地址为"http://a/c/d",
   因此,如果base地址本身已经是相对地址, 那么GET/POST的参数不能以"/"开头.*
   
3. 主程序中实现get请求
   #+BEGIN_SRC 
public class MainActivity {
    ....
    public static final String SERVER_URL = "http://10.10.10.10/account";
    private OkHttpClient okHttpClient = new OkHttpClient();
    private Retrofit.Builder builder = new Retrofit.Builder()
	.base_url(SERVER_URL)
	.client(okHttpClient)
	.addConvertFactory(GsonConvertFactory.create());

    Retrofit retrofit = builder.build();
    Client client = retrofit.create(Client.class);
    Client call = client.getUsers();
    List<Users> result = call.execute().body();
    ....
}
   
   #+END_SRC
   上述代码用来做实际的请求动作, 首先通过Retrofit Builder来基于各种参数(服务器地址, httpclient, converter)
   生成一个builder对象, 让后调用builder的build()函数生成一个retrofit对象.
   
   接着,调用retrofit的create()函数,传入上一步中定义的接口作为参数来实例化一个具体的接口对象, 然后调用
   该对象的具体http请求函数(这里为getUsers())来实现http请求. 请求的结果是Json数据,会通过GsonConverter转化为具体的
   对象(即User). 由于是多个对象,所以需要放到一个List中.

上述三步即为retrofit的基本使用方法.(htt
** 创建一个Service generator类
参考自 [[https://futurestud.io/blog/retrofit-getting-started-and-android-client/]].

如果项目中*针对同一个server地址*需要创建多个Retrofit Interface service,那么可以创建一个通用的ServiceGenerator类
来生成service实例.

#+BEGIN_SRC java
public class ServiceGenerator {
    public static final String BASE_URL = "";

    private static OkHttpClient httpClient = new OkHttpClient();
    private static Retrofit.Builder builder =
	new Retrofit.Builder()
	.baseUrl(BASE_URL)
	.addConverterFactory(GsonConverterFactory.create());

    public static <T> T createService(Class<T> serviceClass){
        //把设置client放到这里是因为后续有对client进行配置的需求
	Retrofit retrofit = builder.client(httpClient).build(); 
	return retrofit.create(serviceClass);
    }
				      
}

#+END_SRC

这样在上一节的MainActivity中,可以直接使用ServiceGenerator来创建Client实例

#+BEGIN_SRC java

    Client client = ServiceGenerator.create(Client.class);
    Client call = client.getUsers();
    List<Users> result = call.execute().body();

#+END_SRC
** 扩展ServiceGenerator类
上一节创建了一个基本的ServiceGenerator类, 因为Http请求的丰富多样性, 
可以通过扩展该类加入更多的Http请求功能.

*** 帐号密码认证
帐号密码是一种常见的认证方式, 通常将其加密后以放入到http头部的Authorization中
进行请求认证.通过对OkHttpClient进行配置可以在retrofit中实现该方式. 

#+BEGIN_SRC java
    public static <T> T createService(Class<T> serviceClass){
	createService(serviceClass, null, null);
    }

    pubic static <T> T createService(Class<T> serviceCls, String userName, String passWord)  {
	if (userName != null && passWord != null) {
	    //对用户名和密码进行加密(不同的需求加密方式不一样, 这里只提供参考)
	    String credentials = userName + ":" + passWord;
	    final String base64Str = Base64.encodeToString(credentials.getBytes(), Base64.NO_WRAP);

	    httpClient.interceptors().clear();
	    httpClient.interceptors().add(new Interceptor() {
		    @Override
		    public Response intercept(Interceptor.Chain chain) throws IOException {
			Request original = chain.request();

			Request.Builder requestBuilder = original.newBuilder()
			    .header("Authorization", basic);
                        .header("Accept", "applicaton/json");
                        .method(original.method(), original.body());

			Request request = requestBuilder.build();
			return chain.proceed(request);
		    }
		});
	}

	Retrofit retrofit = builder.client(httpClient).build();
	return retrofit.create(serverClass);
    }
#+END_SRC

上述代码通过修改OkHttpClient的相关参数来修改API请求的头部, 讲加密后的帐号和密码放入到
Authorization中实现验证.

注: Interceptors是属于OkHttp的相关内容, 这部分在后面学习OkHttp时会介绍.

*** OAuth认证接口
整合过第三方API的同学肯定对OAuth接口不陌生, 大部分情况下你都需要去第三方开发者
平台注册你的app去获取一个id和secret, 这样才可以访问第三方的接口.

注: 关于oauth的介绍可以参考阮一峰老师的文章 [[http://www.ruanyifeng.com/blog/2014/05/oauth_2_0.html][理解OAuth2.0]].
