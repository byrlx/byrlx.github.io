#+OPTIONS: num:nil
#+OPTIONS: ^:nil
#+OPTIONS: H:nil
#+OPTIONS: toc:nil
#+AUTHOR: Zhengchao Xu
#+EMAIL: xuzhengchaojob@gmail.com

#+BEGIN_HTML
---
layout: post
title: Square开源系列(3) Retrofit 源码解读 
tag: [Java, Android, Square]
description: [retrofit源码阅读笔记]
---
#+END_HTML

(持续更新)

不了解Retrofit的人可以先参考这篇介绍文章 [[http://byrlx.github.io/2015-11/retrofit/]]

* 使用Retrofit的一般步骤.
在[[http://byrlx.github.io/2015-11/retrofit/][这篇]] 文章里我们创建了一个最简单的Retrofit程序, 定义了一个用户GET请求的Service Client, 
并通过Retrofit来创建一个Client实例, 来实现具体的HTTP请求, 并将请求的结果转化为User对象.
所以一般来说, 使用retrofit的通常步骤为:
1. 创建一个Retrofit实例.
2. 调用retrofit的create()函数创建一个接口的具体对象.
   接口为用户自定义的HTTP接口类, 并将其作为参数传递给create().
3. 用2生成的对象调用其定义的http请求函数.该函数返回一个Call对象.
4. 执行上一步返回的call对象的execute().body()获取http结果, 该结果返回的是对象.
* 从示例代码入手追溯底层实现
** Retrofit类
Retrofit的一个超好用的特点就是高度封装性:我们只需定义一个抽象接口和一系列抽象的请求函数, 
retrofit就可以为我们生成一个该接口的具体类, 然后我们就可以用自己定义的接口函数实现具体的
Http请求, 而无需关心具体http的实现, 这些retrofit都帮我们做了. 下面看一下这个类的代码:
1. 内部Builder类
   Retrofit使用了Builder设计模式, 不能直接通过 "new Retrofit()" 来创建一个
   retrofit对象, 而是需要调用其内部类Builder的build函数.
   #+BEGIN_SRC java
   
  public static final class Builder {
    private OkHttpClient client;
    private BaseUrl baseUrl;
    private List<Converter.Factory> converterFactories = new ArrayList<>();
    private List<CallAdapter.Factory> adapterFactories = new ArrayList<>();
    private Executor callbackExecutor;
    private boolean validateEagerly;

    public Builder() {
      // Add the built-in converter factory first. This prevents overriding its behavior but also
      // ensures correct behavior when using converters that consume all types.
      converterFactories.add(new BuiltInConverters());
    }

    /** The HTTP client used for requests. */
    public Builder client(OkHttpClient client) {
      this.client = checkNotNull(client, "client == null");
      return this;
    }

    /** API base URL. */
    public Builder baseUrl(String baseUrl) {
      checkNotNull(baseUrl, "baseUrl == null");
      HttpUrl httpUrl = HttpUrl.parse(baseUrl);
      if (httpUrl == null) {
        throw new IllegalArgumentException("Illegal URL: " + baseUrl);
      }
      return baseUrl(httpUrl);
    }

    /** API base URL. */
    public Builder baseUrl(final HttpUrl baseUrl) {
      checkNotNull(baseUrl, "baseUrl == null");
      return baseUrl(new BaseUrl() {
        @Override public HttpUrl url() {
          return baseUrl;
        }
      });
    }

    /** API base URL. */
    public Builder baseUrl(BaseUrl baseUrl) {
      this.baseUrl = checkNotNull(baseUrl, "baseUrl == null");
      return this;
    }

    /** Add converter factory for serialization and deserialization of objects. */
    public Builder addConverterFactory(Converter.Factory converterFactory) {
      converterFactories.add(checkNotNull(converterFactory, "converterFactory == null"));
      return this;
    }

    /**
     * TODO
     */
    public Builder addCallAdapterFactory(CallAdapter.Factory factory) {
      adapterFactories.add(checkNotNull(factory, "factory == null"));
      return this;
    }

    /**
     * The executor on which {@link Callback} methods are invoked when returning {@link Call} from
     * your service method.
     */
    public Builder callbackExecutor(Executor callbackExecutor) {
      this.callbackExecutor = checkNotNull(callbackExecutor, "callbackExecutor == null");
      return this;
    }

    /**
     * When calling {@link #create} on the resulting {@link Retrofit} instance, eagerly validate
     * the configuration of all methods in the supplied interface.
     */
    public Builder validateEagerly() {
      validateEagerly = true;
      return this;
    }

    /** Create the {@link Retrofit} instances. */
    public Retrofit build() {
      if (baseUrl == null) {
        throw new IllegalStateException("Base URL required.");
      }

      OkHttpClient client = this.client;
      if (client == null) {
        client = new OkHttpClient();
      }

      // Make a defensive copy of the adapters and add the default Call adapter.
      List<CallAdapter.Factory> adapterFactories = new ArrayList<>(this.adapterFactories);
      adapterFactories.add(Platform.get().defaultCallAdapterFactory(callbackExecutor));

      // Make a defensive copy of the converters.
      List<Converter.Factory> converterFactories = new ArrayList<>(this.converterFactories);

      return new Retrofit(client, baseUrl, converterFactories, adapterFactories, callbackExecutor,
          validateEagerly);
    }
  }
   #+END_SRC
   这是一个典型的Builder模式, Builder类内部定义和Retrofit相同的变量, 
   并且其每一个setter()函数都会返回this. 最后通过build()函数new一个Retrofit
   对象并返回.

   *注*: 从代码中可以看到, 如果在builder中没有主动传入OkHttpClient的话,
   Builder会创建一个默认的OkHttpClient.
2. create()函数
   该函数是Retrofit的 *精华*, 通过它, 我们可以将自定义的接口转化为一个具体的
   该接口的对象.
   #+BEGIN_SRC java
  public <T> T create(final Class<T> service) {
    Utils.validateServiceInterface(service);
    if (validateEagerly) {
      eagerlyValidateMethods(service);
    }
    return (T) Proxy.newProxyInstance(service.getClassLoader(), new Class<?>[] { service },
        new InvocationHandler() {
          private final Platform platform = Platform.get();

          @Override public Object invoke(Object proxy, Method method, Object... args)
              throws Throwable {
            // If the method is a method from Object then defer to normal invocation.
            if (method.getDeclaringClass() == Object.class) {
              return method.invoke(this, args);
            }
            if (platform.isDefaultMethod(method)) {
              return platform.invokeDefaultMethod(method, service, proxy, args);
            }
            return loadMethodHandler(method).invoke(args);
          }
        });
  }
   #+END_SRC
   上面的代码就是retrofit的实现, 代码比较短, 首先是调用validateServiceInterface()
   来检查传入的类变量是否合法:
   #+BEGIN_SRC 
  static <T> void validateServiceInterface(Class<T> service) {
    if (!service.isInterface()) {
      throw new IllegalArgumentException("API declarations must be interfaces.");
    }
    // Prevent API interfaces from extending other interfaces. This not only avoids a bug in
    // Android (http://b.android.com/58753) but it forces composition of API declarations which is
    // the recommended pattern.
    if (service.getInterfaces().length > 0) {
      throw new IllegalArgumentException("API interfaces must not extend other interfaces.");
    }
  }   
   #+END_SRC
   这里检查的地方有两个: 1, 传入的参数必须为一个interface类型. 2, 传入的参数
   没有实现其他interface.
   
   参数合法性检查完之后, 会条件性的执行eagerlyValidateMethods(), 这里先略过.
   接下来是调用Proxy的newProxyInstance()函数为传入的参数生成动态代理. 
   动态代理机制是Java的一个高级特性, 其主要功能就是可以为委托类对象生成代理类,
   代理类可以将所有的方法调用分派到委托对象上反射执行. 动态代理的相关知识可参考
   相关的Java书籍. 这里传入newProxyInstance()有三个参数: 1, 接口的classLoader. 2, 
   只包含接口的class数组. 3, 自定义的InvocationHandler()对象, 该对象实现了invoke()
   函数, 通常在该函数中实现对委托类函数的访问. 所以从create函数可以看出, *其实该函数
   返回的是一个动态代理类对象(被转化成了我们自定义的接口), 当我们调用该接口的自定义
   函数时, 我们调用的实际是invoke()函数.* 而要执行的方法被当作参数传给了invoke.

   下面看下invoke()函数的具体实现:
   + 判断要调用的方法是否是object类的方法(每个类都有), 如果是则直接在当前
     类上调用.
   + 如果是平台的默认方法, 调用platform的相关函数(目前这段代码不会走到)
   + 否则, 调用loadMethodHandler()函数返回值的的invoke()方法实现函数调用.
     这个方法就是retrofit替我们实现Http请求的地方.
3. loadMethodHandler()函数
   #+BEGIN_SRC java 
  MethodHandler<?> loadMethodHandler(Method method) {
    MethodHandler<?> handler;
    synchronized (methodHandlerCache) {
      handler = methodHandlerCache.get(method);
      if (handler == null) {
        handler = MethodHandler.create(this, method);
        methodHandlerCache.put(method, handler);
      }
    }
    return handler;
  }   
   #+END_SRC
   这个函数的实现比较简单, 就是从cache中寻找调用函数的MethodHandler, 如果找到就
   返回, 否则创建一个新的返回. 下面就看下这个类的实现.
** MethodHandler类
在上一小节说过, 我们通过retrofit.create()创造出一个自定义接口的实例,
然后调用实例方法实际上最后是对MethodHandler的invoke()函数的调用, 这一节
就具体看一下这个类及相关方法的具体实现.
1. 对象创建
   该类的构造函数为私有函数, 所以只能通过静态函数create()来创造一个Methodhandler
   对象.
   #+BEGIN_SRC java
final class MethodHandler<T> {
  @SuppressWarnings("unchecked")
  static MethodHandler<?> create(Retrofit retrofit, Method method) {
    CallAdapter<Object> callAdapter = (CallAdapter<Object>) createCallAdapter(method, retrofit);
    Type responseType = callAdapter.responseType();
    Converter<ResponseBody, Object> responseConverter =
        (Converter<ResponseBody, Object>) createResponseConverter(method, retrofit, responseType);
    RequestFactory requestFactory = RequestFactoryParser.parse(method, responseType, retrofit);
    return new MethodHandler<>(retrofit, requestFactory, callAdapter, responseConverter);
  }
  ...
   #+END_SRC
   该函数首先基于mothod和retrofit创建一个CallAdapter的对象, 然后基于该对象
   创建一个Converter对象, 接着生成一个RequestFactory对象, 然后把这些对象作为
   参数传递给构造函数生成一个MethodHandler实例.
2. 创建CallAdapter实例
   #+BEGIN_SRC java
  private static CallAdapter<?> createCallAdapter(Method method, Retrofit retrofit) {
    Type returnType = method.getGenericReturnType();
    if (Utils.hasUnresolvableType(returnType)) {
      throw Utils.methodError(method,
          "Method return type must not include a type variable or wildcard: %s", returnType);
    }
    if (returnType == void.class) {
      throw Utils.methodError(method, "Service methods cannot return void.");
    }
    Annotation[] annotations = method.getAnnotations();
    try {
      return retrofit.callAdapter(returnType, annotations);
    } catch (RuntimeException e) { // Wide exception range because factories are user code.
      throw Utils.methodError(e, method, "Unable to create call adapter for %s", returnType);
    }
  }   
   #+END_SRC
   首先调用method的getGenericReturnType()获取该函数的返回类型, 如果该类型不能
   被解析或为void, 报错. 然后通过getAnnotations()函数获取我们在定义函数时使用的注解(GET/POST..)
   最后基于返回值和注解调用retrofit的callAdapter()生成对象.
   #+BEGIN_SRC java
 //retrofit.java
 public CallAdapter<?> callAdapter(Type returnType, Annotation[] annotations) {
    return nextCallAdapter(null, returnType, annotations);
  }

  /**
   * Returns the {@link CallAdapter} for {@code returnType} from the available {@linkplain
   * #callAdapterFactories() factories} except {@code skipPast}.
   */
  public CallAdapter<?> nextCallAdapter(CallAdapter.Factory skipPast, Type returnType,
      Annotation[] annotations) {
    checkNotNull(returnType, "returnType == null");
    checkNotNull(annotations, "annotations == null");

    int start = adapterFactories.indexOf(skipPast) + 1;
    for (int i = start, count = adapterFactories.size(); i < count; i++) {
      CallAdapter<?> adapter = adapterFactories.get(i).get(returnType, annotations, this);
      if (adapter != null) {
        return adapter;
      }
    }

     ....
  }
   
   #+END_SRC
   callAdapter函数就是从retrofit的adapterFactories变量中找到与该函数和返回值相关的
   adapter, 如果找不到则报错. 从前面Retrofit的builder代码可以看到, 如果用户没用显示声明
   Adapter的话, 默认会创建一个defaultAdapterFactory的实例加入到adapterFactories中.
3. invoke()函数
   invoke()函数是MethodHandler/对象/的唯一函数, 该函数实际是调用了callAdapter.adapt()
   函数, 该函数的参数为一个OkHttpCall对象, 从这里就可以看成该函数是Http请求的
   实际函数, 后面在看CallAdapter代码会再详细介绍其功能.
   #+BEGIN_SRC java
  Object invoke(Object... args) {
    return callAdapter.adapt(new OkHttpCall<>(retrofit, requestFactory, responseConverter, args));
  }   
   #+END_SRC

** CallAdapter和DefaultCallAdapter
前面的小节讲过, 当我们在程序中定义了一个retrofit接口, 然后通过retrofit.create()
生成一个实例, 并调用该实例的函数时, 会得到一个Call类型的返回值(因此用户自定义的
接口中的函数返回值应该都为Call类型). 对实例函数的调用最终是调用到了retrofit的
callAdapter的adapt()函数. 这个函数(返回Call)是在DefaultCallAdapter中实现的.
1. DefaultCallAdapter
   #+BEGIN_SRC java
final class DefaultCallAdapter implements CallAdapter<Call<?>> {
  static final Factory FACTORY = new Factory() {
    @Override
    public CallAdapter<?> get(Type returnType, Annotation[] annotations, Retrofit retrofit) {
      if (Utils.getRawType(returnType) != Call.class) {
        return null;
      }
      Type responseType = Utils.getCallResponseType(returnType);
      return new DefaultCallAdapter(responseType);
    }
  };

  private final Type responseType;

  DefaultCallAdapter(Type responseType) {
    this.responseType = responseType;
  }

  @Override public Type responseType() {
    return responseType;
  }

  @Override public <R> Call<R> adapt(Call<R> call) {
    return call;
  }
}   
   #+END_SRC
   可以看到该函数返回了一个Call类型的结果, 跟我们在例子中定义的一样.
   
2. CallAdapter
   该类是DefaultCallAdapter的父类, 
   #+BEGIN_SRC java
public interface CallAdapter<T> {
  Type responseType();

  <R> T adapt(Call<R> call);

  interface Factory {
    CallAdapter<?> get(Type returnType, Annotation[] annotations, Retrofit retrofit);
  }
}   
   #+END_SRC
** Call和OkHttpCall
在MethodHandler一节可以看到invoke中调用adapt()函数时传入了一个OkHttpCall类型, 
所以实例中用户调用自定义函数返回的也是一个OkHttpCall类型的结果.

1. Call接口定义
   #+BEGIN_SRC java
   /**
 * An invocation of a Retrofit method that sends a request to a webserver and returns a response.
 * Each call yields its own HTTP request and response pair. Use {@link #clone} to make multiple
 * calls with the same parameters to the same webserver; this may be used to implement polling or
 * to retry a failed call.
 *
 * <p>Calls may be executed synchronously with {@link #execute}, or asynchronously with {@link
 * #enqueue}. In either case the call can be canceled at any time with {@link #cancel}. A call that
 * is busy writing its request or reading its response may receive a {@link IOException}; this is
 * working as designed.
 */
public interface Call<T> extends Cloneable {
  Response<T> execute() throws IOException;
  void enqueue(Callback<T> callback);
  void cancel();
  Call<T> clone();
}
   #+END_SRC
   Call是retrofit定义的一个接口规范, 该类主要用于进行Http请求.
   代码注释阐明了该接口的几个功能和约束:
   + 使用execute()进行同步调用.
   + 使用enqueue()进行异步调用.
   + 无论同步还是异步, 都可以在任何时候使用cancel取消.
   + 使用clone()进行一个功能的多次请求.(例如失败后的轮询).
2. OkHttpCall     
