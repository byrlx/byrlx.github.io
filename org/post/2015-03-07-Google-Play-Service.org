#+OPTIONS: num:nil
#+OPTIONS: ^:nil
#+OPTIONS: toc:nil
#+AUTHOR: Luis404
#+EMAIL: luisxu404@gmail.com

#+BEGIN_HTML
---
layout: post
title: Android项目使用Google Play Service
description: [Notes about how to use google play service]
tag: [Android, Google]
---
#+END_HTML

* 在 Android Studio 中使用 Google Play Service
在 Module 下的 build.gradle 的dependencies 中加入下面的代码.

#+BEGIN_SRC java
compile 'com.google.android.gms:play-services:6.5.87'
#+END_SRC

* 解决引用 GMS 后函数数量超过65K 的问题.
由于整个 GMS 的包非常大,引用后非常容易导致整个应用程序的函数数量超过65K.
所以从 GMS6.5开始,可以有选择性的使用 *部分* API,要这样做, 将上一步中的
build.gradle 改成如下方式.


#+BEGIN_SRC java
compile 'com.google.android.gms:play-services-fitness:6.5.87'
compile 'com.google.android.gms:play-services-wearable:6.5.87'
#+END_SRC

更多可以分类的 API 参考[[https://developer.android.com/google/play-services/setup.html#split]].
* GoogleApiClient
早期的 GMS, 不同的 API 有不同的 client. 在新版的 GMS 中,google 将所有 API
入口都整合到了 GoogleApiClient 中.

可以通过 GoogleApiClient.Builder()/build()方法以及 addApi()/addScope()来初始化一个
 GoogleApiClient 对象.同时应该实现相应的连接回调函数, 这样当你调用 GoogleApiClient.connect()来连接 GMS
 时,无论结果是成功/失败/暂停都会调用相应的回调函数.下面的代码是官方的示例:

#+BEGIN_SRC java
import gms.common.api.*;
import gms.drive.*;
import android.support.v4.app.FragmentActivity;

public class MyActivity extends FragmentActivity
        implements ConnectionCallbacks, OnConnectionFailedListener {
    private GoogleApiClient mGoogleApiClient;

    @Override
    protected void onCreate(Bundle savedInstanceState) {
        super.onCreate(savedInstanceState);

        // Create a GoogleApiClient instance
        mGoogleApiClient = new GoogleApiClient.Builder(this)
                .addApi(Drive.API)
                .addScope(Drive.SCOPE_FILE)
                .addConnectionCallbacks(this)
                .addOnConnectionFailedListener(this)
                .build();
        ...
    }

    @Override
    public void onConnected(Bundle connectionHint) {
        // Connected to Google Play services!
        // The good stuff goes here.
    }

    @Override
    public void onConnectionSuspended(int cause) {
        // The connection has been interrupted.
        // Disable any UI components that depend on Google APIs
        // until onConnected() is called.
    }

    @Override
    public void onConnectionFailed(ConnectionResult result) {
        // This callback is important for handling errors that
        // may occur while attempting to connect with Google.
        //
        // More about this in the next section.
        ...
    }
}
#+END_SRC
* 处理错误
当调用 connect()函数去连接 GMS 时,有可能会失败,这种情况下会调用函数 onConnectionFailed().
并给出一个 ConnectionResult 类型的对象 result.

可以调用result 的 hasSolution()函数查看该错误是否可以 *解决*:
+ 返回 true,表明该错误可解(e.g 登录).可以调用 result 的 startResolutionForResult()函数.
  该函数会启动一个可以解决该问题的 Activity(e.g 登录界面).
+ 返回 false,该错误无法解决. 这时,可以调用 GooglePlayServiceUtil的 getErrorDialog()函数,
  将 error code 穿给它. 可以显示该 dialog 给用户(该 dialog 可能只显示错误信息, 也可能会打开
  相关的 activity(e.g 升级版本)).

上面两种情况的函数调用完成都会触发 activity 的 onActivityResult()函数.

** 避免重复进行错误处理
官方文档还提及了错误处理的特殊情况: 假设你在 Activity 的 onStart()中去调用 connect()来连接
 GMS, 发生了连接失败. 这时候你旋转屏幕, activity 重启, 会再一次的调用 connect()去连接 GMS.
如果再次连接失败, 继续对失败做处理, 就出发生 *重复失败处理*. 这是不必要的.

可以通过设置一个 flag来监控当前是否正在进行错误处理.该 flag 可以在 onSavedInstance() 里存储. 
* 发送请求
基本方法: 构造一个 query对象, 然后调用相关 API 的 query()函数.

#+BEGIN_SRC java
Query query = new Query.Builder()
        .addFilter(Filters.eq(SearchableField.TITLE, filename));
PendingResult result = Drive.DriveApi.query(mGoogleApiClient, query);
#+END_SRC

** 异步请求
对 query()函数返回的 PendingIntent 执行 setResultCall()函数.在该函数里
实现 ResultCallback()接口.
** 同步请求
对 PendingIntent 调用 await()函数知道请求完成. 不要在 UI 线程里做这件事.

#+BEGIN_SRC java
private class GetFileTask extends AsyncTask<String, Void, Void> {
    protected void doInBackground(String filename) {
        Query query = new Query.Builder()
                .addFilter(Filters.eq(SearchableField.TITLE, filename))
                .build();
        // Invoke the query synchronously
        DriveApi.MetadataBufferResult result =
                Drive.DriveApi.query(mGoogleApiClient, query).await();

        // Continue doing other stuff synchronously
        ...
    }
}
#+END_SRC
* Get ADID
对于安装 GMS 的手机来说, 可以通过 ADID 来唯一的标识一台手机.
ADID 是 GMS 中和广告相关的 ID.
 AdvertisingIdClient.Info getAdvertisingIdInfo
