#+OPTIONS: num:nil
#+OPTIONS: ^:nil
#+OPTIONS: H:nil
#+OPTIONS: toc:nil
#+AUTHOR: Zhengchao Xu
#+EMAIL: xuzhengchaojob@gmail.com

#+BEGIN_HTML
---
layout: post
title: 'Retrofit源码1: 为什么写一个interface就可以实现http请求'
tag: [java, android, square]
description: [retrofit源码阅读笔记]
categories: [Java]
---
#+END_HTML

本文学习的retrofit源码版本号: parent-2.0.0.

不了解Retrofit的人可以先参考这篇介绍文章[[http://xuzhengchao.com/java/retrofit.html][Retrofit介绍]], 文章介绍了
如何通过写一个简单的接口, 就可以实现
* 使用Retrofit的一般步骤.
在[[http://byrlx.github.io/2015-11/retrofit/][这篇]] 文章里我们创建了一个最简单的Retrofit程序, 定义了一个用户GET请求的Service Client, 
并通过Retrofit来创建一个Client实例, 来实现具体的HTTP请求, 并将请求的结果转化为User对象.
所以一般来说, 使用retrofit的通常步骤为:
1. 创建一个Retrofit实例.
2. 调用retrofit的create()函数创建一个接口的具体对象.
   接口为用户自定义的HTTP接口类, 并将其作为参数传递给create().
3. 用2生成的对象调用其定义的http请求函数.该函数返回一个Call对象.
4. 执行上一步返回的call对象的execute().body()获取http结果, 该结果返回的是对象.
* 从示例代码入手追溯底层实现
** Retrofit类使用动态代理创建接口代理
Retrofit的一个超好用的特点就是高度封装性:我们只需定义一个抽象接口和一系列抽象的请求函数, 
retrofit就可以为我们生成一个该接口的具体类, 然后我们就可以用自己定义的接口函数实现具体的
Http请求, 而无需关心具体http的实现, 这些retrofit都帮我们做了. 下面看一下这个类的代码:
1. 内部Builder类

   Retrofit使用了Builder设计模式, 不能直接通过 "new Retrofit()" 来创建一个
   retrofit对象, 而是需要调用其内部类Builder的build函数.
   从下面的代码看(实现细节省略), 这是一个典型的Builder模式, Builder类内部定义和Retrofit相同的变量, 
   并且其每一个setter()函数都会返回this. 最后通过build()函数new一个Retrofit
   对象并返回.

   *注*: 从代码中可以看到, 如果在builder中没有主动传入OkHttpClient的话,
   Builder会创建一个默认的OkHttpClient.
   #+BEGIN_SRC java
  public static final class Builder {
    public Builder() {
      converterFactories.add(new BuiltInConverters());
    }

    public Builder client(OkHttpClient client) {...}
    public Builder baseUrl(String baseUrl) {...}
    ...
    public Builder addConverterFactory(Converter.Factory converterFactory) {}
    public Builder addCallAdapterFactory(CallAdapter.Factory factory) {}
    public Builder callbackExecutor(Executor callbackExecutor) {}
    public Builder validateEagerly() {}

    /** Create the {@link Retrofit} instances. */
    public Retrofit build() {
      if (baseUrl == null) {
        throw new IllegalStateException("Base URL required.");
      }

      OkHttpClient client = this.client;
      if (client == null) {
        client = new OkHttpClient();
      }

      // Make a defensive copy of the adapters and add the default Call adapter.
      List<CallAdapter.Factory> adapterFactories = new ArrayList<>(this.adapterFactories);
      adapterFactories.add(Platform.get().defaultCallAdapterFactory(callbackExecutor));

      // Make a defensive copy of the converters.
      List<Converter.Factory> converterFactories = new ArrayList<>(this.converterFactories);

      return new Retrofit(client, baseUrl, converterFactories, adapterFactories, callbackExecutor,
          validateEagerly);
    }
  }
   #+END_SRC
2. create()函数
   该函数是Retrofit的 *精华*, 通过它, 我们可以将自定义的接口转化为一个具体的
   该接口的对象.
   #+BEGIN_SRC java
  public <T> T create(final Class<T> service) {
    Utils.validateServiceInterface(service);
    if (validateEagerly) {
      eagerlyValidateMethods(service);
    }
    return (T) Proxy.newProxyInstance(service.getClassLoader(), new Class<?>[] { service },
        new InvocationHandler() {
          private final Platform platform = Platform.get();

          @Override public Object invoke(Object proxy, Method method, Object... args)
              throws Throwable {
            // If the method is a method from Object then defer to normal invocation.
            if (method.getDeclaringClass() == Object.class) {
              return method.invoke(this, args);
            }
            if (platform.isDefaultMethod(method)) {
              return platform.invokeDefaultMethod(method, service, proxy, args);
            }
            return loadMethodHandler(method).invoke(args);
          }
        });
  }
   #+END_SRC
   上面的代码就是retrofit的实现, 代码比较短, 首先是调用validateServiceInterface()
   来检查传入的类变量是否合法:
   #+BEGIN_SRC  java
  static <T> void validateServiceInterface(Class<T> service) {
    if (!service.isInterface()) {
      throw new IllegalArgumentException("API declarations must be interfaces.");
    }
    if (service.getInterfaces().length > 0) {
      throw new IllegalArgumentException("API interfaces must not extend other interfaces.");
    }
  }   
   #+END_SRC
   这里检查的地方有两个: 1, 传入的参数必须为一个interface类型. 2, 传入的参数
   没有实现其他interface.
   
   参数合法性检查完之后, 会条件性的执行eagerlyValidateMethods(), 这里先略过.
   接下来是调用Proxy的newProxyInstance()函数为传入的参数生成动态代理. 
   动态代理机制是Java的一个高级特性, 其主要功能就是可以为委托类对象生成代理类,
   代理类可以将所有的方法调用分派到委托对象上反射执行. 动态代理的相关知识可参考
   相关的Java书籍. 这里传入newProxyInstance()有三个参数: 1, 接口的classLoader. 2, 
   只包含接口的class数组. 3, 自定义的InvocationHandler()对象, 该对象实现了invoke()
   函数, 通常在该函数中实现对委托类函数的访问. 所以从create函数可以看出, *其实该函数
   返回的是一个动态代理类对象(被转化成了我们自定义的接口), 当我们调用该接口的自定义
   函数时, 我们调用的实际是invoke()函数.* 而要执行的方法被当作参数传给了invoke.

   下面看下invoke()函数的具体实现:
   + 判断要调用的方法是否是object类的方法(每个类都有), 如果是则直接在当前
     类上调用.
   + 如果是平台的默认方法, 调用platform的相关函数(目前这段代码不会走到)
   + 否则, 调用loadMethodHandler()函数返回值的的invoke()方法实现函数调用.
     这个方法就是retrofit替我们实现Http请求的地方.
3. loadMethodHandler()函数
   #+BEGIN_SRC java 
  MethodHandler<?> loadMethodHandler(Method method) {
    MethodHandler<?> handler;
    synchronized (methodHandlerCache) {
      handler = methodHandlerCache.get(method);
      if (handler == null) {
        handler = MethodHandler.create(this, method);
        methodHandlerCache.put(method, handler);
      }
    }
    return handler;
  }   
   #+END_SRC
   这个函数的实现比较简单, 就是从cache中寻找调用函数的MethodHandler, 如果找到就
   返回, 否则创建一个新的返回. 下面就看下这个类的实现.
** MethodHandler类实现接口函数调用
在上一小节说过, 我们通过retrofit.create()创造出一个自定义接口的实例,
然后调用实例方法实际上最后是对MethodHandler的invoke()函数的调用, 这一节
就具体看一下这个类及相关方法的具体实现.
1. 对象创建.
   #+BEGIN_SRC java
final class MethodHandler<T> {
  @SuppressWarnings("unchecked")
  static MethodHandler<?> create(Retrofit retrofit, Method method) {
    CallAdapter<Object> callAdapter = (CallAdapter<Object>) createCallAdapter(method, retrofit);
    Type responseType = callAdapter.responseType();
    Converter<ResponseBody, Object> responseConverter =
        (Converter<ResponseBody, Object>) createResponseConverter(method, retrofit, responseType);
    RequestFactory requestFactory = RequestFactoryParser.parse(method, responseType, retrofit);
    return new MethodHandler<>(retrofit, requestFactory, callAdapter, responseConverter);
  }
  ...
   #+END_SRC
   该类的构造函数为私有函数, 所以只能通过静态函数create()来创造一个Methodhandler
   对象.该函数首先基于mothod和retrofit创建一个CallAdapter的对象, 然后基于该对象
   创建一个Converter对象, 接着生成一个RequestFactory对象, 然后把这些对象作为
   参数传递给构造函数生成一个MethodHandler实例.
2. 创建CallAdapter实例
   #+BEGIN_SRC java
  private static CallAdapter<?> createCallAdapter(Method method, Retrofit retrofit) {
    Type returnType = method.getGenericReturnType();
    if (Utils.hasUnresolvableType(returnType)) {
      throw Utils.methodError(method,
          "Method return type must not include a type variable or wildcard: %s", returnType);
    }
    if (returnType == void.class) {
      throw Utils.methodError(method, "Service methods cannot return void.");
    }
    Annotation[] annotations = method.getAnnotations();
    try {
      return retrofit.callAdapter(returnType, annotations);
    } catch (RuntimeException e) { // Wide exception range because factories are user code.
      throw Utils.methodError(e, method, "Unable to create call adapter for %s", returnType);
    }
  }   
   #+END_SRC
   首先调用method的getGenericReturnType()获取该函数的返回类型, 如果该类型不能
   被解析或为void, 报错. 然后通过getAnnotations()函数获取我们在定义函数时使用的注解(GET/POST..)
   最后基于返回值和注解调用retrofit的callAdapter()生成对象.
   #+BEGIN_SRC java
 //retrofit.java
 public CallAdapter<?> callAdapter(Type returnType, Annotation[] annotations) {
    return nextCallAdapter(null, returnType, annotations);
  }

  public CallAdapter<?> nextCallAdapter(CallAdapter.Factory skipPast, Type returnType,
      Annotation[] annotations) {
    checkNotNull(returnType, "returnType == null");
    checkNotNull(annotations, "annotations == null");

    int start = adapterFactories.indexOf(skipPast) + 1;
    for (int i = start, count = adapterFactories.size(); i < count; i++) {
      CallAdapter<?> adapter = adapterFactories.get(i).get(returnType, annotations, this);
      if (adapter != null) {
        return adapter;
      }
    }
     ....
  }
   
   #+END_SRC
   callAdapter函数就是从retrofit的adapterFactories变量中找到与该函数和返回值相关的
   adapter, 如果找不到则报错. 从前面Retrofit的builder代码可以看到, 如果用户没用显示声明
   Adapter的话, 默认会创建一个defaultAdapterFactory的实例加入到adapterFactories中.
3. invoke()函数
   invoke()函数是MethodHandler/对象/的唯一函数, 该函数实际是调用了callAdapter.adapt()
   函数, 该函数的参数为一个OkHttpCall对象, 从这里就可以看成该函数是Http请求的
   实际函数, 后面在看CallAdapter代码会再详细介绍其功能.
   #+BEGIN_SRC java
  Object invoke(Object... args) {
    return callAdapter.adapt(new OkHttpCall<>(retrofit, requestFactory, responseConverter, args));
  }   
   #+END_SRC

** CallAdapter和DefaultCallAdapter
前面的小节讲过, 当我们在程序中定义了一个retrofit接口, 然后通过retrofit.create()
生成一个实例, 并调用该实例的函数时, 会得到一个Call类型的返回值(因此用户自定义的
接口中的函数返回值应该都为Call类型). 对实例函数的调用最终是调用到了retrofit的
callAdapter的adapt()函数. 这个函数(返回Call)是在DefaultCallAdapter中实现的.
1. DefaultCallAdapter
   #+BEGIN_SRC java
final class DefaultCallAdapter implements CallAdapter<Call<?>> {
  static final Factory FACTORY = new Factory() {
    @Override
    public CallAdapter<?> get(Type returnType, Annotation[] annotations, Retrofit retrofit) {
      if (Utils.getRawType(returnType) != Call.class) {
        return null;
      }
      Type responseType = Utils.getCallResponseType(returnType);
      return new DefaultCallAdapter(responseType);
    }
  };

  private final Type responseType;

  DefaultCallAdapter(Type responseType) {
    this.responseType = responseType;
  }

  @Override public Type responseType() {
    return responseType;
  }

  @Override public <R> Call<R> adapt(Call<R> call) {
    return call;
  }
}   
   #+END_SRC
   可以看到adapt()函数返回了一个Call类型的结果, 跟我们在例子中定义的一样.
   DefaultCallAdapter的父类是CallAdapter. 所以如果要实现自己的Adapter, 同样
   需要继承此类.
** Call和OkHttpCall 实现真正请求
在MethodHandler一节可以看到invoke中调用adapt()函数时传入了一个OkHttpCall类型, 
所以实例中用户调用自定义函数返回的也是一个OkHttpCall类型的结果.

1. Call接口定义.
   Call是retrofit定义的一个接口规范, 该类主要用于进行Http请求.
   代码注释阐明了该接口的几个功能和约束:
   + 使用execute()进行同步调用.
   + 使用enqueue()进行异步调用.
   + 无论同步还是异步, 都可以在任何时候使用cancel取消.
   + 使用clone()进行一个功能的多次请求.(例如失败后的轮询).
   #+BEGIN_SRC java
public interface Call<T> extends Cloneable {
  Response<T> execute() throws IOException;
  void enqueue(Callback<T> callback);
  void cancel();
  Call<T> clone();
}
   #+END_SRC
2. OkHttpCall.    
   OkHttpCall是基于OkHttp的Call接口的一个实现, 可以通过这个类看一下具体它是怎样
   遵循Call接口的规范的. 下面是其几个主要函数的实现:
   + execute().
     #+BEGIN_SRC java
  public Response<T> execute() throws IOException {
    synchronized (this) {
      if (executed) throw new IllegalStateException("Already executed");
      executed = true;
    }

    com.squareup.okhttp.Call rawCall = createRawCall();
    if (canceled) {
      rawCall.cancel();
    }
    this.rawCall = rawCall;

    return parseResponse(rawCall.execute());
  }     
     #+END_SRC
     前面讲过该函数是Call的同步请求函数, 直接返回请求结果. 从代码中可以看出.
     由于executed变量被设为true后其值一直不变, 所以execute的"请求"代码只会
     执行一次. 该函数使用了OkHttp的Call类来执行具体的执行动作. 最后调用
     parseResponse()处理请求结果.
   + enqueue().
     该函数是Call的异步请求函数, 需要向该函数传递一个Callback类型的参数.Callback是一个
     接口, 提供了两个函数onResponse()表示成功, onFailure()表示失败.
     在Android中,这两个函数需要在UI线程中执行.
     #+BEGIN_SRC java
public interface Callback<T> {
  /** Successful HTTP response. */
  void onResponse(Response<T> response, Retrofit retrofit);

  /** Invoked when a network or unexpected exception occurred during the HTTP request. */
  void onFailure(Throwable t);
}
     #+END_SRC

     在enqueue()中创建了一个com.squareup.okhttp.Call实例,
     http请求动作实际是这个实例的enqueue()函数来执行的.
     #+BEGIN_SRC java
@Override public void enqueue(final Callback<T> callback) {
    synchronized (this) {
      if (executed) throw new IllegalStateException("Already executed");
      executed = true;
    }

    com.squareup.okhttp.Call rawCall;
    try {
      rawCall = createRawCall();
    } catch (Throwable t) {
      callback.onFailure(t);
      return;
    }
    ...
    rawCall.enqueue(new com.squareup.okhttp.Callback() {
      private void callFailure(Throwable e) {
        try {
          callback.onFailure(e);
        } catch (Throwable t) {
          t.printStackTrace();
        }
      }

      private void callSuccess(Response<T> response) {
        try {
          callback.onResponse(response, retrofit);
        } catch (Throwable t) {
          t.printStackTrace();
        }
      }

      @Override public void onFailure(Request request, IOException e) {
        callFailure(e);
      }

      @Override public void onResponse(com.squareup.okhttp.Response rawResponse) {
        Response<T> response;
        try {
          response = parseResponse(rawResponse);
        } catch (Throwable e) {
          callFailure(e);
          return;
        }
        callSuccess(response);
      }
    });
} 
     #+END_SRC
   + cancel(). 
     取消请求, 实际是调用com.squareup.okhttp.Call的cancel()函数.
   + clone().
     由于一个对象只能执行一次请求, 所以同一请求的多次执行, 需要通过clone()来
     复制, 该函数实际上是创建了一个新的OkHttpCall对象.
   + parseResponse().
     该函数用来将execute()或enqueue()返回的结果转换为一个Response对象并返回, 前面讲到
     实际的请求是由OkHttp完成的, OkHttp请求也是返回一个com.squareup.okhttp.Response的对象, 
     这个函数就是将该对象转换为一个retrofit的Response对象.

     看一下这个函数的代码. 首先调用response的body()函数获取一个ResponseBody类型,
     然后基于response的contentType和length生成一个新的rawResponse. 
     #+BEGIN_SRC java
     ResponseBody rawBody = rawResponse.body();

    // Remove the body's source (the only stateful object) so we can pass the response along.
    rawResponse = rawResponse.newBuilder()
        .body(new NoContentResponseBody(rawBody.contentType(), rawBody.contentLength()))
        .build();

    int code = rawResponse.code();
    if (code < 200 || code >= 300) {
      try {
        // Buffer the entire body to avoid future I/O.
        ResponseBody bufferedBody = Utils.readBodyToBytesIfNecessary(rawBody);
        return Response.error(bufferedBody, rawResponse);
      } finally {
        closeQuietly(rawBody);
      }
    }

     #+END_SRC

     接着处理"错误"返回和无内容的成功返回. 对于小于200或大于300的"错误码", 会先
     尝试生成一个errBody, 然后返回一个"携带错误内容"的Response. 204或205的状态码
     表示请求成功但无返回内容, 会简单调用success函数返回一个成功的Response.
     Response是retrofit的请求结果类, 后面会介绍.
     #+BEGIN_SRC java
    int code = rawResponse.code();
    if (code < 200 || code >= 300) {
      try {
        // Buffer the entire body to avoid future I/O.
        ResponseBody bufferedBody = Utils.readBodyToBytesIfNecessary(rawBody);
        return Response.error(bufferedBody, rawResponse);
      } finally {
        closeQuietly(rawBody);
      }
    }

    if (code == 204 || code == 205) {
      return Response.success(null, rawResponse);
    }

//error和success的代码
  public static <T> Response<T> success(T body, com.squareup.okhttp.Response rawResponse) {
    return new Response<>(rawResponse, body, null);
  }

  public static <T> Response<T> error(ResponseBody body, com.squareup.okhttp.Response rawResponse) {
    return new Response<>(rawResponse, null, body);
  }     
     #+END_SRC

     如果状态码不在这两个范围, 则尝试处理body并将其转化为最终我们需要的类型.
     代码中的responseConverter就是我们在示例中构建retrofit时通过调用
     addConverterFactory()传入的converter. 
     所以如果我们传回的结果为一个类的json表示, 就可以通过这个函数传入一个GsonConverter.
     它就会自动将返回内容转换为结果类型对象并存放到Response的body中.
     我们直接调用body()函数就可有获得这个结果.
     #+BEGIN_SRC java
    ExceptionCatchingRequestBody catchingBody = new ExceptionCatchingRequestBody(rawBody);
    try {
      T body = responseConverter.convert(catchingBody);
      return Response.success(body, rawResponse);
    } catch (RuntimeException e) {
      catchingBody.throwIfCaught();
      throw e;
    }
     #+END_SRC
** Request相关类处理请求
在retrofit示例中讲到,使用retrofit一般首先要定义了一个接口,
并在接口里用retrofit提供的注解定义了一系列请求函数. 下面的
代码展示一个基本的接口和函数定义, 通过注解可以看出, 该函数
是一个POST请求, 并使用了表单, 定义了属性user和pass,
这两个属性的值通过函数参数传进来. 
#+BEGIN_SRC java
public interface CHHttpService {
    @FormUrlEncoded
    @POST("/p/checkState.do")
    Call<CHIMEI>  checkState(@Field("user") String user, @Field("pass") String pass);
}
#+END_SRC

这一部分的内容就是讲解retrofit如何通过解析注解来生成一个完整的
OkHttp请求(request). 这一切的入口就是MethodHandler的create()函数中的
一行代码. 
#+BEGIN_SRC  java
  static MethodHandler<?> create(Retrofit retrofit, Method method) {
    ...
    RequestFactory requestFactory = RequestFactoryParser.parse(method, responseType, retrofit);  //<====here
    return new MethodHandler<>(retrofit, requestFactory, callAdapter, responseConverter);
  }
#+END_SRC

*** RequestFactoryParser & RequestFactory
在MethodHandler的create()函数中调用RequestFactoryParser的parse()函数
生成了一个RequestFactory实例, 下面看下这个函数的主要功能.
#+BEGIN_SRC java
  static RequestFactory parse(Method method, Type responseType, Retrofit retrofit) {
    RequestFactoryParser parser = new RequestFactoryParser(method);
    parser.parseMethodAnnotations(responseType);
    parser.parseParameters(retrofit);
    return parser.toRequestFactory(retrofit.baseUrl());
  }
#+END_SRC
该函数先创建一个RequestFactoryParser的实例, 然后调用parseMethodAnnotations()
和parseParameters()两个函数, 从这两个函数的名称上可以看出它们的功能,分别是
处理*接口函数*的注解和参数的注解.最后调用toRequestFactory()生成一个
RequestFactory实例返回. 下面是这两个函数的实现:
+ parseMethodAnnotations().
  该函数通过Method类的getAnnotations()函数返回要解析的函数的所有注解, 然后
  遍历这些注解. 大部分请求相关的注解都调用了parseHttpMethodAndPath()这个函数
  *Headers* 注解调用了parseHeaders()函数. 其他的注解则设置了相关的标志位.
  #+BEGIN_SRC java
   private void parseMethodAnnotations(Type responseType) {
    for (Annotation annotation : method.getAnnotations()) {
      if (annotation instanceof POST) { //同样适用于GET/DELET/HEAD/PATCH/, 第三个参数可能不同
        parseHttpMethodAndPath("POST", ((POST) annotation).value(), true);
      } else if (annotation instanceof Headers) {
        String[] headersToParse = ((Headers) annotation).value();
        if (headersToParse.length == 0) {throw methodError(method, "@Headers annotation is empty.");}
        headers = parseHeaders(headersToParse);
      } else if (annotation instanceof Multipart) {
        if (isFormEncoded) {throw methodError(method, "Only one encoding annotation is allowed.");}
        isMultipart = true;
      } else if (annotation instanceof FormUrlEncoded) {
        if (isMultipart) {throw methodError(method, "Only one encoding annotation is allowed.");}
        isFormEncoded = true;
      }
    }
    ...
  } 
  #+END_SRC
+ parseParameters
  该函数先调用Method的函数geGenericParameterTypes()获取每个参数的类型, 然后
  调用getParameterAnnotations()获取每个参数的注解.然后解析每个注解, 并将解析的
  结果存放到requestBuilderActions变量中.
*** RequestBuilder & RequestBuilderAction
在OkHttpCall类中, 创建一个OkHttp的call实例会传入一个OkHttp的
Request的参数, 这个Request变量是通过调用ReqeustFactory的create()
函数生成的. create()函数首先通过已经处理完成的所有请求参数生成一个
RequestBuilder实例, 然后再进一步处理上一部分还未完成的参数处理, 即
将参数和注解结果结合起来.这个是通过调用RequestBuilderAction的perform()
函数完成的.
#+BEGIN_SRC java
  public Response<T> execute() throws IOException {
    com.squareup.okhttp.Call rawCall = createRawCall();
    return parseResponse(rawCall.execute());
  }
  private com.squareup.okhttp.Call createRawCall() {
    return retrofit.client().newCall(requestFactory.create(args));
  }

  Request create(Object... args) {
    RequestBuilder requestBuilder =
        new RequestBuilder(method, baseUrl.url(), relativeUrl, headers, contentType, hasBody,
            isFormEncoded, isMultipart);

    if (args != null) {
      RequestBuilderAction[] actions = requestBuilderActions;
      if (actions.length != args.length) {throw new IllegalArgumentException("Argument count (" + args.length + ") doesn't match action count (" + actions.length + ")");}
      for (int i = 0, count = args.length; i < count; i++) {
        actions[i].perform(requestBuilder, args[i]);
      }
    }
    return requestBuilder.build();
  }
#+END_SRC
** Response处理返回结果
   Response是execute和enqueue函数的返回值, Reponse的实现思想是:
   如果请求成功并有结果返回, 则尝试将结果转化为最终的类, 
   否则保存OkHttp请求的返回结果(rawResponse)并交给使用者处理.
   Response的实现比较简单, 只有100行代码, 主要的两个函数为success()和
   error(), 这两个函数会生成一个包含请求结果的Response对象, 然后是一系列
   的getter()函数, 用来获取请求结果(头, 状态码, body等...).
   #+BEGIN_SRC java
public final class Response<T> {
  private final com.squareup.okhttp.Response rawResponse;
  private final T body;
  private final ResponseBody errorBody;
  private Response(com.squareup.okhttp.Response rawResponse, T body, ResponseBody errorBody) { ... }

  public static <T> Response<T> success(T body, com.squareup.okhttp.Response rawResponse) {return new Response<>(rawResponse, body, null);}
  public static <T> Response<T> error(ResponseBody body, com.squareup.okhttp.Response rawResponse) {return new Response<>(rawResponse, null, body);}

  public com.squareup.okhttp.Response raw() {return rawResponse;}
  public int code() {return rawResponse.code();}
  public String message() {return rawResponse.message();}
  public Headers headers() {return rawResponse.headers();}
  public boolean isSuccess() {return rawResponse.isSuccessful();}
  public T body() {return body;}
  public ResponseBody errorBody() {return errorBody;}
}
   #+END_SRC
