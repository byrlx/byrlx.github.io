<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
"http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en">
<head>
<!-- 2016-08-17 Wed 07:23 -->
<meta  http-equiv="Content-Type" content="text/html;charset=utf-8" />
<meta  name="viewport" content="width=device-width, initial-scale=1" />
<title>ArrayList, LinkedList源码笔记</title>
<meta  name="generator" content="Org-mode" />
<meta  name="author" content="Zhengchao Xu" />
<link rel="stylesheet" title="Standard" href="/style/worg.css" type="text/css" />
<link rel="alternate stylesheet" title="Zenburn" href="/style/worg-zenburn.css" type="text/css" />
<link rel="alternate stylesheet" title="Classic" href="/style/worg-classic.css" type="text/css" />
<link rel="SHORTCUT ICON" href="/org-mode-unicorn.ico" type="image/x-icon" />
<link rel="icon" href="/org-mode-unicorn.ico" type="image/ico" />
<script type="text/javascript">
/*
@licstart  The following is the entire license notice for the
JavaScript code in this tag.

Copyright (C) 2012-2013 Free Software Foundation, Inc.

The JavaScript code in this tag is free software: you can
redistribute it and/or modify it under the terms of the GNU
General Public License (GNU GPL) as published by the Free Software
Foundation, either version 3 of the License, or (at your option)
any later version.  The code is distributed WITHOUT ANY WARRANTY;
without even the implied warranty of MERCHANTABILITY or FITNESS
FOR A PARTICULAR PURPOSE.  See the GNU GPL for more details.

As additional permission under GNU GPL version 3 section 7, you
may distribute non-source (e.g., minimized or compacted) forms of
that code without the copy of the GNU GPL normally required by
section 4, provided you include this license notice and a URL
through which recipients can access the Corresponding Source.


@licend  The above is the entire license notice
for the JavaScript code in this tag.
*/
<!--/*--><![CDATA[/*><!--*/
 function CodeHighlightOn(elem, id)
 {
   var target = document.getElementById(id);
   if(null != target) {
     elem.cacheClassElem = elem.className;
     elem.cacheClassTarget = target.className;
     target.className = "code-highlighted";
     elem.className   = "code-highlighted";
   }
 }
 function CodeHighlightOff(elem, id)
 {
   var target = document.getElementById(id);
   if(elem.cacheClassElem)
     elem.className = elem.cacheClassElem;
   if(elem.cacheClassTarget)
     target.className = elem.cacheClassTarget;
 }
/*]]>*///-->
</script>
</head>
<body>
<div id="preamble" class="status">
<script type="text/javascript">

  var _gaq = _gaq || [];
  _gaq.push(['_setAccount', 'UA-7691209-1']);
  _gaq.push(['_trackPageview']);

  (function() {
    var ga = document.createElement('script'); ga.type = 'text/javascript'; ga.async = true;
    ga.src = ('https:' == document.location.protocol ? 'https://ssl' : 'http://www') + '.google-analytics.com/ga.js';
    var s = document.getElementsByTagName('script')[0]; s.parentNode.insertBefore(ga, s);
  })();

  document.addEventListener('DOMContentLoaded',function() {
      document.getElementById("table-of-contents").onclick = function() {
          var elem = document.getElementById("text-table-of-contents");
          elem.style.display = elem.style.display == "block" ? "none" : "block";
      }
  });
</script>
</div>
<div id="content">
<h1 class="title">ArrayList, LinkedList源码笔记</h1>
<div id="table-of-contents">
<h2>Table of Contents</h2>
<div id="text-table-of-contents">
<ul>
<li><a href="#orgheadline2">Iterable</a></li>
<li><a href="#orgheadline1">Iterator</a></li>
<li><a href="#orgheadline3">Collection</a></li>
<li><a href="#orgheadline4">List</a></li>
<li><a href="#orgheadline5">ListIterator</a></li>
<li><a href="#orgheadline6">AbstractCollection</a></li>
<li><a href="#orgheadline7">AbstractList</a>
<ul>
<li><a href="#orgheadline8">Itr</a></li>
<li><a href="#orgheadline9">ListItr</a></li>
<li><a href="#orgheadline10">SubList</a></li>
<li><a href="#orgheadline11">RandomAccessSubList</a></li>
</ul>
</li>
<li><a href="#orgheadline12">ArrayList</a></li>
<li><a href="#orgheadline13">AbstractSequentialList</a></li>
<li><a href="#orgheadline14">Deque</a></li>
<li><a href="#orgheadline15">LinkedList</a>
<ul>
<li><a href="#orgheadline16">Node</a></li>
</ul>
</li>
<li><a href="#orgheadline17">SynchronizedList</a></li>
</ul>
</div>
</div>
<p>
最近工作不忙, 抽空看了一下ArrayList和LinkedList的源码. 下面是一些主要知识点的笔记. 
</p>

<div id="outline-container-orgheadline2" class="outline-2">
<h2 id="orgheadline2">Iterable</h2>
<div class="outline-text-2" id="text-orgheadline2">
<p>
实现了Iterable的接口类, 可以使用 "for-loop" 形式的语法. 
例如这里实现一个 Foo 类实现了 Iterable 接口. 那么可以使用
如下代码来操作 Foo 实例.
</p>

<pre class="example">
Foo foo = new Foo();
for(T t : foo ) {//do  something}
</pre>

<p>
该接口的几个主要API:
</p>
<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">


<colgroup>
<col  class="org-left" />

<col  class="org-left" />
</colgroup>
<thead>
<tr>
<th scope="col" class="org-left">名称</th>
<th scope="col" class="org-left">功能</th>
</tr>
</thead>
<tbody>
<tr>
<td class="org-left">interator()</td>
<td class="org-left">返回一个<a href="#orgheadline1">Iterator</a> 实例, 用于实现对Interable接口的"遍历".</td>
</tr>

<tr>
<td class="org-left">forEach(action)</td>
<td class="org-left">接受一个Cousumer类型的参数action, 然后对"遍历"后的每个元素用action做处理.</td>
</tr>
</tbody>
</table>
</div>
</div>

<div id="outline-container-orgheadline1" class="outline-2">
<h2 id="orgheadline1">Iterator</h2>
<div class="outline-text-2" id="text-orgheadline1">
<p>
Iterator是集合的"迭代器", 提供了对集合进行遍历的方法. Iterator一般
都是依附Iterable存在的. <br  />
Iterator提供的API:
</p>

<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">


<colgroup>
<col  class="org-left" />

<col  class="org-left" />
</colgroup>
<thead>
<tr>
<th scope="col" class="org-left">名称</th>
<th scope="col" class="org-left">功能</th>
</tr>
</thead>
<tbody>
<tr>
<td class="org-left">hasNext()</td>
<td class="org-left">判断集合是否还有元素.</td>
</tr>

<tr>
<td class="org-left">next()</td>
<td class="org-left">返回下一个元素.</td>
</tr>

<tr>
<td class="org-left">remove()</td>
<td class="org-left">删除next()返回的元素.</td>
</tr>

<tr>
<td class="org-left">forEachRemaining(action)</td>
<td class="org-left">对集合剩下的元素执行action动作. action的定义与<a href="#orgheadline2">Iterable</a>介绍的相同.</td>
</tr>
</tbody>
</table>
</div>
</div>

<div id="outline-container-orgheadline3" class="outline-2">
<h2 id="orgheadline3">Collection</h2>
<div class="outline-text-2" id="text-orgheadline3">
<p>
Collection是Java"集合"家族的顶层接口, 继承自<a href="#orgheadline2">Iterable</a>.
定义了集合的一些共同特性:
</p>
<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">


<colgroup>
<col  class="org-left" />

<col  class="org-left" />
</colgroup>
<thead>
<tr>
<th scope="col" class="org-left">API名称</th>
<th scope="col" class="org-left">描述</th>
</tr>
</thead>
<tbody>
<tr>
<td class="org-left">size()</td>
<td class="org-left">集合大小</td>
</tr>

<tr>
<td class="org-left">isEmpty()</td>
<td class="org-left">是否为空</td>
</tr>

<tr>
<td class="org-left">contains()</td>
<td class="org-left">是否包含元素</td>
</tr>

<tr>
<td class="org-left">iterator()</td>
<td class="org-left">返回该集合的迭代器</td>
</tr>

<tr>
<td class="org-left">toArray()/toArray(T[] a)</td>
<td class="org-left">集合转化为数组</td>
</tr>

<tr>
<td class="org-left">add(E e)</td>
<td class="org-left">添加元素</td>
</tr>

<tr>
<td class="org-left">remove(E e)</td>
<td class="org-left">删除元素</td>
</tr>

<tr>
<td class="org-left">addAll(c)</td>
<td class="org-left">添加一个Collection</td>
</tr>

<tr>
<td class="org-left">clear()</td>
<td class="org-left">清空整个集合</td>
</tr>
</tbody>
</table>
</div>
</div>
<div id="outline-container-orgheadline4" class="outline-2">
<h2 id="orgheadline4">List</h2>
<div class="outline-text-2" id="text-orgheadline4">
<p>
List是"队列"家族的抽象类, 队列是一种"有先后顺序"的集合, 队列中的元素
有添加的先后顺序, 新元素都会添加到队列尾部.
该类继承自<a href="#orgheadline3">Collection</a>, 除了<a href="#orgheadline3">Collection</a>的特性, 该类的其他主要特性包括:
</p>
<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">


<colgroup>
<col  class="org-left" />

<col  class="org-left" />
</colgroup>
<thead>
<tr>
<th scope="col" class="org-left">API</th>
<th scope="col" class="org-left">描述</th>
</tr>
</thead>
<tbody>
<tr>
<td class="org-left">add(e)</td>
<td class="org-left">添加到队尾, 返回是否添加成功</td>
</tr>

<tr>
<td class="org-left">remove(e)</td>
<td class="org-left">删除第一次出现的元素</td>
</tr>

<tr>
<td class="org-left">addAll(index, c)</td>
<td class="org-left">将集合c添加到index开始的位置</td>
</tr>

<tr>
<td class="org-left">replaceAll(operator)</td>
<td class="org-left">使用operator来替换所有元素</td>
</tr>

<tr>
<td class="org-left">sort(c)</td>
<td class="org-left">使用Comparator c对队列进行排序</td>
</tr>

<tr>
<td class="org-left">get(index)</td>
<td class="org-left">获取index位置的元素</td>
</tr>

<tr>
<td class="org-left">set(index, e)</td>
<td class="org-left">替换index位置的元素, 返回旧元素</td>
</tr>

<tr>
<td class="org-left">add(index, e)</td>
<td class="org-left">index位置插入一个元素</td>
</tr>

<tr>
<td class="org-left">remove(index)</td>
<td class="org-left">删除index位置的元素</td>
</tr>

<tr>
<td class="org-left">index(e)</td>
<td class="org-left">获取元素在队列中第一次出现的位置, 或-1</td>
</tr>

<tr>
<td class="org-left">lastIndexOf(e)</td>
<td class="org-left">获取元素在队列中最后一次出现的位置, 或-1</td>
</tr>

<tr>
<td class="org-left">subList(start, end)</td>
<td class="org-left">获取[start, end) 位置的子列表</td>
</tr>

<tr>
<td class="org-left">listIterator()</td>
<td class="org-left">获取list的ListIterator</td>
</tr>
</tbody>
</table>

<p>
PS:
</p>
<ol class="org-ol">
<li><p>
replaceAll()实现: 首先获取队列的ListIterator, 然后过该iterator
来操作队列. 
</p>
<pre class="example">
default void replaceAll(UnaryOperator&lt;E&gt; operator) {
    Objects.requireNonNull(operator);
    final ListIterator&lt;E&gt; li = this.listIterator();
    while (li.hasNext()) {
        li.set(operator.apply(li.next()));
    }
}
</pre></li>
<li><p>
sort(Comparator c)实现: 首先调用toArray()方法将队列转化为array,
然后调用 <code>Arrays.sort()</code> 函数来对array进行排序, 最后将排序后的
array通过ListIterator存入队列.
</p>
<pre class="example">
default void sort(Comparator&lt;? super E&gt; c) {
    Object[] a = this.toArray();
    Arrays.sort(a, (Comparator) c);
    ListIterator&lt;E&gt; i = this.listIterator();
    for (Object e : a) {
        i.next();
        i.set((E) e);
    }
}
</pre></li>
<li>subList(): 通过该函数返回的子队列, 其数据还是存储在其"父队列"的底层实现中, 
所以对该队列数据的修改都会影响付队列, 同样, 对父队列的修改也会影响子队列.</li>
</ol>
</div>
</div>
<div id="outline-container-orgheadline5" class="outline-2">
<h2 id="orgheadline5">ListIterator</h2>
<div class="outline-text-2" id="text-orgheadline5">
<p>
该类是<a href="#orgheadline4">List</a>类的一个Iterator实现, 继承自<a href="#orgheadline1">Iterator</a>接口, 
其提供了遍历<a href="#orgheadline4">List</a>的接口, 同时对一些接口做了条件约束:
即对<a href="#orgheadline4">List</a>的遍历只能按照"从前向后"或"从后向前"的顺序.<br  />
该类的主要API如下:
</p>
<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">


<colgroup>
<col  class="org-left" />

<col  class="org-left" />
</colgroup>
<thead>
<tr>
<th scope="col" class="org-left">API</th>
<th scope="col" class="org-left">描述</th>
</tr>
</thead>
<tbody>
<tr>
<td class="org-left">hasNext()</td>
<td class="org-left">从前向后遍历,判断是否还有元素</td>
</tr>

<tr>
<td class="org-left">next()</td>
<td class="org-left">从前向后遍历, 返回下一个元素</td>
</tr>

<tr>
<td class="org-left">nextIndex()</td>
<td class="org-left">从前向后遍历, 返回下一个位置</td>
</tr>

<tr>
<td class="org-left">hasPrevious()</td>
<td class="org-left">从后向前遍历, 判断是否还有元素</td>
</tr>

<tr>
<td class="org-left">previous()</td>
<td class="org-left">从后向前, 返回下一个元素</td>
</tr>

<tr>
<td class="org-left">previousIndex()</td>
<td class="org-left">从后向前, 返回下一个元素位置</td>
</tr>

<tr>
<td class="org-left">remove()</td>
<td class="org-left">返回next()或previous()的返回值</td>
</tr>

<tr>
<td class="org-left">set()</td>
<td class="org-left">替换next()或previous()的返回值</td>
</tr>

<tr>
<td class="org-left">add()</td>
<td class="org-left">见注1</td>
</tr>
</tbody>
</table>

<p>
PS:
</p>
<ol class="org-ol">
<li>add(): 插入到next()返回值的"前面", 或previous()返回值的"后面".
另一个观点, 从"从前向后"的视角来看, 新插入的元素永远在当前元素的"前面".</li>
</ol>
</div>
</div>
<div id="outline-container-orgheadline6" class="outline-2">
<h2 id="orgheadline6">AbstractCollection</h2>
<div class="outline-text-2" id="text-orgheadline6">
<p>
AbstractCollection是<a href="#orgheadline3">Collection</a>接口的一个实现, 对于
集合类型的一些"可能"的共同操作, 该类给出了一些API实现, 包括:
</p>
<ol class="org-ol">
<li><p>
isEmpty()
</p>
<pre class="example">
public boolean isEmpty() {
    return size() == 0;
}
</pre></li>
<li><p>
contains(o)
该函数实现分两种情况: 如果o为null, 则判断集合中是否包含null. 否则,遍历
集合并调用参数o的equals()方法来判断是否有相等元素. 元素遍历是通过iterator实现.
</p>
<pre class="example">
public boolean contains(Object o) {
    Iterator&lt;E&gt; it = iterator();
    if (o==null) {
        while (it.hasNext())
            if (it.next()==null)
                return true;
    } else {
        while (it.hasNext())
            if (o.equals(it.next()))
                return true;
    }
    return false;
}
</pre></li>
<li><p>
toArray()
该函数用于将集合转换为数组, 需要关注的是, 在转化过程中, 集合的
结构可能被修改(多线程), 即元素被添加或删除.<br  />
该函数的实现也cover了这种情况. 从下面代码可以看到, 
</p>
<ol class="org-ol">
<li>在每次for循环开始都会调用hasNext()判断是已经到结尾(即期间有元素被删除). 
如果是, 则直接调用Array的copyOf()函数把返回临时数组的一个copy, 该临时数组
用于存储已经遍历过的元素.</li>
<li>遍历完之后, 还会再次调用hasNext()判断是否有新元素, 如果有, 则调用finishToArray()
函数继续对集合进行变量, 并分配一个更大的数组, 知道集合变量完或者达到数组上限.</li>
</ol>
<pre class="example">
public Object[] toArray() {
    // Estimate size of array; be prepared to see more or fewer elements
    Object[] r = new Object[size()];
    Iterator&lt;E&gt; it = iterator();
    for (int i = 0; i &lt; r.length; i++) {
        if (! it.hasNext()) // fewer elements than expected
            return Arrays.copyOf(r, i);
        r[i] = it.next();
    }
    return it.hasNext() ? finishToArray(r, it) : r;
}
</pre></li>
<li>toArray(T[] a)
如果a的size足够能容下集合元素, 则存入a中并返回a, 否则存入一个新分配的数组并返回.</li>
<li>remove(): 实现方式与contains()相同, 也是通过iterator进行操作.</li>
<li>containsAll()/addAll()/removeAll()<br  />
实现方式基本相同, 都是遍历参数集合, 然后基于参数中的每个元素
对集合进行操作.</li>
<li>retainAll(c). 只保留c和该集合的"交集"元素.</li>
<li><p>
clear(): 反复调用iterator的hasNext(), next(), remove()函数删除所有元素.
</p>
<pre class="example">
public void clear() {
    Iterator&lt;E&gt; it = iterator();
    while (it.hasNext()) {
        it.next();
        it.remove();
    }
}
</pre></li>
</ol>
</div>
</div>
<div id="outline-container-orgheadline7" class="outline-2">
<h2 id="orgheadline7">AbstractList</h2>
<div class="outline-text-2" id="text-orgheadline7">
<p>
该类是<a href="#orgheadline6">AbstractCollection</a>的一个子类并实现了<a href="#orgheadline4">List</a>接口, 该类实现了
List相关的一些共同操作. 包括:
</p>
<ol class="org-ol">
<li><p>
indexOf(o):寻找元素位置. 该函数的实现使用了previousIndex()函数, 因为
调用next()之后, iterator会移动到下一位, 所以需要调用这个函数才能获取
到"命中元素"的位置.
</p>
<pre class="example">
public int indexOf(Object o) {
    ListIterator&lt;E&gt; it = listIterator();
    if (o==null) {
        while (it.hasNext())
            if (it.next()==null)
                return it.previousIndex();
    } else {
        while (it.hasNext())
            if (o.equals(it.next()))
                return it.previousIndex();
    }
    return -1;
}
</pre></li>
<li>lastIndexOf(o): 实现方式与indexOf()相同, 只是遍历顺序相反.</li>
</ol>
</div>

<div id="outline-container-orgheadline8" class="outline-3">
<h3 id="orgheadline8">Itr</h3>
<div class="outline-text-3" id="text-orgheadline8">
<p>
该类是AbstractList的一个内部类, 在List的层级结构中, 是第一次具体实现
一个Iterator. 可以看下该类是如何具体实现<a href="#orgheadline1">Iterator</a>的API的.
</p>
<ol class="org-ol">
<li><p>
hasNext():判断当前的光标是否等于size()函数. 如果等于, 表示到达尾部, 返回false.
</p>
<pre class="example">
public boolean hasNext() {
    return cursor != size();
}
</pre></li>
<li><p>
next():返回下一个元素. 由于光标一开始是指向第一个元素(index=0), 
所以每次调用该函数, 返回的都是当前光标位置的元素, 然后再把光标
移动一个位置. 同时有一个成员变量 lastRet 用于记录这次返回值的位置.
</p>
<pre class="example">
   public E next() {
    checkForComodification();
    try {
        int i = cursor;
        E next = get(i);
        lastRet = i;
        cursor = i + 1;
        return next;
    } catch (IndexOutOfBoundsException e) {
        checkForComodification();
        throw new NoSuchElementException();
    }
}
</pre>

<p>
在函数的开始调用了 <code>checkForComodification()</code> 函数, 该函数用于
判断是否有其他线程操作了该iterator所属的集合.它的实现原理是:
Iterator有一个成员变量expectedModcount, 其值等于集合的变量modCount, 
每次集合被修改(添加/删除), modCount的值都会发生变化. 所以如果发现
expectedModcount的值与该值不相等了, 说明"集合"被其他线程修改了. 
在AbstractList中就会抛异常.
</p>
<pre class="example">
final void checkForComodification() {
     if (modCount != expectedModCount)
         throw new ConcurrentModificationException();
 }
</pre></li>
<li>remove():
如果当前光标没有指向list区间, 则抛异常. 否则调用 <a href="#orgheadline7">AbstractList</a>的remove()函数.
然后将缓存光标 lastRet 置位-1. 并重新赋值 expectedModcount(因为AbstractList的
remove()函数可能会修改modCount的值).</li>
</ol>
</div>
</div>
<div id="outline-container-orgheadline9" class="outline-3">
<h3 id="orgheadline9">ListItr</h3>
<div class="outline-text-3" id="text-orgheadline9">
<p>
该类是<a href="#orgheadline8">Itr</a>的子类并实现了<a href="#orgheadline5">ListIterator</a>接口. 主要是实现了ListIterator"从后向前"的遍历方法.
</p>
<ol class="org-ol">
<li>构造函数ListItr(index):
直接将光标至于index的位置.</li>
<li>hasPrevious():判断当前光标是否为0, 如果是返回false.</li>
<li><p>
previous(): 返回当前光标的前一个元素. 这里与next()不同, 
next()是先返回当前光标的值, 移动光标. previous()是返回
当前光标前面的值, 并移动光标. 
</p>
<pre class="example">
public E previous() {
    checkForComodification();
    try {
        int i = cursor - 1;
        E previous = get(i);
        lastRet = cursor = i;
        return previous;
    } catch (IndexOutOfBoundsException e) {
        checkForComodification();
        throw new NoSuchElementException();
    }
}
</pre></li>
<li>nextIndex(): 返回当前光标.</li>
<li>previousIndex(): 返回当前光标减1.</li>
</ol>
</div>
</div>
<div id="outline-container-orgheadline10" class="outline-3">
<h3 id="orgheadline10">SubList</h3>
<div class="outline-text-3" id="text-orgheadline10">
<p>
该类是AbstractList的子类,是"子队列"概念的代码实现. 代表了某个
队列的一部分. 在其实现中, 其内容存储在原列表的底层存储中. 该类
只维护了一些"列表"状态, 来表示子对类. 任何对该类的队列的修改都会
影响到原列表, 反之亦然. 通过下面的几个函数可以看出对该类的增删其实调用的
都是原来队列的方法.
</p>
<pre class="example">
SubList(AbstractList&lt;E&gt; list, int fromIndex, int toIndex) {
    if (fromIndex &lt; 0)
        throw new IndexOutOfBoundsException("fromIndex = " + fromIndex);
    if (toIndex &gt; list.size())
        throw new IndexOutOfBoundsException("toIndex = " + toIndex);
    if (fromIndex &gt; toIndex)
        throw new IllegalArgumentException("fromIndex(" + fromIndex +
                                           ") &gt; toIndex(" + toIndex + ")");
    l = list;
    offset = fromIndex;
    size = toIndex - fromIndex;
    this.modCount = l.modCount;
}

public E set(int index, E element) {
    rangeCheck(index);
    checkForComodification();
    return l.set(index+offset, element);
}

public E get(int index) {
    rangeCheck(index);
    checkForComodification();
    return l.get(index+offset);
}

public void add(int index, E element) {
    rangeCheckForAdd(index);
    checkForComodification();
    l.add(index+offset, element);
    this.modCount = l.modCount;
    size++;
}

public E remove(int index) {
    rangeCheck(index);
    checkForComodification();
    E result = l.remove(index+offset);
    this.modCount = l.modCount;
    size--;
    return result;
}
</pre>
</div>
</div>
<div id="outline-container-orgheadline11" class="outline-3">
<h3 id="orgheadline11">RandomAccessSubList</h3>
<div class="outline-text-3" id="text-orgheadline11">
<p>
该类是<a href="#orgheadline10">SubList</a>的一个子类, 但是实现了RandomAccess接口(空接口),
表明其具有RandomAccess的属性. 该类的所有操作几乎都是使用<a href="#orgheadline10">SubList</a>的操作. 
</p>

<p>
在AbstractList的subList()函数实现中, 会判断当前List是否为RandomAccess,
如果是, 则会返回一个 RandomAccessSubList 实例, 否则返回一个 SubList 实例. 
</p>
<pre class="example">
public List&lt;E&gt; subList(int fromIndex, int toIndex) {
    return (this instanceof RandomAccess ?
            new RandomAccessSubList&lt;&gt;(this, fromIndex, toIndex) :
            new SubList&lt;&gt;(this, fromIndex, toIndex));
}
</pre>
</div>
</div>
</div>
<div id="outline-container-orgheadline12" class="outline-2">
<h2 id="orgheadline12">ArrayList</h2>
<div class="outline-text-2" id="text-orgheadline12">
<p>
介绍了这么多之后, 终于来到了ArrayList的实现, 该类直接继承
自<a href="#orgheadline7">AbstractList</a>, 并实现了 <a href="#orgheadline4">List</a> 和 RandomAccess 接口.
</p>
<pre class="example">
public class ArrayList&lt;E&gt; extends AbstractList&lt;E&gt;
        implements List&lt;E&gt;, RandomAccess, Cloneable, java.io.Serializable
{
</pre>

<p>
这里主要介绍其底层数据存储的实现及与LinkedList不同的API:
</p>
<ol class="org-ol">
<li>ArrayList的元素都存放在底层Object数组elementData中.</li>
<li>int变量size存放元素数量.</li>
<li>get(index): 获取元素, 直接访问数组对应位置, O(1).</li>
<li>set(index, e): 更新元素, 同上, O(1).</li>
<li>add(index, e): index位置插入元素, 这里会做两步:
<ul class="org-ul">
<li>如果数组已满, 分配新数组, <b>这样会做一次整个数组的copy</b>.</li>
<li>插入新元素, 此时会将index后的内容做整体移动.</li>
</ul></li>
<li>remove(index): 对index后的内容做整体前移动作.</li>
<li><p>
batchRemove(c, flag): 批量删除, flag是一个boolean变量, 
其含义是: 如果为true, 保留c和该list的交集, 而删除其他元素.
如果为false, 则删除交集.
</p>
<pre class="example">
private boolean batchRemove(Collection&lt;?&gt; c, boolean complement) {
    final Object[] elementData = this.elementData;
    int r = 0, w = 0;
    boolean modified = false;
    try {
        for (; r &lt; size; r++)
            if (c.contains(elementData[r]) == complement)
                elementData[w++] = elementData[r];
    } finally {
        // Preserve behavioral compatibility with AbstractCollection,
        // even if c.contains() throws.
        if (r != size) {
            System.arraycopy(elementData, r,
                             elementData, w,
                             size - r);
            w += size - r;
        }
        if (w != size) {
            // clear to let GC do its work
            for (int i = w; i &lt; size; i++)
                elementData[i] = null;
            modCount += size - w;
            size = w;
            modified = true;
        }
    }
    return modified;
}
</pre></li>
</ol>

<p>
所以对于ArrayList的所有的插入/删除动作, 都会涉及到底层数组的
"移动", 这个移动最终是调用 <code>System.arraycopy()</code> 函数实现的.
所以插入/删除的效率直接与该函数的实现有关. 
</p>

<p>
ArryaList的其他实现, 例如 Iterator 和 ListIterator, 基本与
<a href="#orgheadline7">AbstractList</a>大同小异.
</p>
</div>
</div>
<div id="outline-container-orgheadline13" class="outline-2">
<h2 id="orgheadline13">AbstractSequentialList</h2>
<div class="outline-text-2" id="text-orgheadline13">
<p>
在介绍LinkedList之前, 先看一下它的父类, 该类是<a href="#orgheadline7">AbstractList</a>的
子类, 但是它具有"顺序"的属性, 这是相对于ArrayList的RandomAccess属性而言. 
官方文档中对该属性是这样解释的. 
</p>
<pre class="example">
* This class is the opposite of the &lt;tt&gt;AbstractList&lt;/tt&gt; class in the sense
* that it implements the "random access" methods (&lt;tt&gt;get(int index)&lt;/tt&gt;,
* &lt;tt&gt;set(int index, E element)&lt;/tt&gt;, &lt;tt&gt;add(int index, E element)&lt;/tt&gt; and
* &lt;tt&gt;remove(int index)&lt;/tt&gt;) on top of the list's list iterator, instead of
* the other way around.&lt;p&gt;
</pre>

<p>
上面这段文字解释了在该类中通过index "插入/删除" 元素的实现方法.
都是通过其ListIterator实现的. (想想在<a href="#orgheadline12">ArrayList</a>中,这些方法都是直接
操作数组). 可以看下几个相关的API代码.
</p>
<pre class="example">
public void add(int index, E element) {
    try {
        listIterator(index).add(element);
    } catch (NoSuchElementException exc) {
        throw new IndexOutOfBoundsException("Index: "+index);
    }
}
public E remove(int index) {
    try {
        ListIterator&lt;E&gt; e = listIterator(index);
        E outCast = e.next();
        e.remove();
        return outCast;
    } catch (NoSuchElementException exc) {
        throw new IndexOutOfBoundsException("Index: "+index);
    }
}
</pre>

<p>
另外, 该类的 iterator() 和 listIterator() 函数返回的都是
ListIterator实例.
</p>
</div>
</div>
<div id="outline-container-orgheadline14" class="outline-2">
<h2 id="orgheadline14">Deque</h2>
<div class="outline-text-2" id="text-orgheadline14">
<p>
双端队列, 支持头部和尾部的插入和删除动作. 
Deque接口提供了这些操作的相应API.
</p>
</div>
</div>
<div id="outline-container-orgheadline15" class="outline-2">
<h2 id="orgheadline15">LinkedList</h2>
<div class="outline-text-2" id="text-orgheadline15">
<p>
继承自<a href="#orgheadline13">AbstractSequentialList</a>, 并实现了 <a href="#orgheadline4">List</a> 和 <a href="#orgheadline14">Deque</a> 接口.
</p>

<p>
不过与<a href="#orgheadline13">AbstractSequentialList</a>不同的是, LinkedList的插入删除并
没有使用ListIterator, 而是直接操作链表. 下面是一些核心API:
</p>
<ol class="org-ol">
<li><p>
unlink(e): 删除元素, "几乎"所有删除API的底层实现. 
与<a href="#orgheadline12">ArrayList</a>不同的是, 它没有设计到"一片内存"区域的移动, 所以
效率上要比ArrayList高.
</p>
<pre class="example">
E unlink(Node&lt;E&gt; x) {
    // assert x != null;
    final E element = x.item;
    final Node&lt;E&gt; next = x.next;
    final Node&lt;E&gt; prev = x.prev;

    if (prev == null) {
        first = next;
    } else {
        prev.next = next;
        x.prev = null;
    }

    if (next == null) {
        last = prev;
    } else {
        next.prev = prev;
        x.next = null;
    }

    x.item = null;
    size--;
    modCount++;
    return element;
}
</pre></li>
<li>linkBefore(e, node): 插入元素,实现原理同unlink().</li>
<li><p>
node(index): 获取index位置的node, "几乎" 所有遍历类的底层实现.
这需要遍历链表, 不过因为LinkedList是双向列表, 
所以该函数的实现上也有点技巧: 即如果index &gt; size/2, 则从队列
尾部向前寻找, 否则从队列头部向后寻找.
</p>
<pre class="example">
Node&lt;E&gt; node(int index) {
    // assert isElementIndex(index);

    if (index &lt; (size &gt;&gt; 1)) {
        Node&lt;E&gt; x = first;
        for (int i = 0; i &lt; index; i++)
            x = x.next;
        return x;
    } else {
        Node&lt;E&gt; x = last;
        for (int i = size - 1; i &gt; index; i--)
            x = x.prev;
        return x;
    }
}
</pre></li>
</ol>

<p>
这三个函数基本就是LinkedList的核心原理. 
</p>
</div>
<div id="outline-container-orgheadline16" class="outline-3">
<h3 id="orgheadline16">Node</h3>
<div class="outline-text-3" id="text-orgheadline16">
<p>
LinkedList是使用"链表"这种数据结构来存储数据, 所以其内部定义了一个
Node类用来表示链表节点. Node类的实现很简单.
</p>
<pre class="example">
private static class Node&lt;E&gt; {
    E item;
    Node&lt;E&gt; next;
    Node&lt;E&gt; prev;

    Node(Node&lt;E&gt; prev, E element, Node&lt;E&gt; next) {
        this.item = element;
        this.next = next;
        this.prev = prev;
    }
}
</pre>
</div>
</div>
</div>
<div id="outline-container-orgheadline17" class="outline-2">
<h2 id="orgheadline17">SynchronizedList</h2>
<div class="outline-text-2" id="text-orgheadline17">
<p>
由于List类不是线程安全的. 多线程可以同时修改list的内容. 
所以为了解决这个问题, Collections类提供了一个 
<code>snchronizedList()</code> 函数用于将 <a href="#orgheadline4">List</a> 转化为一个 "同步" list.
其基本原理类似于adapter模式, 实现了一个新的list, 被提供了
同步功能. 看下部分源码:
</p>
<pre class="example">
public static &lt;T&gt; List&lt;T&gt; synchronizedList(List&lt;T&gt; list) {
    return (list instanceof RandomAccess ?
            new SynchronizedRandomAccessList&lt;&gt;(list) :
            new SynchronizedList&lt;&gt;(list));
}

static class SynchronizedList&lt;E&gt;
    extends SynchronizedCollection&lt;E&gt;
    implements List&lt;E&gt; {
    private static final long serialVersionUID = -7754090372962971524L;

    final List&lt;E&gt; list;

    SynchronizedList(List&lt;E&gt; list) {
        super(list);
        this.list = list;
    }
    SynchronizedList(List&lt;E&gt; list, Object mutex) {
        super(list, mutex);
        this.list = list;
    }

    public boolean equals(Object o) {
        if (this == o)
            return true;
        synchronized (mutex) {return list.equals(o);}
    }
    public int hashCode() {
        synchronized (mutex) {return list.hashCode();}
    }

    public E get(int index) {
        synchronized (mutex) {return list.get(index);}
    }
    public E set(int index, E element) {
        synchronized (mutex) {return list.set(index, element);}
    }
    public void add(int index, E element) {
        synchronized (mutex) {list.add(index, element);}
    }
    public E remove(int index) {
        synchronized (mutex) {return list.remove(index);}
    }
</pre>
</div>
</div>
</div>
<div id="postamble" class="status">
The code examples and css stylesheets are licensed under the <a href="http://www.gnu.org/licenses/gpl.html">GNU General Public License v3</a> or later.</p></div>
</div>
</body>
</html>
