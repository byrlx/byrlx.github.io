<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
"http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en">
<head>
<!-- 2017-03-09 Thu 22:49 -->
<meta  http-equiv="Content-Type" content="text/html;charset=utf-8" />
<meta  name="viewport" content="width=device-width, initial-scale=1" />
<title>ArrayList, LinkedList源码笔记</title>
<meta  name="generator" content="Org-mode" />
<meta  name="author" content="Luis Xu" />
<link rel="stylesheet" title="Standard" href="/style/worg.css" type="text/css" />
<link rel="alternate stylesheet" title="Zenburn" href="/style/worg-zenburn.css" type="text/css" />
<link rel="alternate stylesheet" title="Classic" href="/style/worg-classic.css" type="text/css" />
<link rel="SHORTCUT ICON" href="/org-mode-unicorn.ico" type="image/x-icon" />
<link rel="icon" href="/org-mode-unicorn.ico" type="image/ico" />
<script type="text/javascript">
/*
@licstart  The following is the entire license notice for the
JavaScript code in this tag.

Copyright (C) 2012-2013 Free Software Foundation, Inc.

The JavaScript code in this tag is free software: you can
redistribute it and/or modify it under the terms of the GNU
General Public License (GNU GPL) as published by the Free Software
Foundation, either version 3 of the License, or (at your option)
any later version.  The code is distributed WITHOUT ANY WARRANTY;
without even the implied warranty of MERCHANTABILITY or FITNESS
FOR A PARTICULAR PURPOSE.  See the GNU GPL for more details.

As additional permission under GNU GPL version 3 section 7, you
may distribute non-source (e.g., minimized or compacted) forms of
that code without the copy of the GNU GPL normally required by
section 4, provided you include this license notice and a URL
through which recipients can access the Corresponding Source.


@licend  The above is the entire license notice
for the JavaScript code in this tag.
*/
<!--/*--><![CDATA[/*><!--*/
 function CodeHighlightOn(elem, id)
 {
   var target = document.getElementById(id);
   if(null != target) {
     elem.cacheClassElem = elem.className;
     elem.cacheClassTarget = target.className;
     target.className = "code-highlighted";
     elem.className   = "code-highlighted";
   }
 }
 function CodeHighlightOff(elem, id)
 {
   var target = document.getElementById(id);
   if(elem.cacheClassElem)
     elem.className = elem.cacheClassElem;
   if(elem.cacheClassTarget)
     target.className = elem.cacheClassTarget;
 }
/*]]>*///-->
</script>
</head>
<body>
<div id="preamble" class="status">
<script type="text/javascript">

  var _gaq = _gaq || [];
  _gaq.push(['_setAccount', 'UA-7691209-1']);
  _gaq.push(['_trackPageview']);

  (function() {
    var ga = document.createElement('script'); ga.type = 'text/javascript'; ga.async = true;
    ga.src = ('https:' == document.location.protocol ? 'https://ssl' : 'http://www') + '.google-analytics.com/ga.js';
    var s = document.getElementsByTagName('script')[0]; s.parentNode.insertBefore(ga, s);
  })();

  document.addEventListener('DOMContentLoaded',function() {
      document.getElementById("table-of-contents").onclick = function() {
          var elem = document.getElementById("text-table-of-contents");
          elem.style.display = elem.style.display == "block" ? "none" : "block";
      }
  });
</script>
</div>
<div id="content">
<h1 class="title">ArrayList, LinkedList源码笔记</h1>
<div id="table-of-contents">
<h2>Table of Contents</h2>
<div id="text-table-of-contents">
<ul>
<li><a href="#orgheadline1">标记接口</a>
<ul>
<li><a href="#orgheadline2">Cloneable</a></li>
<li><a href="#orgheadline3">Serializable</a></li>
<li><a href="#orgheadline4">RandomAccess</a></li>
</ul>
</li>
<li><a href="#orgheadline26">ArrayList</a>
<ul>
<li><a href="#orgheadline7">定义</a></li>
<li><a href="#orgheadline8">主要成员</a></li>
<li><a href="#orgheadline9">构造函数</a></li>
<li><a href="#orgheadline10">添加数据</a>
<ul>
<li><a href="#orgheadline11">查看当前空间</a></li>
</ul>
</li>
<li><a href="#orgheadline12">查找数据</a></li>
<li><a href="#orgheadline13">删除数据</a>
<ul>
<li><a href="#orgheadline14">按坐标删除</a></li>
<li><a href="#orgheadline15">删除指定元素</a></li>
<li><a href="#orgheadline16">清空所有</a></li>
<li><a href="#orgheadline17">批量删除</a></li>
<li><a href="#orgheadline18">保留交集</a></li>
<li><a href="#orgheadline19">条件删除</a></li>
<li><a href="#orgheadline20">批量修改</a></li>
</ul>
</li>
<li><a href="#orgheadline21">关于fail-fast</a></li>
<li><a href="#orgheadline22">迭代器</a>
<ul>
<li><a href="#orgheadline23">Iterator实现: Itr</a></li>
<li><a href="#orgheadline24">ListIterator实现: ListItr</a></li>
</ul>
</li>
<li><a href="#orgheadline25">子列表</a></li>
</ul>
</li>
<li><a href="#orgheadline28">Iterable</a></li>
<li><a href="#orgheadline27">Iterator</a></li>
<li><a href="#orgheadline29">Collection</a></li>
<li><a href="#orgheadline6">List</a></li>
<li><a href="#orgheadline30">ListIterator</a></li>
<li><a href="#orgheadline31">AbstractCollection</a></li>
<li><a href="#orgheadline5">AbstractList</a>
<ul>
<li><a href="#orgheadline32">Itr</a></li>
<li><a href="#orgheadline33">ListItr</a></li>
<li><a href="#orgheadline34">SubList</a></li>
<li><a href="#orgheadline35">RandomAccessSubList</a></li>
</ul>
</li>
<li><a href="#orgheadline36">AbstractSequentialList</a></li>
<li><a href="#orgheadline37">Deque</a></li>
<li><a href="#orgheadline38">LinkedList</a>
<ul>
<li><a href="#orgheadline39">Node</a></li>
</ul>
</li>
<li><a href="#orgheadline40">SynchronizedList</a></li>
</ul>
</div>
</div>
<p>
最近工作不忙, 抽空看了一下ArrayList和LinkedList的源码. 
这两个类是List的具体实现类, 所以在它们之上还有许多的
抽象接口和抽象类, 下面源码分析的笔记
</p>

<p>
<i>代码基于JDK</i>
</p>

<div id="outline-container-orgheadline1" class="outline-2">
<h2 id="orgheadline1">标记接口</h2>
<div class="outline-text-2" id="text-orgheadline1">
<p>
在Java中有一类接口叫做"标记接口"(Marker Interface). 标记接口
是没有任何方法的接口, 它仅仅标志实现它的类具有"某个特点", 而系统的
其他应用可能会在对类做操作时先判断其是否具有这个特点(例如下面的Cloneable).
</p>
</div>
<div id="outline-container-orgheadline2" class="outline-3">
<h3 id="orgheadline2">Cloneable</h3>
<div class="outline-text-3" id="text-orgheadline2">
<p>
标志该类可以继承. Object类的clone()函数会先判断该类是否具有该特性,
如果没有则报错:
</p>
<pre class="example">
protected Object clone() throws CloneNotSupportedException {
    if (!(this instanceof Cloneable)) {
        throw new CloneNotSupportedException("Class " + getClass().getName() +
                                             " doesn't implement Cloneable");
    }

    return internalClone();
}
</pre>
</div>
</div>
<div id="outline-container-orgheadline3" class="outline-3">
<h3 id="orgheadline3">Serializable</h3>
<div class="outline-text-3" id="text-orgheadline3">
<p>
标志该类可以被序列化和反序列化.
</p>
</div>
</div>
<div id="outline-container-orgheadline4" class="outline-3">
<h3 id="orgheadline4">RandomAccess</h3>
<div class="outline-text-3" id="text-orgheadline4">
<p>
这个标记接口被List类使用,标志该List具备
快速随机访问功能.
</p>
</div>
</div>
</div>
<div id="outline-container-orgheadline26" class="outline-2">
<h2 id="orgheadline26">ArrayList</h2>
<div class="outline-text-2" id="text-orgheadline26">
</div><div id="outline-container-orgheadline7" class="outline-3">
<h3 id="orgheadline7">定义</h3>
<div class="outline-text-3" id="text-orgheadline7">
<p>
ArrayList直接继承自<a href="#orgheadline5">AbstractList</a>, 并实现了以下接口:
</p>
<ol class="org-ol">
<li><a href="#orgheadline6">List</a> : 说明ArrayList具备List接口的功能.</li>
<li><a href="#orgheadline4">RandomAccess</a>: 说明ArrayList是支持快速访问的.</li>
<li><a href="#orgheadline2">Cloneable</a>: 可以被clone.</li>
<li><a href="#orgheadline3">Serializable</a>: 可以被序列化和反序列化.</li>
</ol>
<div class="org-src-container">

<pre class="src src-java"><span style="color: #F0DFAF; font-weight: bold;">public</span> <span style="color: #F0DFAF; font-weight: bold;">class</span> <span style="color: #7CB8BB;">ArrayList</span>&lt;<span style="color: #7CB8BB;">E</span>&gt; <span style="color: #F0DFAF; font-weight: bold;">extends</span> <span style="color: #7CB8BB;">AbstractList</span>&lt;<span style="color: #7CB8BB;">E</span>&gt;
        <span style="color: #F0DFAF; font-weight: bold;">implements</span> <span style="color: #7CB8BB;">List</span>&lt;<span style="color: #7CB8BB;">E</span>&gt;, <span style="color: #7CB8BB;">RandomAccess</span>, <span style="color: #7CB8BB;">Cloneable</span>, <span style="color: #BFEBBF;">java</span>.<span style="color: #BFEBBF;">io</span>.<span style="color: #7CB8BB;">Serializable</span>
{
</pre>
</div>
</div>
</div>

<div id="outline-container-orgheadline8" class="outline-3">
<h3 id="orgheadline8">主要成员</h3>
<div class="outline-text-3" id="text-orgheadline8">
<ol class="org-ol">
<li>ArrayList的底层数据存储就像它的名字一样, 使用了一个 Object[] 数组,
因为ArrayList是支持泛型的, 所以在添加数据时,数据被转成了Object存储,
在获取数据时,又将其转化成相应的类型.</li>
<li>同时, AL还维护了一个size变量用来记录当前的数组大小.</li>
</ol>
</div>
</div>
<div id="outline-container-orgheadline9" class="outline-3">
<h3 id="orgheadline9">构造函数</h3>
<div class="outline-text-3" id="text-orgheadline9">
<p>
ArrayList支持三种类型的构造函数.
</p>
<ol class="org-ol">
<li><p>
默认构造函数. 默认构造函数只有一行代码,
就是把存放数据的数组指向一个空数组
DEFAULTCAPACITY_EMPTY_ELEMENTDATA.
</p>
<pre class="example">
public ArrayList() {
    this.elementData = DEFAULTCAPACITY_EMPTY_ELEMENTDATA;
}
</pre>
<p>
另外AL里还定义了另外一个空数组EMPTY_ELEMENTDATA. 
之所以要定义两个空数组, 是因为DEFAULTCAPACITY_EMPTY_ELEMENTDATA
是与DEFAULT_CAPACITY来结合使用的, 该数组标志着第一次添加
元素时elementData要扩容的大小. 可以看如下代码:
</p>
<pre class="example">
private void ensureCapacityInternal(int minCapacity) {
    if (elementData == DEFAULTCAPACITY_EMPTY_ELEMENTDATA) {
        minCapacity = Math.max(DEFAULT_CAPACITY, minCapacity);
    }

    ensureExplicitCapacity(minCapacity);
}
</pre>
<p>
当第一次添加元素时, minCapacity的值为1, 所以会将
elementData扩容到DEFAULT_CAPACITY的大小.
</p></li>
<li><p>
带size的构造函数.
使用该构造函数可以指定数组的初始大小.会直接创建一个
Object数组.
</p>
<pre class="example">
public ArrayList(int initialCapacity) {
    if (initialCapacity &gt; 0) {
        this.elementData = new Object[initialCapacity];
    } else if (initialCapacity == 0) {
        this.elementData = EMPTY_ELEMENTDATA;
    } else {
        throw new IllegalArgumentException("Illegal Capacity: "+
                                           initialCapacity);
    }
}
</pre></li>
<li><p>
使用集合创建ArrayList,
这个构造函数接受一个集合, 并使用该集合去初始化
elementData. 因为AL是接受泛型参数, 所以集合参数的
类型是该泛型的任意子类. 该函数的步骤
</p>
<ol class="org-ol">
<li>调用集合的toArray()函数.</li>

<li>赋值size值. 如果size大于0, 判断集合的class
是否为Object[].class, 如果不是, 则调用Arrays
的函数 copyOf() 将其转化成Object[]类型.</li>
</ol>
<pre class="example">
public ArrayList(Collection&lt;? extends E&gt; c) {
    elementData = c.toArray();
    if ((size = elementData.length) != 0) {
        // c.toArray might (incorrectly) not return Object[] (see 6260652)
        if (elementData.getClass() != Object[].class)
            elementData = Arrays.copyOf(elementData, size, Object[].class);
    } else {
        // replace with empty array.
        this.elementData = EMPTY_ELEMENTDATA;
    }
}
</pre></li>
</ol>
</div>
</div>
<div id="outline-container-orgheadline10" class="outline-3">
<h3 id="orgheadline10">添加数据</h3>
<div class="outline-text-3" id="text-orgheadline10">
<p>
ArrayList提供了两个添加数据的接口. add(E e)及
add(int index, E element). 这两个函数的实现都分为
两步:
</p>
<ol class="org-ol">
<li>查看当前空间是否够用, 不够则扩容.</li>
<li>插入数据. 第一个add()函数直接将数据放到指定位置.
第二个则调用了系统的arraycopy()函数将整体元素后移,
然后将元素放到指定位置.</li>
</ol>
<pre class="example">
public boolean add(E e) {
    ensureCapacityInternal(size + 1);  // Increments modCount!!
    elementData[size++] = e;
    return true;
}

public void add(int index, E element) {
    rangeCheckForAdd(index);

    ensureCapacityInternal(size + 1);  // Increments modCount!!
    System.arraycopy(elementData, index, elementData, index + 1,
                     size - index);
    elementData[index] = element;
    size++;
}
</pre>
</div>
<div id="outline-container-orgheadline11" class="outline-4">
<h4 id="orgheadline11">查看当前空间</h4>
<div class="outline-text-4" id="text-orgheadline11">
<p>
查看当前空间是通过调用ensureCapacityInternal()函数来实现的
   需要传递给函数一个参数, 标志需要确保的最小size值.
   该函数调用了ensureExplicitCapacity()来做扩容的工作(不一定必做).
   如果需要扩容, 后者则会调用到了grow()函数做实际扩容, 该函数的步骤
</p>
<ul class="org-ul">
<li>将当前容量增大1.5倍.</li>
<li>如果增大后的容量还小于要求的容量, 
则将其设为要求的容量.</li>
<li>将增大后的容量与最大的阈值MAX_ARRAY_SIZE
作比较, 如果比它大, 那么调用hugeCapacity()
函数确定最后的容量大小:
<ul class="org-ul">
<li>如果要求的容量是负数, overflow, 报错.</li>
<li>如果大于MAX_ARRAY_SIZE, 则新容量为
Integer.MAX_VALUE. 否则为 MAX_ARRAY_SIZE.</li>
</ul></li>
<li>调用Arrays的copyOf()函数生成一个新容量大小的数组.</li>
</ul>
<p>
代码如下:
</p>
<pre class="example">
private void ensureCapacityInternal(int minCapacity) {
    if (elementData == DEFAULTCAPACITY_EMPTY_ELEMENTDATA) {
        minCapacity = Math.max(DEFAULT_CAPACITY, minCapacity);
    }

    ensureExplicitCapacity(minCapacity);
}

private void ensureExplicitCapacity(int minCapacity) {
    modCount++;

    // overflow-conscious code
    if (minCapacity - elementData.length &gt; 0)
        grow(minCapacity);
}

private static final int MAX_ARRAY_SIZE = Integer.MAX_VALUE - 8;

private void grow(int minCapacity) {
    // overflow-conscious code
    int oldCapacity = elementData.length;
    int newCapacity = oldCapacity + (oldCapacity &gt;&gt; 1);
    if (newCapacity - minCapacity &lt; 0)
        newCapacity = minCapacity;
    if (newCapacity - MAX_ARRAY_SIZE &gt; 0)
        newCapacity = hugeCapacity(minCapacity);
    // minCapacity is usually close to size, so this is a win:
    elementData = Arrays.copyOf(elementData, newCapacity);
}

private static int hugeCapacity(int minCapacity) {
    if (minCapacity &lt; 0) // overflow
        throw new OutOfMemoryError();
    return (minCapacity &gt; MAX_ARRAY_SIZE) ?
        Integer.MAX_VALUE :
        MAX_ARRAY_SIZE;
}
</pre>
</div>
</div>
</div>
<div id="outline-container-orgheadline12" class="outline-3">
<h3 id="orgheadline12">查找数据</h3>
<div class="outline-text-3" id="text-orgheadline12">
<p>
ArrayList支持基于下标查找数据, 并且该操作是O(1)
操作. 不过会将返回的数据强制转化为泛型类型.
</p>
<pre class="example">
public E get(int index) {
    rangeCheck(index);

    return elementData(index);
}

E elementData(int index) {
    return (E) elementData[index];
}
</pre>
</div>
</div>
<div id="outline-container-orgheadline13" class="outline-3">
<h3 id="orgheadline13">删除数据</h3>
<div class="outline-text-3" id="text-orgheadline13">
<p>
ArrayList提供了以下的删除API:
remove(int), remove(Object), clear(),
removeAll(Collection), removeIf(Predicate).
</p>

<p>
<b>注:这些删除操作都会修改modCount的值, 该值用来判断List是否被多进程修改</b>
</p>
</div>
<div id="outline-container-orgheadline14" class="outline-4">
<h4 id="orgheadline14">按坐标删除</h4>
<div class="outline-text-4" id="text-orgheadline14">
<p>
步骤:
</p>
<ol class="org-ol">
<li>计算要移动的元素数: num = size - index - 1</li>
<li>调用System.arraycopy()移动数组.</li>
<li>将数组的最后一个元素置为null.</li>
</ol>
<pre class="example">
public E remove(int index) {
    rangeCheck(index);

    modCount++;
    E oldValue = elementData(index);

    int numMoved = size - index - 1;
    if (numMoved &gt; 0)
        System.arraycopy(elementData, index+1, elementData, index,
                         numMoved);
    elementData[--size] = null; // clear to let GC do its work

    return oldValue;
}
</pre>
</div>
</div>
<div id="outline-container-orgheadline15" class="outline-4">
<h4 id="orgheadline15">删除指定元素</h4>
<div class="outline-text-4" id="text-orgheadline15">
<p>
该函数先知道元素位置, 然后在做数组移动
和置null工作. 
<b>注: 由于AL支持存放null元素, 所以删除的时候null和实际元素要区分对待</b>
</p>
</div>
</div>
<div id="outline-container-orgheadline16" class="outline-4">
<h4 id="orgheadline16">清空所有</h4>
<div class="outline-text-4" id="text-orgheadline16">
<p>
把所有元素置null就可以了.
</p>
</div>
</div>
<div id="outline-container-orgheadline17" class="outline-4">
<h4 id="orgheadline17">批量删除</h4>
<div class="outline-text-4" id="text-orgheadline17">
<p>
(即删除交集)
removeAll()函数接受一个集合参数, 然后调用
batchRemove()做实际的删除工作.
batchRemove()接受两个参数, 第一个就是上面的集合, 第二个
参数是boolean类型, 标志集合中的元素是否保留, 如果该参数
值为TRUE,则标志集合中的元素要保留, 否则删除. 
</p>

<p>
removeAll()函数在调用该函数时传入的参数为false.
batchRemove()会遍历当前所有元素, 然后判断是否在传入的集合中
也包含, 同时更新当前数组. 
</p>
<pre class="example">
public boolean removeAll(Collection&lt;?&gt; c) {
     Objects.requireNonNull(c);
     return batchRemove(c, false);
 }

 private boolean batchRemove(Collection&lt;?&gt; c, boolean complement) {
     final Object[] elementData = this.elementData;
     int r = 0, w = 0;
     boolean modified = false;
     try {
         for (; r &lt; size; r++)
             if (c.contains(elementData[r]) == complement)
                 elementData[w++] = elementData[r];
     } finally {
         // Preserve behavioral compatibility with AbstractCollection,
         // even if c.contains() throws.
         if (r != size) {
             System.arraycopy(elementData, r,
                              elementData, w,
                              size - r);
             w += size - r;
         }
         if (w != size) {
             // clear to let GC do its work
             for (int i = w; i &lt; size; i++)
                 elementData[i] = null;
             modCount += size - w;
             size = w;
             modified = true;
         }
     }
     return modified;
 }
</pre>
</div>
</div>
<div id="outline-container-orgheadline18" class="outline-4">
<h4 id="orgheadline18">保留交集</h4>
<div class="outline-text-4" id="text-orgheadline18">
<p>
retainAll()函数与removeAll()类似, 
只不过retainAll()里传入的集合内容都会在
数组里保存, 其余的删除.
</p>
<pre class="example">
public boolean retainAll(Collection&lt;?&gt; c) {
    Objects.requireNonNull(c);
    return batchRemove(c, true);
}
</pre>
</div>
</div>
<div id="outline-container-orgheadline19" class="outline-4">
<h4 id="orgheadline19">条件删除</h4>
<div class="outline-text-4" id="text-orgheadline19">
<p>
removeIf()是提供了条件删除的功能, 该函数接受一个
Predicate的参数, predicate提供了判断条件, 如果
AL里的元素满足条件, 则将其删除. 
</p>
<pre class="example">
@Override
public boolean removeIf(Predicate&lt;? super E&gt; filter) {
    Objects.requireNonNull(filter);
    // figure out which elements are to be removed
    // any exception thrown from the filter predicate at this stage
    // will leave the collection unmodified
    int removeCount = 0;
    final BitSet removeSet = new BitSet(size);
    final int expectedModCount = modCount;
    final int size = this.size;
    for (int i=0; modCount == expectedModCount &amp;&amp; i &lt; size; i++) {
        @SuppressWarnings("unchecked")
        final E element = (E) elementData[i];
        if (filter.test(element)) {
            removeSet.set(i);
            removeCount++;
        }
    }
    if (modCount != expectedModCount) {
        throw new ConcurrentModificationException();
    }

    // shift surviving elements left over the spaces left by removed elements
    final boolean anyToRemove = removeCount &gt; 0;
    if (anyToRemove) {
        final int newSize = size - removeCount;
        for (int i=0, j=0; (i &lt; size) &amp;&amp; (j &lt; newSize); i++, j++) {
            i = removeSet.nextClearBit(i);
            elementData[j] = elementData[i];
        }
        for (int k=newSize; k &lt; size; k++) {
            elementData[k] = null;  // Let gc do its work
        }
        this.size = newSize;
        if (modCount != expectedModCount) {
            throw new ConcurrentModificationException();
        }
        modCount++;
    }

    return anyToRemove;
}
</pre>
<p>
removeIf()的实现使用了BitSet类, 该类提供了bitmap
功能.主要步骤:
</p>
<ol class="org-ol">
<li>遍历元素, 如果满足Predicate的test条件, 则设置
removeSet的相应bit位.
遍历过程中会一直检查modCount有没有被其他线程修改.
如果修改则终止遍历并抛异常.</li>
<li>再次遍历元素, 获取removeSet里被设为没被设为true的
index,并存入elementData.</li>
<li>将elmentData剩下的元素设为null以方便GC回收.</li>
<li>修改modCount的值.</li>
</ol>
</div>
</div>
<div id="outline-container-orgheadline20" class="outline-4">
<h4 id="orgheadline20">批量修改</h4>
<div class="outline-text-4" id="text-orgheadline20">
<p>
replaceAll()函数提供了批量修改功能,
该函数接受一个一元操作符的类 UnaryOperator 实例.
然后将操作应用于所有元素.
</p>
</div>
</div>
</div>
<div id="outline-container-orgheadline21" class="outline-3">
<h3 id="orgheadline21">关于fail-fast</h3>
<div class="outline-text-3" id="text-orgheadline21">
<p>
在需要遍历元素的过程中, 经常会在for()
循环里判断modCount的值有没有变化, 如果
有变化则立即停止循环并抛出并发异常.
</p>

<p>
而modCount会变化的唯一可能是其他线程同时
在操作这个ArrayList.
</p>

<p>
注: 在add()类相关函数中没有发现modCount的操作.
</p>
</div>
</div>
<div id="outline-container-orgheadline22" class="outline-3">
<h3 id="orgheadline22">迭代器</h3>
<div class="outline-text-3" id="text-orgheadline22">
<p>
ArrayList支持两种迭代器: iterator和listIterator.
</p>
</div>
<div id="outline-container-orgheadline23" class="outline-4">
<h4 id="orgheadline23">Iterator实现: Itr</h4>
<div class="outline-text-4" id="text-orgheadline23">
<p>
通过iterator()函数可以获取AL的Iterator, 函数的实现中
创建了一个AL自定义的内部类Itr. Itr继承自抽象类 Iterator.
</p>

<p>
Itr内部定义了一个cursor变量, 以及一个expectedModCount,
一个lastRet(用来保存上一次的位置).
当创建一个新实例时, 会将其赋值为modCount. 看一下对Iterator
所提供的API的实现.
</p>
<ol class="org-ol">
<li>hasNext(): 将cursor当前值与size做比较, 如果不相等则表示还有
元素.</li>
<li>next(): 返回一个泛型的值. 函数实现步骤:
<ol class="org-ol">
<li>检查是否被其他线程修改. 如果是报同步异常.</li>
<li>检查cursor的值是否超出了size, 如果是报异常.
(是不是modCount未修改, 但元素已删除的时候会出现这种情况?).</li>
<li>检查i的值是否超出了AL的数组长度, 如果是则抛同步异常.</li>
<li>将cursor的值加1, 并返回之前cursor位置的元素.
并讲之前值赋值给lastRet.</li>
</ol></li>
<li>remove(): 删除当前cursor指向的元素. 函数实现步骤:
<ol class="org-ol">
<li>判断lastRet是否小于0, 如果是, 说明还没调用next()就调用remove.
抛非法状态异常.</li>
<li>检查是否有其他线程修改.</li>
<li><a href="#orgheadline14">调用remove()</a>删除lastRet当前指向的元素.
将cursor的值更新为lastRet, 并把lastRet设为-1(从这儿可以看出不能连续调用两次remove()).
更新expectedModCount. 如果这一步抛出边界异常, 则捕获并重新抛出同步异常.</li>
</ol></li>
</ol>
<pre class="example">
public boolean hasNext() {
          return cursor != size;
      }

      @SuppressWarnings("unchecked")
      public E next() {
          checkForComodification();
          int i = cursor;
          if (i &gt;= size)
              throw new NoSuchElementException();
          Object[] elementData = ArrayList.this.elementData;
          if (i &gt;= elementData.length)
              throw new ConcurrentModificationException();
          cursor = i + 1;
          return (E) elementData[lastRet = i];
      }

      public void remove() {
          if (lastRet &lt; 0)
              throw new IllegalStateException();
          checkForComodification();

          try {
              ArrayList.this.remove(lastRet);
              cursor = lastRet;
              lastRet = -1;
              expectedModCount = modCount;
          } catch (IndexOutOfBoundsException ex) {
              throw new ConcurrentModificationException();
          }
      }
</pre>
</div>
</div>
<div id="outline-container-orgheadline24" class="outline-4">
<h4 id="orgheadline24">ListIterator实现: ListItr</h4>
<div class="outline-text-4" id="text-orgheadline24">
<p>
ListItr继承Itr并实现了ListIterator接口. 包括: previous(), hasPrevious(),
nextIndex(), previousIndex()等.
</p>
</div>
</div>
</div>
<div id="outline-container-orgheadline25" class="outline-3">
<h3 id="orgheadline25">子列表</h3>
<div class="outline-text-3" id="text-orgheadline25">
<p>
ArrayList提供了接口subList()来获取该AL的一个子集. 这是通过创建
一个新的SubList类实例来实现的.
</p>
<pre class="example">
public List&lt;E&gt; subList(int fromIndex, int toIndex) {
    subListRangeCheck(fromIndex, toIndex, size);
    return new SubList(this, offset, fromIndex, toIndex);
}
</pre>

<p>
SubList类是ArrayList的一个子类, 它的底层数据存储仍然是ArrayList的elementData
数组, 所以对SubList的修改也会反馈到ArrayList中.
SubList重要维护了一个索引来记录它所包含的数据. 包括 offset, size等. 
由于SubList也继承自AbstractList, 所以它也提供了List的所有增删查的行为,
当都是在函数内部通过坐标索引计算后调用ArrayList相应的api实现.
同时, SubList也提供Iterator接口.
</p>
</div>
</div>
</div>

<div id="outline-container-orgheadline28" class="outline-2">
<h2 id="orgheadline28">Iterable</h2>
<div class="outline-text-2" id="text-orgheadline28">
<p>
实现了Iterable的接口类, 可以使用 "for-loop" 形式的语法. 
例如这里实现一个 Foo 类实现了 Iterable 接口. 那么可以使用
如下代码来操作 Foo 实例.
</p>

<div class="org-src-container">

<pre class="src src-java"><span style="color: #7CB8BB;">Foo</span> <span style="color: #DFAF8F;">foo</span> = <span style="color: #F0DFAF; font-weight: bold;">new</span> <span style="color: #7CB8BB;">Foo</span>();
<span style="color: #F0DFAF; font-weight: bold;">for</span>(<span style="color: #7CB8BB;">T</span> <span style="color: #DFAF8F;">t</span> : foo ) {<span style="color: #5F7F5F;">//</span><span style="color: #7F9F7F;">do  something}</span>
</pre>
</div>

<p>
该接口的几个主要API:
</p>
<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">


<colgroup>
<col  class="org-left" />

<col  class="org-left" />
</colgroup>
<thead>
<tr>
<th scope="col" class="org-left">名称</th>
<th scope="col" class="org-left">功能</th>
</tr>
</thead>
<tbody>
<tr>
<td class="org-left">interator()</td>
<td class="org-left">返回一个<a href="#orgheadline27">Iterator</a> 实例, 用于实现对Interable接口的"遍历".</td>
</tr>

<tr>
<td class="org-left">forEach(action)</td>
<td class="org-left">接受一个Cousumer类型的参数action, 然后对"遍历"后的每个元素用action做处理.</td>
</tr>
</tbody>
</table>
</div>
</div>

<div id="outline-container-orgheadline27" class="outline-2">
<h2 id="orgheadline27">Iterator</h2>
<div class="outline-text-2" id="text-orgheadline27">
<p>
Iterator是集合的"迭代器", 提供了对集合进行遍历的方法. Iterator一般
都是依附Iterable存在的. <br  />
Iterator提供的API:
</p>

<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">


<colgroup>
<col  class="org-left" />

<col  class="org-left" />
</colgroup>
<thead>
<tr>
<th scope="col" class="org-left">名称</th>
<th scope="col" class="org-left">功能</th>
</tr>
</thead>
<tbody>
<tr>
<td class="org-left">hasNext()</td>
<td class="org-left">判断集合是否还有元素.</td>
</tr>

<tr>
<td class="org-left">next()</td>
<td class="org-left">返回下一个元素.</td>
</tr>

<tr>
<td class="org-left">remove()</td>
<td class="org-left">删除next()返回的元素.</td>
</tr>

<tr>
<td class="org-left">forEachRemaining(action)</td>
<td class="org-left">对集合剩下的元素执行action动作. action的定义与<a href="#orgheadline28">Iterable</a>介绍的相同.</td>
</tr>
</tbody>
</table>
</div>
</div>

<div id="outline-container-orgheadline29" class="outline-2">
<h2 id="orgheadline29">Collection</h2>
<div class="outline-text-2" id="text-orgheadline29">
<p>
Collection是Java"集合"家族的顶层接口, 继承自<a href="#orgheadline28">Iterable</a>.
定义了集合的一些共同特性:
</p>
<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">


<colgroup>
<col  class="org-left" />

<col  class="org-left" />
</colgroup>
<thead>
<tr>
<th scope="col" class="org-left">API名称</th>
<th scope="col" class="org-left">描述</th>
</tr>
</thead>
<tbody>
<tr>
<td class="org-left">size()</td>
<td class="org-left">集合大小</td>
</tr>

<tr>
<td class="org-left">isEmpty()</td>
<td class="org-left">是否为空</td>
</tr>

<tr>
<td class="org-left">contains()</td>
<td class="org-left">是否包含元素</td>
</tr>

<tr>
<td class="org-left">iterator()</td>
<td class="org-left">返回该集合的迭代器</td>
</tr>

<tr>
<td class="org-left">toArray()/toArray(T[] a)</td>
<td class="org-left">集合转化为数组</td>
</tr>

<tr>
<td class="org-left">add(E e)</td>
<td class="org-left">添加元素</td>
</tr>

<tr>
<td class="org-left">remove(E e)</td>
<td class="org-left">删除元素</td>
</tr>

<tr>
<td class="org-left">addAll(c)</td>
<td class="org-left">添加一个Collection</td>
</tr>

<tr>
<td class="org-left">clear()</td>
<td class="org-left">清空整个集合</td>
</tr>
</tbody>
</table>
</div>
</div>
<div id="outline-container-orgheadline6" class="outline-2">
<h2 id="orgheadline6">List</h2>
<div class="outline-text-2" id="text-orgheadline6">
<p>
List是"队列"家族的抽象类, 队列是一种"有先后顺序"的集合, 队列中的元素
有添加的先后顺序, 新元素都会添加到队列尾部.
该类继承自<a href="#orgheadline29">Collection</a>, 除了<a href="#orgheadline29">Collection</a>的特性, 该类的其他主要特性包括:
</p>
<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">


<colgroup>
<col  class="org-left" />

<col  class="org-left" />
</colgroup>
<thead>
<tr>
<th scope="col" class="org-left">API</th>
<th scope="col" class="org-left">描述</th>
</tr>
</thead>
<tbody>
<tr>
<td class="org-left">add(e)</td>
<td class="org-left">添加到队尾, 返回是否添加成功</td>
</tr>

<tr>
<td class="org-left">remove(e)</td>
<td class="org-left">删除第一次出现的元素</td>
</tr>

<tr>
<td class="org-left">addAll(index, c)</td>
<td class="org-left">将集合c添加到index开始的位置</td>
</tr>

<tr>
<td class="org-left">replaceAll(operator)</td>
<td class="org-left">使用operator来替换所有元素</td>
</tr>

<tr>
<td class="org-left">sort(c)</td>
<td class="org-left">使用Comparator c对队列进行排序</td>
</tr>

<tr>
<td class="org-left">get(index)</td>
<td class="org-left">获取index位置的元素</td>
</tr>

<tr>
<td class="org-left">set(index, e)</td>
<td class="org-left">替换index位置的元素, 返回旧元素</td>
</tr>

<tr>
<td class="org-left">add(index, e)</td>
<td class="org-left">index位置插入一个元素</td>
</tr>

<tr>
<td class="org-left">remove(index)</td>
<td class="org-left">删除index位置的元素</td>
</tr>

<tr>
<td class="org-left">index(e)</td>
<td class="org-left">获取元素在队列中第一次出现的位置, 或-1</td>
</tr>

<tr>
<td class="org-left">lastIndexOf(e)</td>
<td class="org-left">获取元素在队列中最后一次出现的位置, 或-1</td>
</tr>

<tr>
<td class="org-left">subList(start, end)</td>
<td class="org-left">获取[start, end) 位置的子列表</td>
</tr>

<tr>
<td class="org-left">listIterator()</td>
<td class="org-left">获取list的ListIterator</td>
</tr>
</tbody>
</table>

<p>
PS:
</p>
<ol class="org-ol">
<li><p>
replaceAll()实现: 首先获取队列的ListIterator, 然后过该iterator
来操作队列. 
</p>
<div class="org-src-container">

<pre class="src src-java"><span style="color: #F0DFAF; font-weight: bold;">default</span> <span style="color: #7CB8BB;">void</span> <span style="color: #93E0E3;">replaceAll</span>(<span style="color: #7CB8BB;">UnaryOperator</span>&lt;<span style="color: #7CB8BB;">E</span>&gt; <span style="color: #DFAF8F;">operator</span>) {
    Objects.requireNonNull(operator);
    <span style="color: #F0DFAF; font-weight: bold;">final</span> <span style="color: #7CB8BB;">ListIterator</span>&lt;<span style="color: #7CB8BB;">E</span>&gt; <span style="color: #DFAF8F;">li</span> = <span style="color: #F0DFAF; font-weight: bold;">this</span>.listIterator();
    <span style="color: #F0DFAF; font-weight: bold;">while</span> (li.hasNext()) {
        li.set(operator.apply(li.next()));
    }
}
</pre>
</div></li>
<li><p>
sort(Comparator c)实现: 首先调用toArray()方法将队列转化为array,
然后调用 <code>Arrays.sort()</code> 函数来对array进行排序, 最后将排序后的
array通过ListIterator存入队列.
</p>
<div class="org-src-container">

<pre class="src src-java"><span style="color: #F0DFAF; font-weight: bold;">default</span> <span style="color: #7CB8BB;">void</span> <span style="color: #93E0E3;">sort</span>(<span style="color: #7CB8BB;">Comparator</span>&lt;? <span style="color: #F0DFAF; font-weight: bold;">super</span> <span style="color: #7CB8BB;">E</span>&gt; <span style="color: #DFAF8F;">c</span>) {
    <span style="color: #7CB8BB;">Object</span>[] <span style="color: #DFAF8F;">a</span> = <span style="color: #F0DFAF; font-weight: bold;">this</span>.toArray();
    Arrays.sort(a, (<span style="color: #7CB8BB;">Comparator</span>) c);
    <span style="color: #7CB8BB;">ListIterator</span>&lt;<span style="color: #7CB8BB;">E</span>&gt; <span style="color: #DFAF8F;">i</span> = <span style="color: #F0DFAF; font-weight: bold;">this</span>.listIterator();
    <span style="color: #F0DFAF; font-weight: bold;">for</span> (<span style="color: #7CB8BB;">Object</span> <span style="color: #DFAF8F;">e</span> : a) {
        i.next();
        i.set((<span style="color: #7CB8BB;">E</span>) e);
    }
}
</pre>
</div></li>
<li>subList(): 通过该函数返回的子队列, 其数据还是存储在其"父队列"的底层实现中, 
所以对该队列数据的修改都会影响付队列, 同样, 对父队列的修改也会影响子队列.</li>
</ol>
</div>
</div>
<div id="outline-container-orgheadline30" class="outline-2">
<h2 id="orgheadline30">ListIterator</h2>
<div class="outline-text-2" id="text-orgheadline30">
<p>
该类是<a href="#orgheadline6">List</a>类的一个Iterator实现, 继承自<a href="#orgheadline27">Iterator</a>接口, 
其提供了遍历<a href="#orgheadline6">List</a>的接口, 同时对一些接口做了条件约束:
即对<a href="#orgheadline6">List</a>的遍历只能按照"从前向后"或"从后向前"的顺序.<br  />
该类的主要API如下:
</p>
<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">


<colgroup>
<col  class="org-left" />

<col  class="org-left" />
</colgroup>
<thead>
<tr>
<th scope="col" class="org-left">API</th>
<th scope="col" class="org-left">描述</th>
</tr>
</thead>
<tbody>
<tr>
<td class="org-left">hasNext()</td>
<td class="org-left">从前向后遍历,判断是否还有元素</td>
</tr>

<tr>
<td class="org-left">next()</td>
<td class="org-left">从前向后遍历, 返回下一个元素</td>
</tr>

<tr>
<td class="org-left">nextIndex()</td>
<td class="org-left">从前向后遍历, 返回下一个位置</td>
</tr>

<tr>
<td class="org-left">hasPrevious()</td>
<td class="org-left">从后向前遍历, 判断是否还有元素</td>
</tr>

<tr>
<td class="org-left">previous()</td>
<td class="org-left">从后向前, 返回下一个元素</td>
</tr>

<tr>
<td class="org-left">previousIndex()</td>
<td class="org-left">从后向前, 返回下一个元素位置</td>
</tr>

<tr>
<td class="org-left">remove()</td>
<td class="org-left">返回next()或previous()的返回值</td>
</tr>

<tr>
<td class="org-left">set()</td>
<td class="org-left">替换next()或previous()的返回值</td>
</tr>

<tr>
<td class="org-left">add()</td>
<td class="org-left">见注1</td>
</tr>
</tbody>
</table>

<p>
PS:
</p>
<ol class="org-ol">
<li>add(): 插入到next()返回值的"前面", 或previous()返回值的"后面".
另一个观点, 从"从前向后"的视角来看, 新插入的元素永远在当前元素的"前面".</li>
</ol>
</div>
</div>
<div id="outline-container-orgheadline31" class="outline-2">
<h2 id="orgheadline31">AbstractCollection</h2>
<div class="outline-text-2" id="text-orgheadline31">
<p>
AbstractCollection是<a href="#orgheadline29">Collection</a>接口的一个实现, 对于
集合类型的一些"可能"的共同操作, 该类给出了一些API实现, 包括:
</p>
<ol class="org-ol">
<li><p>
isEmpty()
</p>
<div class="org-src-container">

<pre class="src src-java"><span style="color: #F0DFAF; font-weight: bold;">public</span> <span style="color: #7CB8BB;">boolean</span> <span style="color: #93E0E3;">isEmpty</span>() {
    <span style="color: #F0DFAF; font-weight: bold;">return</span> size() == 0;
}
</pre>
</div></li>
<li><p>
contains(o)
该函数实现分两种情况: 如果o为null, 则判断集合中是否包含null. 否则,遍历
集合并调用参数o的equals()方法来判断是否有相等元素. 元素遍历是通过iterator实现.
</p>
<div class="org-src-container">

<pre class="src src-java"><span style="color: #F0DFAF; font-weight: bold;">public</span> <span style="color: #7CB8BB;">boolean</span> <span style="color: #93E0E3;">contains</span>(<span style="color: #7CB8BB;">Object</span> <span style="color: #DFAF8F;">o</span>) {
    <span style="color: #7CB8BB;">Iterator</span>&lt;<span style="color: #7CB8BB;">E</span>&gt; <span style="color: #DFAF8F;">it</span> = iterator();
    <span style="color: #F0DFAF; font-weight: bold;">if</span> (o==<span style="color: #BFEBBF;">null</span>) {
        <span style="color: #F0DFAF; font-weight: bold;">while</span> (it.hasNext())
            <span style="color: #F0DFAF; font-weight: bold;">if</span> (it.next()==<span style="color: #BFEBBF;">null</span>)
                <span style="color: #F0DFAF; font-weight: bold;">return</span> <span style="color: #BFEBBF;">true</span>;
    } <span style="color: #F0DFAF; font-weight: bold;">else</span> {
        <span style="color: #F0DFAF; font-weight: bold;">while</span> (it.hasNext())
            <span style="color: #F0DFAF; font-weight: bold;">if</span> (o.equals(it.next()))
                <span style="color: #F0DFAF; font-weight: bold;">return</span> <span style="color: #BFEBBF;">true</span>;
    }
    <span style="color: #F0DFAF; font-weight: bold;">return</span> <span style="color: #BFEBBF;">false</span>;
}
</pre>
</div></li>
<li><p>
toArray()
该函数用于将集合转换为数组, 需要关注的是, 在转化过程中, 集合的
结构可能被修改(多线程), 即元素被添加或删除.<br  />
该函数的实现也cover了这种情况. 从下面代码可以看到, 
</p>
<ol class="org-ol">
<li>在每次for循环开始都会调用hasNext()判断是已经到结尾(即期间有元素被删除). 
如果是, 则直接调用Array的copyOf()函数把返回临时数组的一个copy, 该临时数组
用于存储已经遍历过的元素.</li>
<li>遍历完之后, 还会再次调用hasNext()判断是否有新元素, 如果有, 则调用finishToArray()
函数继续对集合进行变量, 并分配一个更大的数组, 知道集合变量完或者达到数组上限.</li>
</ol>
<div class="org-src-container">

<pre class="src src-java"><span style="color: #F0DFAF; font-weight: bold;">public</span> <span style="color: #7CB8BB;">Object</span>[] <span style="color: #93E0E3;">toArray</span>() {
    <span style="color: #5F7F5F;">// </span><span style="color: #7F9F7F;">Estimate size of array; be prepared to see more or fewer elements</span>
    <span style="color: #7CB8BB;">Object</span>[] <span style="color: #DFAF8F;">r</span> = <span style="color: #F0DFAF; font-weight: bold;">new</span> <span style="color: #7CB8BB;">Object</span>[size()];
    <span style="color: #7CB8BB;">Iterator</span>&lt;<span style="color: #7CB8BB;">E</span>&gt; <span style="color: #DFAF8F;">it</span> = iterator();
    <span style="color: #F0DFAF; font-weight: bold;">for</span> (<span style="color: #7CB8BB;">int</span> <span style="color: #DFAF8F;">i</span> = 0; i &lt; r.<span style="color: #7CB8BB;">length</span>; i++) {
        <span style="color: #F0DFAF; font-weight: bold;">if</span> (<span style="color: #F0DFAF; font-weight: bold;">!</span> it.hasNext()) <span style="color: #5F7F5F;">// </span><span style="color: #7F9F7F;">fewer elements than expected</span>
            <span style="color: #F0DFAF; font-weight: bold;">return</span> Arrays.copyOf(r, i);
        r[i] = it.next();
    }
    <span style="color: #F0DFAF; font-weight: bold;">return</span> it.hasNext() ? finishToArray(r, it) : r;
}
</pre>
</div></li>
<li>toArray(T[] a)
如果a的size足够能容下集合元素, 则存入a中并返回a, 否则存入一个新分配的数组并返回.</li>
<li>remove(): 实现方式与contains()相同, 也是通过iterator进行操作.</li>
<li>containsAll()/addAll()/removeAll()<br  />
实现方式基本相同, 都是遍历参数集合, 然后基于参数中的每个元素
对集合进行操作.</li>
<li>retainAll(c). 只保留c和该集合的"交集"元素.</li>
<li><p>
clear(): 反复调用iterator的hasNext(), next(), remove()函数删除所有元素.
</p>
<div class="org-src-container">

<pre class="src src-java"><span style="color: #F0DFAF; font-weight: bold;">public</span> <span style="color: #7CB8BB;">void</span> <span style="color: #93E0E3;">clear</span>() {
    <span style="color: #7CB8BB;">Iterator</span>&lt;<span style="color: #7CB8BB;">E</span>&gt; <span style="color: #DFAF8F;">it</span> = iterator();
    <span style="color: #F0DFAF; font-weight: bold;">while</span> (it.hasNext()) {
        it.next();
        it.remove();
    }
}
</pre>
</div></li>
</ol>
</div>
</div>
<div id="outline-container-orgheadline5" class="outline-2">
<h2 id="orgheadline5">AbstractList</h2>
<div class="outline-text-2" id="text-orgheadline5">
<p>
该类是<a href="#orgheadline31">AbstractCollection</a>的一个子类并实现了<a href="#orgheadline6">List</a>接口, 该类实现了
List相关的一些共同操作. 包括:
</p>
<ol class="org-ol">
<li><p>
indexOf(o):寻找元素位置. 该函数的实现使用了previousIndex()函数, 因为
调用next()之后, iterator会移动到下一位, 所以需要调用这个函数才能获取
到"命中元素"的位置.
</p>
<div class="org-src-container">

<pre class="src src-java"><span style="color: #F0DFAF; font-weight: bold;">public</span> <span style="color: #7CB8BB;">int</span> <span style="color: #93E0E3;">indexOf</span>(<span style="color: #7CB8BB;">Object</span> <span style="color: #DFAF8F;">o</span>) {
    <span style="color: #7CB8BB;">ListIterator</span>&lt;<span style="color: #7CB8BB;">E</span>&gt; <span style="color: #DFAF8F;">it</span> = listIterator();
    <span style="color: #F0DFAF; font-weight: bold;">if</span> (o==<span style="color: #BFEBBF;">null</span>) {
        <span style="color: #F0DFAF; font-weight: bold;">while</span> (it.hasNext())
            <span style="color: #F0DFAF; font-weight: bold;">if</span> (it.next()==<span style="color: #BFEBBF;">null</span>)
                <span style="color: #F0DFAF; font-weight: bold;">return</span> it.previousIndex();
    } <span style="color: #F0DFAF; font-weight: bold;">else</span> {
        <span style="color: #F0DFAF; font-weight: bold;">while</span> (it.hasNext())
            <span style="color: #F0DFAF; font-weight: bold;">if</span> (o.equals(it.next()))
                <span style="color: #F0DFAF; font-weight: bold;">return</span> it.previousIndex();
    }
    <span style="color: #F0DFAF; font-weight: bold;">return</span> -1;
}
</pre>
</div></li>
<li>lastIndexOf(o): 实现方式与indexOf()相同, 只是遍历顺序相反.</li>
</ol>
</div>

<div id="outline-container-orgheadline32" class="outline-3">
<h3 id="orgheadline32">Itr</h3>
<div class="outline-text-3" id="text-orgheadline32">
<p>
该类是AbstractList的一个内部类, 在List的层级结构中, 是第一次具体实现
一个Iterator. 可以看下该类是如何具体实现<a href="#orgheadline27">Iterator</a>的API的.
</p>
<ol class="org-ol">
<li><p>
hasNext():判断当前的光标是否等于size()函数. 如果等于, 表示到达尾部, 返回false.
</p>
<div class="org-src-container">

<pre class="src src-java"><span style="color: #F0DFAF; font-weight: bold;">public</span> <span style="color: #7CB8BB;">boolean</span> <span style="color: #93E0E3;">hasNext</span>() {
    <span style="color: #F0DFAF; font-weight: bold;">return</span> cursor != size();
}
</pre>
</div></li>
<li><p>
next():返回下一个元素. 由于光标一开始是指向第一个元素(index=0), 
所以每次调用该函数, 返回的都是当前光标位置的元素, 然后再把光标
移动一个位置. 同时有一个成员变量 lastRet 用于记录这次返回值的位置.
</p>
<div class="org-src-container">

<pre class="src src-java">   <span style="color: #F0DFAF; font-weight: bold;">public</span> <span style="color: #7CB8BB;">E</span> <span style="color: #93E0E3;">next</span>() {
    checkForComodification();
    <span style="color: #F0DFAF; font-weight: bold;">try</span> {
        <span style="color: #7CB8BB;">int</span> <span style="color: #DFAF8F;">i</span> = cursor;
        <span style="color: #7CB8BB;">E</span> <span style="color: #DFAF8F;">next</span> = get(i);
        lastRet = i;
        cursor = i + 1;
        <span style="color: #F0DFAF; font-weight: bold;">return</span> next;
    } <span style="color: #F0DFAF; font-weight: bold;">catch</span> (<span style="color: #7CB8BB;">IndexOutOfBoundsException</span> <span style="color: #DFAF8F;">e</span>) {
        checkForComodification();
        <span style="color: #F0DFAF; font-weight: bold;">throw</span> <span style="color: #F0DFAF; font-weight: bold;">new</span> <span style="color: #7CB8BB;">NoSuchElementException</span>();
    }
}
</pre>
</div>

<p>
在函数的开始调用了 <code>checkForComodification()</code> 函数, 该函数用于
判断是否有其他线程操作了该iterator所属的集合.它的实现原理是:
Iterator有一个成员变量expectedModcount, 其值等于集合的变量modCount, 
每次集合被修改(添加/删除), modCount的值都会发生变化. 所以如果发现
expectedModcount的值与该值不相等了, 说明"集合"被其他线程修改了. 
在AbstractList中就会抛异常.
</p>
<div class="org-src-container">

<pre class="src src-java"><span style="color: #F0DFAF; font-weight: bold;">final</span> <span style="color: #7CB8BB;">void</span> <span style="color: #93E0E3;">checkForComodification</span>() {
     <span style="color: #F0DFAF; font-weight: bold;">if</span> (modCount != expectedModCount)
         <span style="color: #F0DFAF; font-weight: bold;">throw</span> <span style="color: #F0DFAF; font-weight: bold;">new</span> <span style="color: #7CB8BB;">ConcurrentModificationException</span>();
 }
</pre>
</div></li>
<li>remove():
如果当前光标没有指向list区间, 则抛异常. 否则调用 <a href="#orgheadline5">AbstractList</a>的remove()函数.
然后将缓存光标 lastRet 置位-1. 并重新赋值 expectedModcount(因为AbstractList的
remove()函数可能会修改modCount的值).</li>
</ol>
</div>
</div>
<div id="outline-container-orgheadline33" class="outline-3">
<h3 id="orgheadline33">ListItr</h3>
<div class="outline-text-3" id="text-orgheadline33">
<p>
该类是<a href="#orgheadline32">Itr</a>的子类并实现了<a href="#orgheadline30">ListIterator</a>接口. 主要是实现了ListIterator"从后向前"的遍历方法.
</p>
<ol class="org-ol">
<li>构造函数ListItr(index):
直接将光标至于index的位置.</li>
<li>hasPrevious():判断当前光标是否为0, 如果是返回false.</li>
<li><p>
previous(): 返回当前光标的前一个元素. 这里与next()不同, 
next()是先返回当前光标的值, 移动光标. previous()是返回
当前光标前面的值, 并移动光标. 
</p>
<div class="org-src-container">

<pre class="src src-java"><span style="color: #F0DFAF; font-weight: bold;">public</span> <span style="color: #7CB8BB;">E</span> <span style="color: #93E0E3;">previous</span>() {
    checkForComodification();
    <span style="color: #F0DFAF; font-weight: bold;">try</span> {
        <span style="color: #7CB8BB;">int</span> <span style="color: #DFAF8F;">i</span> = cursor - 1;
        <span style="color: #7CB8BB;">E</span> <span style="color: #DFAF8F;">previous</span> = get(i);
        lastRet = cursor = i;
        <span style="color: #F0DFAF; font-weight: bold;">return</span> previous;
    } <span style="color: #F0DFAF; font-weight: bold;">catch</span> (<span style="color: #7CB8BB;">IndexOutOfBoundsException</span> <span style="color: #DFAF8F;">e</span>) {
        checkForComodification();
        <span style="color: #F0DFAF; font-weight: bold;">throw</span> <span style="color: #F0DFAF; font-weight: bold;">new</span> <span style="color: #7CB8BB;">NoSuchElementException</span>();
    }
}
</pre>
</div></li>
<li>nextIndex(): 返回当前光标.</li>
<li>previousIndex(): 返回当前光标减1.</li>
</ol>
</div>
</div>
<div id="outline-container-orgheadline34" class="outline-3">
<h3 id="orgheadline34">SubList</h3>
<div class="outline-text-3" id="text-orgheadline34">
<p>
该类是AbstractList的子类,是"子队列"概念的代码实现. 代表了某个
队列的一部分. 在其实现中, 其内容存储在原列表的底层存储中. 该类
只维护了一些"列表"状态, 来表示子对类. 任何对该类的队列的修改都会
影响到原列表, 反之亦然. 通过下面的几个函数可以看出对该类的增删其实调用的
都是原来队列的方法.
</p>
<div class="org-src-container">

<pre class="src src-java"><span style="color: #93E0E3;">SubList</span>(<span style="color: #7CB8BB;">AbstractList</span>&lt;<span style="color: #7CB8BB;">E</span>&gt; <span style="color: #DFAF8F;">list</span>, <span style="color: #7CB8BB;">int</span> <span style="color: #DFAF8F;">fromIndex</span>, <span style="color: #7CB8BB;">int</span> <span style="color: #DFAF8F;">toIndex</span>) {
    <span style="color: #F0DFAF; font-weight: bold;">if</span> (fromIndex &lt; 0)
        <span style="color: #F0DFAF; font-weight: bold;">throw</span> <span style="color: #F0DFAF; font-weight: bold;">new</span> <span style="color: #7CB8BB;">IndexOutOfBoundsException</span>(<span style="color: #CC9393;">"fromIndex = "</span> + fromIndex);
    <span style="color: #F0DFAF; font-weight: bold;">if</span> (toIndex &gt; list.size())
        <span style="color: #F0DFAF; font-weight: bold;">throw</span> <span style="color: #F0DFAF; font-weight: bold;">new</span> <span style="color: #7CB8BB;">IndexOutOfBoundsException</span>(<span style="color: #CC9393;">"toIndex = "</span> + toIndex);
    <span style="color: #F0DFAF; font-weight: bold;">if</span> (fromIndex &gt; toIndex)
        <span style="color: #F0DFAF; font-weight: bold;">throw</span> <span style="color: #F0DFAF; font-weight: bold;">new</span> <span style="color: #7CB8BB;">IllegalArgumentException</span>(<span style="color: #CC9393;">"fromIndex("</span> + fromIndex +
                                           <span style="color: #CC9393;">") &gt; toIndex("</span> + toIndex + <span style="color: #CC9393;">")"</span>);
    l = list;
    offset = fromIndex;
    size = toIndex - fromIndex;
    <span style="color: #F0DFAF; font-weight: bold;">this</span>.modCount = l.modCount;
}

<span style="color: #F0DFAF; font-weight: bold;">public</span> <span style="color: #7CB8BB;">E</span> <span style="color: #93E0E3;">set</span>(<span style="color: #7CB8BB;">int</span> <span style="color: #DFAF8F;">index</span>, <span style="color: #7CB8BB;">E</span> <span style="color: #DFAF8F;">element</span>) {
    rangeCheck(index);
    checkForComodification();
    <span style="color: #F0DFAF; font-weight: bold;">return</span> l.set(index+offset, element);
}

<span style="color: #F0DFAF; font-weight: bold;">public</span> <span style="color: #7CB8BB;">E</span> <span style="color: #93E0E3;">get</span>(<span style="color: #7CB8BB;">int</span> <span style="color: #DFAF8F;">index</span>) {
    rangeCheck(index);
    checkForComodification();
    <span style="color: #F0DFAF; font-weight: bold;">return</span> l.get(index+offset);
}

<span style="color: #F0DFAF; font-weight: bold;">public</span> <span style="color: #7CB8BB;">void</span> <span style="color: #93E0E3;">add</span>(<span style="color: #7CB8BB;">int</span> <span style="color: #DFAF8F;">index</span>, <span style="color: #7CB8BB;">E</span> <span style="color: #DFAF8F;">element</span>) {
    rangeCheckForAdd(index);
    checkForComodification();
    l.add(index+offset, element);
    <span style="color: #F0DFAF; font-weight: bold;">this</span>.modCount = l.modCount;
    size++;
}

<span style="color: #F0DFAF; font-weight: bold;">public</span> <span style="color: #7CB8BB;">E</span> <span style="color: #93E0E3;">remove</span>(<span style="color: #7CB8BB;">int</span> <span style="color: #DFAF8F;">index</span>) {
    rangeCheck(index);
    checkForComodification();
    <span style="color: #7CB8BB;">E</span> <span style="color: #DFAF8F;">result</span> = l.remove(index+offset);
    <span style="color: #F0DFAF; font-weight: bold;">this</span>.modCount = l.modCount;
    size--;
    <span style="color: #F0DFAF; font-weight: bold;">return</span> result;
}
</pre>
</div>
</div>
</div>
<div id="outline-container-orgheadline35" class="outline-3">
<h3 id="orgheadline35">RandomAccessSubList</h3>
<div class="outline-text-3" id="text-orgheadline35">
<p>
该类是<a href="#orgheadline34">SubList</a>的一个子类, 但是实现了RandomAccess接口(空接口),
表明其具有RandomAccess的属性. 该类的所有操作几乎都是使用<a href="#orgheadline34">SubList</a>的操作. 
</p>

<p>
在AbstractList的subList()函数实现中, 会判断当前List是否为RandomAccess,
如果是, 则会返回一个 RandomAccessSubList 实例, 否则返回一个 SubList 实例. 
</p>
<div class="org-src-container">

<pre class="src src-java"><span style="color: #F0DFAF; font-weight: bold;">public</span> <span style="color: #7CB8BB;">List</span>&lt;<span style="color: #7CB8BB;">E</span>&gt; <span style="color: #93E0E3;">subList</span>(<span style="color: #7CB8BB;">int</span> <span style="color: #DFAF8F;">fromIndex</span>, <span style="color: #7CB8BB;">int</span> <span style="color: #DFAF8F;">toIndex</span>) {
    <span style="color: #F0DFAF; font-weight: bold;">return</span> (<span style="color: #F0DFAF; font-weight: bold;">this</span> <span style="color: #F0DFAF; font-weight: bold;">instanceof</span> RandomAccess ?
            <span style="color: #F0DFAF; font-weight: bold;">new</span> <span style="color: #7CB8BB;">RandomAccessSubList</span>&lt;&gt;(<span style="color: #F0DFAF; font-weight: bold;">this</span>, fromIndex, toIndex) :
            <span style="color: #F0DFAF; font-weight: bold;">new</span> <span style="color: #7CB8BB;">SubList</span>&lt;&gt;(<span style="color: #F0DFAF; font-weight: bold;">this</span>, fromIndex, toIndex));
}
</pre>
</div>
</div>
</div>
</div>
<div id="outline-container-orgheadline36" class="outline-2">
<h2 id="orgheadline36">AbstractSequentialList</h2>
<div class="outline-text-2" id="text-orgheadline36">
<p>
在介绍LinkedList之前, 先看一下它的父类, 该类是<a href="#orgheadline5">AbstractList</a>的
子类, 但是它具有"顺序"的属性, 这是相对于ArrayList的RandomAccess属性而言. 
官方文档中对该属性是这样解释的. 
</p>
<div class="org-src-container">

<pre class="src src-java">* This <span style="color: #F0DFAF; font-weight: bold;">class</span> is the opposite of <span style="color: #7CB8BB;">the</span> &lt;<span style="color: #7CB8BB;">tt</span>&gt;AbstractList&lt;/tt&gt; <span style="color: #F0DFAF; font-weight: bold;">class</span> in the sense
* that it <span style="color: #F0DFAF; font-weight: bold;">implements</span> <span style="color: #7CB8BB;">the</span> <span style="color: #CC9393;">"random access"</span> methods (&lt;<span style="color: #7CB8BB;">tt</span>&gt;get(<span style="color: #7CB8BB;">int</span> <span style="color: #DFAF8F;">index</span>)&lt;/tt&gt;,
* &lt;<span style="color: #7CB8BB;">tt</span>&gt;set(<span style="color: #7CB8BB;">int</span> <span style="color: #DFAF8F;">index</span>, <span style="color: #7CB8BB;">E</span> <span style="color: #DFAF8F;">element</span>)&lt;/tt&gt;, &lt;<span style="color: #7CB8BB;">tt</span>&gt;add(<span style="color: #7CB8BB;">int</span> <span style="color: #DFAF8F;">index</span>, <span style="color: #7CB8BB;">E</span> <span style="color: #DFAF8F;">element</span>)&lt;/tt&gt; and
* &lt;<span style="color: #7CB8BB;">tt</span>&gt;remove(<span style="color: #7CB8BB;">int</span> <span style="color: #DFAF8F;">index</span>)&lt;/tt&gt;) on top of the list<span style="color: #D0BF8F; font-weight: bold;">'</span><span style="color: #CC9393;">s list iterator, instead of</span>
<span style="color: #CC9393;">* the other way around.&lt;p&gt;</span>
</pre>
</div>

<p>
上面这段文字解释了在该类中通过index "插入/删除" 元素的实现方法.
都是通过其ListIterator实现的. (想想在<a href="#orgheadline26">ArrayList</a>中,这些方法都是直接
操作数组). 可以看下几个相关的API代码.
</p>
<div class="org-src-container">

<pre class="src src-java"><span style="color: #F0DFAF; font-weight: bold;">public</span> <span style="color: #7CB8BB;">void</span> <span style="color: #93E0E3;">add</span>(<span style="color: #7CB8BB;">int</span> <span style="color: #DFAF8F;">index</span>, <span style="color: #7CB8BB;">E</span> <span style="color: #DFAF8F;">element</span>) {
    <span style="color: #F0DFAF; font-weight: bold;">try</span> {
        listIterator(index).add(element);
    } <span style="color: #F0DFAF; font-weight: bold;">catch</span> (<span style="color: #7CB8BB;">NoSuchElementException</span> <span style="color: #DFAF8F;">exc</span>) {
        <span style="color: #F0DFAF; font-weight: bold;">throw</span> <span style="color: #F0DFAF; font-weight: bold;">new</span> <span style="color: #7CB8BB;">IndexOutOfBoundsException</span>(<span style="color: #CC9393;">"Index: "</span>+index);
    }
}
<span style="color: #F0DFAF; font-weight: bold;">public</span> <span style="color: #7CB8BB;">E</span> <span style="color: #93E0E3;">remove</span>(<span style="color: #7CB8BB;">int</span> <span style="color: #DFAF8F;">index</span>) {
    <span style="color: #F0DFAF; font-weight: bold;">try</span> {
        <span style="color: #7CB8BB;">ListIterator</span>&lt;<span style="color: #7CB8BB;">E</span>&gt; <span style="color: #DFAF8F;">e</span> = listIterator(index);
        <span style="color: #7CB8BB;">E</span> <span style="color: #DFAF8F;">outCast</span> = e.next();
        e.remove();
        <span style="color: #F0DFAF; font-weight: bold;">return</span> outCast;
    } <span style="color: #F0DFAF; font-weight: bold;">catch</span> (<span style="color: #7CB8BB;">NoSuchElementException</span> <span style="color: #DFAF8F;">exc</span>) {
        <span style="color: #F0DFAF; font-weight: bold;">throw</span> <span style="color: #F0DFAF; font-weight: bold;">new</span> <span style="color: #7CB8BB;">IndexOutOfBoundsException</span>(<span style="color: #CC9393;">"Index: "</span>+index);
    }
}
</pre>
</div>

<p>
另外, 该类的 iterator() 和 listIterator() 函数返回的都是
ListIterator实例.
</p>
</div>
</div>
<div id="outline-container-orgheadline37" class="outline-2">
<h2 id="orgheadline37">Deque</h2>
<div class="outline-text-2" id="text-orgheadline37">
<p>
双端队列, 支持头部和尾部的插入和删除动作. 
Deque接口提供了这些操作的相应API.
</p>
</div>
</div>
<div id="outline-container-orgheadline38" class="outline-2">
<h2 id="orgheadline38">LinkedList</h2>
<div class="outline-text-2" id="text-orgheadline38">
<p>
继承自<a href="#orgheadline36">AbstractSequentialList</a>, 并实现了 <a href="#orgheadline6">List</a> 和 <a href="#orgheadline37">Deque</a> 接口.
</p>

<p>
不过与<a href="#orgheadline36">AbstractSequentialList</a>不同的是, LinkedList的插入删除并
没有使用ListIterator, 而是直接操作链表. 下面是一些核心API:
</p>
<ol class="org-ol">
<li><p>
unlink(e): 删除元素, "几乎"所有删除API的底层实现. 
与<a href="#orgheadline26">ArrayList</a>不同的是, 它没有设计到"一片内存"区域的移动, 所以
效率上要比ArrayList高.
</p>
<div class="org-src-container">

<pre class="src src-java"><span style="color: #7CB8BB;">E</span> <span style="color: #93E0E3;">unlink</span>(<span style="color: #7CB8BB;">Node</span>&lt;<span style="color: #7CB8BB;">E</span>&gt; <span style="color: #DFAF8F;">x</span>) {
    <span style="color: #5F7F5F;">// </span><span style="color: #7F9F7F;">assert x != null;</span>
    <span style="color: #F0DFAF; font-weight: bold;">final</span> <span style="color: #7CB8BB;">E</span> <span style="color: #DFAF8F;">element</span> = x.item;
    <span style="color: #F0DFAF; font-weight: bold;">final</span> <span style="color: #7CB8BB;">Node</span>&lt;<span style="color: #7CB8BB;">E</span>&gt; <span style="color: #DFAF8F;">next</span> = x.next;
    <span style="color: #F0DFAF; font-weight: bold;">final</span> <span style="color: #7CB8BB;">Node</span>&lt;<span style="color: #7CB8BB;">E</span>&gt; <span style="color: #DFAF8F;">prev</span> = x.prev;

    <span style="color: #F0DFAF; font-weight: bold;">if</span> (prev == <span style="color: #BFEBBF;">null</span>) {
        first = next;
    } <span style="color: #F0DFAF; font-weight: bold;">else</span> {
        prev.next = next;
        x.prev = <span style="color: #BFEBBF;">null</span>;
    }

    <span style="color: #F0DFAF; font-weight: bold;">if</span> (next == <span style="color: #BFEBBF;">null</span>) {
        last = prev;
    } <span style="color: #F0DFAF; font-weight: bold;">else</span> {
        next.prev = prev;
        x.next = <span style="color: #BFEBBF;">null</span>;
    }

    x.item = <span style="color: #BFEBBF;">null</span>;
    size--;
    modCount++;
    <span style="color: #F0DFAF; font-weight: bold;">return</span> element;
}
</pre>
</div></li>
<li>linkBefore(e, node): 插入元素,实现原理同unlink().</li>
<li><p>
node(index): 获取index位置的node, "几乎" 所有遍历类的底层实现.
这需要遍历链表, 不过因为LinkedList是双向列表, 
所以该函数的实现上也有点技巧: 即如果index &gt; size/2, 则从队列
尾部向前寻找, 否则从队列头部向后寻找.
</p>
<div class="org-src-container">

<pre class="src src-java"><span style="color: #7CB8BB;">Node</span>&lt;<span style="color: #7CB8BB;">E</span>&gt; <span style="color: #93E0E3;">node</span>(<span style="color: #7CB8BB;">int</span> <span style="color: #DFAF8F;">index</span>) {
    <span style="color: #5F7F5F;">// </span><span style="color: #7F9F7F;">assert isElementIndex(index);</span>

    <span style="color: #F0DFAF; font-weight: bold;">if</span> (index &lt; (size &gt;&gt; 1)) {
        <span style="color: #7CB8BB;">Node</span>&lt;<span style="color: #7CB8BB;">E</span>&gt; <span style="color: #DFAF8F;">x</span> = first;
        <span style="color: #F0DFAF; font-weight: bold;">for</span> (<span style="color: #7CB8BB;">int</span> <span style="color: #DFAF8F;">i</span> = 0; i &lt; <span style="color: #7CB8BB;">index</span>; i++)
            x = x.next;
        <span style="color: #F0DFAF; font-weight: bold;">return</span> x;
    } <span style="color: #F0DFAF; font-weight: bold;">else</span> {
        <span style="color: #7CB8BB;">Node</span>&lt;<span style="color: #7CB8BB;">E</span>&gt; <span style="color: #DFAF8F;">x</span> = last;
        <span style="color: #F0DFAF; font-weight: bold;">for</span> (<span style="color: #7CB8BB;">int</span> <span style="color: #DFAF8F;">i</span> = size - 1; i &gt; index; i--)
            x = x.prev;
        <span style="color: #F0DFAF; font-weight: bold;">return</span> x;
    }
}
</pre>
</div></li>
</ol>

<p>
这三个函数基本就是LinkedList的核心原理. 
</p>
</div>
<div id="outline-container-orgheadline39" class="outline-3">
<h3 id="orgheadline39">Node</h3>
<div class="outline-text-3" id="text-orgheadline39">
<p>
LinkedList是使用"链表"这种数据结构来存储数据, 所以其内部定义了一个
Node类用来表示链表节点. Node类的实现很简单.
</p>
<div class="org-src-container">

<pre class="src src-java"><span style="color: #F0DFAF; font-weight: bold;">private</span> <span style="color: #F0DFAF; font-weight: bold;">static</span> <span style="color: #F0DFAF; font-weight: bold;">class</span> <span style="color: #7CB8BB;">Node</span>&lt;<span style="color: #7CB8BB;">E</span>&gt; {
    <span style="color: #7CB8BB;">E</span> <span style="color: #DFAF8F;">item</span>;
    <span style="color: #7CB8BB;">Node</span>&lt;<span style="color: #7CB8BB;">E</span>&gt; <span style="color: #DFAF8F;">next</span>;
    <span style="color: #7CB8BB;">Node</span>&lt;<span style="color: #7CB8BB;">E</span>&gt; <span style="color: #DFAF8F;">prev</span>;

    <span style="color: #93E0E3;">Node</span>(<span style="color: #7CB8BB;">Node</span>&lt;<span style="color: #7CB8BB;">E</span>&gt; <span style="color: #DFAF8F;">prev</span>, <span style="color: #7CB8BB;">E</span> <span style="color: #DFAF8F;">element</span>, <span style="color: #7CB8BB;">Node</span>&lt;<span style="color: #7CB8BB;">E</span>&gt; <span style="color: #DFAF8F;">next</span>) {
        <span style="color: #F0DFAF; font-weight: bold;">this</span>.item = element;
        <span style="color: #F0DFAF; font-weight: bold;">this</span>.next = next;
        <span style="color: #F0DFAF; font-weight: bold;">this</span>.prev = prev;
    }
}
</pre>
</div>
</div>
</div>
</div>
<div id="outline-container-orgheadline40" class="outline-2">
<h2 id="orgheadline40">SynchronizedList</h2>
<div class="outline-text-2" id="text-orgheadline40">
<p>
由于List类不是线程安全的. 多线程可以同时修改list的内容. 
所以为了解决这个问题, Collections类提供了一个 
<code>snchronizedList()</code> 函数用于将 <a href="#orgheadline6">List</a> 转化为一个 "同步" list.
其基本原理类似于adapter模式, 实现了一个新的list, 被提供了
同步功能. 看下部分源码:
</p>
<div class="org-src-container">

<pre class="src src-java"><span style="color: #F0DFAF; font-weight: bold;">public</span> <span style="color: #F0DFAF; font-weight: bold;">static</span> &lt;<span style="color: #7CB8BB;">T</span>&gt; <span style="color: #7CB8BB;">List</span>&lt;<span style="color: #7CB8BB;">T</span>&gt; <span style="color: #93E0E3;">synchronizedList</span>(<span style="color: #7CB8BB;">List</span>&lt;<span style="color: #7CB8BB;">T</span>&gt; <span style="color: #DFAF8F;">list</span>) {
    <span style="color: #F0DFAF; font-weight: bold;">return</span> (list <span style="color: #F0DFAF; font-weight: bold;">instanceof</span> RandomAccess ?
            <span style="color: #F0DFAF; font-weight: bold;">new</span> <span style="color: #7CB8BB;">SynchronizedRandomAccessList</span>&lt;&gt;(list) :
            <span style="color: #F0DFAF; font-weight: bold;">new</span> <span style="color: #7CB8BB;">SynchronizedList</span>&lt;&gt;(list));
}

<span style="color: #F0DFAF; font-weight: bold;">static</span> <span style="color: #F0DFAF; font-weight: bold;">class</span> <span style="color: #7CB8BB;">SynchronizedList</span>&lt;<span style="color: #7CB8BB;">E</span>&gt;
    <span style="color: #F0DFAF; font-weight: bold;">extends</span> <span style="color: #7CB8BB;">SynchronizedCollection</span>&lt;<span style="color: #7CB8BB;">E</span>&gt;
    <span style="color: #F0DFAF; font-weight: bold;">implements</span> <span style="color: #7CB8BB;">List</span>&lt;<span style="color: #7CB8BB;">E</span>&gt; {
    <span style="color: #F0DFAF; font-weight: bold;">private</span> <span style="color: #F0DFAF; font-weight: bold;">static</span> <span style="color: #F0DFAF; font-weight: bold;">final</span> <span style="color: #7CB8BB;">long</span> <span style="color: #DFAF8F;">serialVersionUID</span> = -7754090372962971524L;

    <span style="color: #F0DFAF; font-weight: bold;">final</span> <span style="color: #7CB8BB;">List</span>&lt;<span style="color: #7CB8BB;">E</span>&gt; <span style="color: #DFAF8F;">list</span>;

    <span style="color: #93E0E3;">SynchronizedList</span>(<span style="color: #7CB8BB;">List</span>&lt;<span style="color: #7CB8BB;">E</span>&gt; <span style="color: #DFAF8F;">list</span>) {
        <span style="color: #F0DFAF; font-weight: bold;">super</span>(list);
        <span style="color: #F0DFAF; font-weight: bold;">this</span>.list = list;
    }
    <span style="color: #93E0E3;">SynchronizedList</span>(<span style="color: #7CB8BB;">List</span>&lt;<span style="color: #7CB8BB;">E</span>&gt; <span style="color: #DFAF8F;">list</span>, <span style="color: #7CB8BB;">Object</span> <span style="color: #DFAF8F;">mutex</span>) {
        <span style="color: #F0DFAF; font-weight: bold;">super</span>(list, mutex);
        <span style="color: #F0DFAF; font-weight: bold;">this</span>.list = list;
    }

    <span style="color: #F0DFAF; font-weight: bold;">public</span> <span style="color: #7CB8BB;">boolean</span> <span style="color: #93E0E3;">equals</span>(<span style="color: #7CB8BB;">Object</span> <span style="color: #DFAF8F;">o</span>) {
        <span style="color: #F0DFAF; font-weight: bold;">if</span> (<span style="color: #F0DFAF; font-weight: bold;">this</span> == o)
            <span style="color: #F0DFAF; font-weight: bold;">return</span> <span style="color: #BFEBBF;">true</span>;
        <span style="color: #F0DFAF; font-weight: bold;">synchronized</span> (mutex) {<span style="color: #F0DFAF; font-weight: bold;">return</span> list.equals(o);}
    }
    <span style="color: #F0DFAF; font-weight: bold;">public</span> <span style="color: #7CB8BB;">int</span> <span style="color: #93E0E3;">hashCode</span>() {
        <span style="color: #F0DFAF; font-weight: bold;">synchronized</span> (mutex) {<span style="color: #F0DFAF; font-weight: bold;">return</span> list.hashCode();}
    }

    <span style="color: #F0DFAF; font-weight: bold;">public</span> <span style="color: #7CB8BB;">E</span> <span style="color: #93E0E3;">get</span>(<span style="color: #7CB8BB;">int</span> <span style="color: #DFAF8F;">index</span>) {
        <span style="color: #F0DFAF; font-weight: bold;">synchronized</span> (mutex) {<span style="color: #F0DFAF; font-weight: bold;">return</span> list.get(index);}
    }
    <span style="color: #F0DFAF; font-weight: bold;">public</span> <span style="color: #7CB8BB;">E</span> <span style="color: #93E0E3;">set</span>(<span style="color: #7CB8BB;">int</span> <span style="color: #DFAF8F;">index</span>, <span style="color: #7CB8BB;">E</span> <span style="color: #DFAF8F;">element</span>) {
        <span style="color: #F0DFAF; font-weight: bold;">synchronized</span> (mutex) {<span style="color: #F0DFAF; font-weight: bold;">return</span> list.set(index, element);}
    }
    <span style="color: #F0DFAF; font-weight: bold;">public</span> <span style="color: #7CB8BB;">void</span> <span style="color: #93E0E3;">add</span>(<span style="color: #7CB8BB;">int</span> <span style="color: #DFAF8F;">index</span>, <span style="color: #7CB8BB;">E</span> <span style="color: #DFAF8F;">element</span>) {
        <span style="color: #F0DFAF; font-weight: bold;">synchronized</span> (mutex) {list.add(index, element);}
    }
    <span style="color: #F0DFAF; font-weight: bold;">public</span> <span style="color: #7CB8BB;">E</span> <span style="color: #93E0E3;">remove</span>(<span style="color: #7CB8BB;">int</span> <span style="color: #DFAF8F;">index</span>) {
        <span style="color: #F0DFAF; font-weight: bold;">synchronized</span> (mutex) {<span style="color: #F0DFAF; font-weight: bold;">return</span> list.remove(index);}
    }
</pre>
</div>
</div>
</div>
</div>
<div id="postamble" class="status">
<p class="postamble">Created At <span class="timestamp-wrapper"><span class="timestamp">&lt;2016-06-08 Wed&gt;</span></span> by Luis Xu. Email: <a href="mailto:xuzhengchaojob@gmail.com">xuzhengchaojob@gmail.com</a></p>
</div>
</body>
</html>
