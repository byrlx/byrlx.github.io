<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
"http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en">
<head>
<!-- 2017-03-06 Mon 22:29 -->
<meta  http-equiv="Content-Type" content="text/html;charset=utf-8" />
<meta  name="viewport" content="width=device-width, initial-scale=1" />
<title>ArrayList, LinkedList源码笔记</title>
<meta  name="generator" content="Org-mode" />
<meta  name="author" content="Luis Xu" />
<link rel="stylesheet" title="Standard" href="/style/worg.css" type="text/css" />
<link rel="alternate stylesheet" title="Zenburn" href="/style/worg-zenburn.css" type="text/css" />
<link rel="alternate stylesheet" title="Classic" href="/style/worg-classic.css" type="text/css" />
<link rel="SHORTCUT ICON" href="/org-mode-unicorn.ico" type="image/x-icon" />
<link rel="icon" href="/org-mode-unicorn.ico" type="image/ico" />
<script type="text/javascript">
/*
@licstart  The following is the entire license notice for the
JavaScript code in this tag.

Copyright (C) 2012-2013 Free Software Foundation, Inc.

The JavaScript code in this tag is free software: you can
redistribute it and/or modify it under the terms of the GNU
General Public License (GNU GPL) as published by the Free Software
Foundation, either version 3 of the License, or (at your option)
any later version.  The code is distributed WITHOUT ANY WARRANTY;
without even the implied warranty of MERCHANTABILITY or FITNESS
FOR A PARTICULAR PURPOSE.  See the GNU GPL for more details.

As additional permission under GNU GPL version 3 section 7, you
may distribute non-source (e.g., minimized or compacted) forms of
that code without the copy of the GNU GPL normally required by
section 4, provided you include this license notice and a URL
through which recipients can access the Corresponding Source.


@licend  The above is the entire license notice
for the JavaScript code in this tag.
*/
<!--/*--><![CDATA[/*><!--*/
 function CodeHighlightOn(elem, id)
 {
   var target = document.getElementById(id);
   if(null != target) {
     elem.cacheClassElem = elem.className;
     elem.cacheClassTarget = target.className;
     target.className = "code-highlighted";
     elem.className   = "code-highlighted";
   }
 }
 function CodeHighlightOff(elem, id)
 {
   var target = document.getElementById(id);
   if(elem.cacheClassElem)
     elem.className = elem.cacheClassElem;
   if(elem.cacheClassTarget)
     target.className = elem.cacheClassTarget;
 }
/*]]>*///-->
</script>
</head>
<body>
<div id="preamble" class="status">
<script type="text/javascript">

  var _gaq = _gaq || [];
  _gaq.push(['_setAccount', 'UA-7691209-1']);
  _gaq.push(['_trackPageview']);

  (function() {
    var ga = document.createElement('script'); ga.type = 'text/javascript'; ga.async = true;
    ga.src = ('https:' == document.location.protocol ? 'https://ssl' : 'http://www') + '.google-analytics.com/ga.js';
    var s = document.getElementsByTagName('script')[0]; s.parentNode.insertBefore(ga, s);
  })();

  document.addEventListener('DOMContentLoaded',function() {
      document.getElementById("table-of-contents").onclick = function() {
          var elem = document.getElementById("text-table-of-contents");
          elem.style.display = elem.style.display == "block" ? "none" : "block";
      }
  });
</script>
</div>
<div id="content">
<h1 class="title">ArrayList, LinkedList源码笔记</h1>
<div id="table-of-contents">
<h2>Table of Contents</h2>
<div id="text-table-of-contents">
<ul>
<li><a href="#orgheadline2">Iterable</a></li>
<li><a href="#orgheadline1">Iterator</a></li>
<li><a href="#orgheadline3">Collection</a></li>
<li><a href="#orgheadline4">List</a></li>
<li><a href="#orgheadline5">ListIterator</a></li>
<li><a href="#orgheadline6">AbstractCollection</a></li>
<li><a href="#orgheadline7">AbstractList</a>
<ul>
<li><a href="#orgheadline8">Itr</a></li>
<li><a href="#orgheadline9">ListItr</a></li>
<li><a href="#orgheadline10">SubList</a></li>
<li><a href="#orgheadline11">RandomAccessSubList</a></li>
</ul>
</li>
<li><a href="#orgheadline12">ArrayList</a></li>
<li><a href="#orgheadline13">AbstractSequentialList</a></li>
<li><a href="#orgheadline14">Deque</a></li>
<li><a href="#orgheadline15">LinkedList</a>
<ul>
<li><a href="#orgheadline16">Node</a></li>
</ul>
</li>
<li><a href="#orgheadline17">SynchronizedList</a></li>
</ul>
</div>
</div>
<p>
最近工作不忙, 抽空看了一下ArrayList和LinkedList的源码. 下面是一些主要知识点的笔记. 
</p>

<div id="outline-container-orgheadline2" class="outline-2">
<h2 id="orgheadline2">Iterable</h2>
<div class="outline-text-2" id="text-orgheadline2">
<p>
实现了Iterable的接口类, 可以使用 "for-loop" 形式的语法. 
例如这里实现一个 Foo 类实现了 Iterable 接口. 那么可以使用
如下代码来操作 Foo 实例.
</p>

<div class="org-src-container">

<pre class="src src-java"><span style="color: #7CB8BB;">Foo</span> <span style="color: #DFAF8F;">foo</span> = <span style="color: #F0DFAF; font-weight: bold;">new</span> <span style="color: #7CB8BB;">Foo</span>();
<span style="color: #F0DFAF; font-weight: bold;">for</span>(<span style="color: #7CB8BB;">T</span> <span style="color: #DFAF8F;">t</span> : foo ) {<span style="color: #5F7F5F;">//</span><span style="color: #7F9F7F;">do  something}</span>
</pre>
</div>

<p>
该接口的几个主要API:
</p>
<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">


<colgroup>
<col  class="org-left" />

<col  class="org-left" />
</colgroup>
<thead>
<tr>
<th scope="col" class="org-left">名称</th>
<th scope="col" class="org-left">功能</th>
</tr>
</thead>
<tbody>
<tr>
<td class="org-left">interator()</td>
<td class="org-left">返回一个<a href="#orgheadline1">Iterator</a> 实例, 用于实现对Interable接口的"遍历".</td>
</tr>

<tr>
<td class="org-left">forEach(action)</td>
<td class="org-left">接受一个Cousumer类型的参数action, 然后对"遍历"后的每个元素用action做处理.</td>
</tr>
</tbody>
</table>
</div>
</div>

<div id="outline-container-orgheadline1" class="outline-2">
<h2 id="orgheadline1">Iterator</h2>
<div class="outline-text-2" id="text-orgheadline1">
<p>
Iterator是集合的"迭代器", 提供了对集合进行遍历的方法. Iterator一般
都是依附Iterable存在的. <br  />
Iterator提供的API:
</p>

<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">


<colgroup>
<col  class="org-left" />

<col  class="org-left" />
</colgroup>
<thead>
<tr>
<th scope="col" class="org-left">名称</th>
<th scope="col" class="org-left">功能</th>
</tr>
</thead>
<tbody>
<tr>
<td class="org-left">hasNext()</td>
<td class="org-left">判断集合是否还有元素.</td>
</tr>

<tr>
<td class="org-left">next()</td>
<td class="org-left">返回下一个元素.</td>
</tr>

<tr>
<td class="org-left">remove()</td>
<td class="org-left">删除next()返回的元素.</td>
</tr>

<tr>
<td class="org-left">forEachRemaining(action)</td>
<td class="org-left">对集合剩下的元素执行action动作. action的定义与<a href="#orgheadline2">Iterable</a>介绍的相同.</td>
</tr>
</tbody>
</table>
</div>
</div>

<div id="outline-container-orgheadline3" class="outline-2">
<h2 id="orgheadline3">Collection</h2>
<div class="outline-text-2" id="text-orgheadline3">
<p>
Collection是Java"集合"家族的顶层接口, 继承自<a href="#orgheadline2">Iterable</a>.
定义了集合的一些共同特性:
</p>
<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">


<colgroup>
<col  class="org-left" />

<col  class="org-left" />
</colgroup>
<thead>
<tr>
<th scope="col" class="org-left">API名称</th>
<th scope="col" class="org-left">描述</th>
</tr>
</thead>
<tbody>
<tr>
<td class="org-left">size()</td>
<td class="org-left">集合大小</td>
</tr>

<tr>
<td class="org-left">isEmpty()</td>
<td class="org-left">是否为空</td>
</tr>

<tr>
<td class="org-left">contains()</td>
<td class="org-left">是否包含元素</td>
</tr>

<tr>
<td class="org-left">iterator()</td>
<td class="org-left">返回该集合的迭代器</td>
</tr>

<tr>
<td class="org-left">toArray()/toArray(T[] a)</td>
<td class="org-left">集合转化为数组</td>
</tr>

<tr>
<td class="org-left">add(E e)</td>
<td class="org-left">添加元素</td>
</tr>

<tr>
<td class="org-left">remove(E e)</td>
<td class="org-left">删除元素</td>
</tr>

<tr>
<td class="org-left">addAll(c)</td>
<td class="org-left">添加一个Collection</td>
</tr>

<tr>
<td class="org-left">clear()</td>
<td class="org-left">清空整个集合</td>
</tr>
</tbody>
</table>
</div>
</div>
<div id="outline-container-orgheadline4" class="outline-2">
<h2 id="orgheadline4">List</h2>
<div class="outline-text-2" id="text-orgheadline4">
<p>
List是"队列"家族的抽象类, 队列是一种"有先后顺序"的集合, 队列中的元素
有添加的先后顺序, 新元素都会添加到队列尾部.
该类继承自<a href="#orgheadline3">Collection</a>, 除了<a href="#orgheadline3">Collection</a>的特性, 该类的其他主要特性包括:
</p>
<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">


<colgroup>
<col  class="org-left" />

<col  class="org-left" />
</colgroup>
<thead>
<tr>
<th scope="col" class="org-left">API</th>
<th scope="col" class="org-left">描述</th>
</tr>
</thead>
<tbody>
<tr>
<td class="org-left">add(e)</td>
<td class="org-left">添加到队尾, 返回是否添加成功</td>
</tr>

<tr>
<td class="org-left">remove(e)</td>
<td class="org-left">删除第一次出现的元素</td>
</tr>

<tr>
<td class="org-left">addAll(index, c)</td>
<td class="org-left">将集合c添加到index开始的位置</td>
</tr>

<tr>
<td class="org-left">replaceAll(operator)</td>
<td class="org-left">使用operator来替换所有元素</td>
</tr>

<tr>
<td class="org-left">sort(c)</td>
<td class="org-left">使用Comparator c对队列进行排序</td>
</tr>

<tr>
<td class="org-left">get(index)</td>
<td class="org-left">获取index位置的元素</td>
</tr>

<tr>
<td class="org-left">set(index, e)</td>
<td class="org-left">替换index位置的元素, 返回旧元素</td>
</tr>

<tr>
<td class="org-left">add(index, e)</td>
<td class="org-left">index位置插入一个元素</td>
</tr>

<tr>
<td class="org-left">remove(index)</td>
<td class="org-left">删除index位置的元素</td>
</tr>

<tr>
<td class="org-left">index(e)</td>
<td class="org-left">获取元素在队列中第一次出现的位置, 或-1</td>
</tr>

<tr>
<td class="org-left">lastIndexOf(e)</td>
<td class="org-left">获取元素在队列中最后一次出现的位置, 或-1</td>
</tr>

<tr>
<td class="org-left">subList(start, end)</td>
<td class="org-left">获取[start, end) 位置的子列表</td>
</tr>

<tr>
<td class="org-left">listIterator()</td>
<td class="org-left">获取list的ListIterator</td>
</tr>
</tbody>
</table>

<p>
PS:
</p>
<ol class="org-ol">
<li><p>
replaceAll()实现: 首先获取队列的ListIterator, 然后过该iterator
来操作队列. 
</p>
<div class="org-src-container">

<pre class="src src-java"><span style="color: #F0DFAF; font-weight: bold;">default</span> <span style="color: #7CB8BB;">void</span> <span style="color: #93E0E3;">replaceAll</span>(<span style="color: #7CB8BB;">UnaryOperator</span>&lt;<span style="color: #7CB8BB;">E</span>&gt; <span style="color: #DFAF8F;">operator</span>) {
    Objects.requireNonNull(operator);
    <span style="color: #F0DFAF; font-weight: bold;">final</span> <span style="color: #7CB8BB;">ListIterator</span>&lt;<span style="color: #7CB8BB;">E</span>&gt; <span style="color: #DFAF8F;">li</span> = <span style="color: #F0DFAF; font-weight: bold;">this</span>.listIterator();
    <span style="color: #F0DFAF; font-weight: bold;">while</span> (li.hasNext()) {
        li.set(operator.apply(li.next()));
    }
}
</pre>
</div></li>
<li><p>
sort(Comparator c)实现: 首先调用toArray()方法将队列转化为array,
然后调用 <code>Arrays.sort()</code> 函数来对array进行排序, 最后将排序后的
array通过ListIterator存入队列.
</p>
<div class="org-src-container">

<pre class="src src-java"><span style="color: #F0DFAF; font-weight: bold;">default</span> <span style="color: #7CB8BB;">void</span> <span style="color: #93E0E3;">sort</span>(<span style="color: #7CB8BB;">Comparator</span>&lt;? <span style="color: #F0DFAF; font-weight: bold;">super</span> <span style="color: #7CB8BB;">E</span>&gt; <span style="color: #DFAF8F;">c</span>) {
    <span style="color: #7CB8BB;">Object</span>[] <span style="color: #DFAF8F;">a</span> = <span style="color: #F0DFAF; font-weight: bold;">this</span>.toArray();
    Arrays.sort(a, (<span style="color: #7CB8BB;">Comparator</span>) c);
    <span style="color: #7CB8BB;">ListIterator</span>&lt;<span style="color: #7CB8BB;">E</span>&gt; <span style="color: #DFAF8F;">i</span> = <span style="color: #F0DFAF; font-weight: bold;">this</span>.listIterator();
    <span style="color: #F0DFAF; font-weight: bold;">for</span> (<span style="color: #7CB8BB;">Object</span> <span style="color: #DFAF8F;">e</span> : a) {
        i.next();
        i.set((<span style="color: #7CB8BB;">E</span>) e);
    }
}
</pre>
</div></li>
<li>subList(): 通过该函数返回的子队列, 其数据还是存储在其"父队列"的底层实现中, 
所以对该队列数据的修改都会影响付队列, 同样, 对父队列的修改也会影响子队列.</li>
</ol>
</div>
</div>
<div id="outline-container-orgheadline5" class="outline-2">
<h2 id="orgheadline5">ListIterator</h2>
<div class="outline-text-2" id="text-orgheadline5">
<p>
该类是<a href="#orgheadline4">List</a>类的一个Iterator实现, 继承自<a href="#orgheadline1">Iterator</a>接口, 
其提供了遍历<a href="#orgheadline4">List</a>的接口, 同时对一些接口做了条件约束:
即对<a href="#orgheadline4">List</a>的遍历只能按照"从前向后"或"从后向前"的顺序.<br  />
该类的主要API如下:
</p>
<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">


<colgroup>
<col  class="org-left" />

<col  class="org-left" />
</colgroup>
<thead>
<tr>
<th scope="col" class="org-left">API</th>
<th scope="col" class="org-left">描述</th>
</tr>
</thead>
<tbody>
<tr>
<td class="org-left">hasNext()</td>
<td class="org-left">从前向后遍历,判断是否还有元素</td>
</tr>

<tr>
<td class="org-left">next()</td>
<td class="org-left">从前向后遍历, 返回下一个元素</td>
</tr>

<tr>
<td class="org-left">nextIndex()</td>
<td class="org-left">从前向后遍历, 返回下一个位置</td>
</tr>

<tr>
<td class="org-left">hasPrevious()</td>
<td class="org-left">从后向前遍历, 判断是否还有元素</td>
</tr>

<tr>
<td class="org-left">previous()</td>
<td class="org-left">从后向前, 返回下一个元素</td>
</tr>

<tr>
<td class="org-left">previousIndex()</td>
<td class="org-left">从后向前, 返回下一个元素位置</td>
</tr>

<tr>
<td class="org-left">remove()</td>
<td class="org-left">返回next()或previous()的返回值</td>
</tr>

<tr>
<td class="org-left">set()</td>
<td class="org-left">替换next()或previous()的返回值</td>
</tr>

<tr>
<td class="org-left">add()</td>
<td class="org-left">见注1</td>
</tr>
</tbody>
</table>

<p>
PS:
</p>
<ol class="org-ol">
<li>add(): 插入到next()返回值的"前面", 或previous()返回值的"后面".
另一个观点, 从"从前向后"的视角来看, 新插入的元素永远在当前元素的"前面".</li>
</ol>
</div>
</div>
<div id="outline-container-orgheadline6" class="outline-2">
<h2 id="orgheadline6">AbstractCollection</h2>
<div class="outline-text-2" id="text-orgheadline6">
<p>
AbstractCollection是<a href="#orgheadline3">Collection</a>接口的一个实现, 对于
集合类型的一些"可能"的共同操作, 该类给出了一些API实现, 包括:
</p>
<ol class="org-ol">
<li><p>
isEmpty()
</p>
<div class="org-src-container">

<pre class="src src-java"><span style="color: #F0DFAF; font-weight: bold;">public</span> <span style="color: #7CB8BB;">boolean</span> <span style="color: #93E0E3;">isEmpty</span>() {
    <span style="color: #F0DFAF; font-weight: bold;">return</span> size() == 0;
}
</pre>
</div></li>
<li><p>
contains(o)
该函数实现分两种情况: 如果o为null, 则判断集合中是否包含null. 否则,遍历
集合并调用参数o的equals()方法来判断是否有相等元素. 元素遍历是通过iterator实现.
</p>
<div class="org-src-container">

<pre class="src src-java"><span style="color: #F0DFAF; font-weight: bold;">public</span> <span style="color: #7CB8BB;">boolean</span> <span style="color: #93E0E3;">contains</span>(<span style="color: #7CB8BB;">Object</span> <span style="color: #DFAF8F;">o</span>) {
    <span style="color: #7CB8BB;">Iterator</span>&lt;<span style="color: #7CB8BB;">E</span>&gt; <span style="color: #DFAF8F;">it</span> = iterator();
    <span style="color: #F0DFAF; font-weight: bold;">if</span> (o==<span style="color: #BFEBBF;">null</span>) {
        <span style="color: #F0DFAF; font-weight: bold;">while</span> (it.hasNext())
            <span style="color: #F0DFAF; font-weight: bold;">if</span> (it.next()==<span style="color: #BFEBBF;">null</span>)
                <span style="color: #F0DFAF; font-weight: bold;">return</span> <span style="color: #BFEBBF;">true</span>;
    } <span style="color: #F0DFAF; font-weight: bold;">else</span> {
        <span style="color: #F0DFAF; font-weight: bold;">while</span> (it.hasNext())
            <span style="color: #F0DFAF; font-weight: bold;">if</span> (o.equals(it.next()))
                <span style="color: #F0DFAF; font-weight: bold;">return</span> <span style="color: #BFEBBF;">true</span>;
    }
    <span style="color: #F0DFAF; font-weight: bold;">return</span> <span style="color: #BFEBBF;">false</span>;
}
</pre>
</div></li>
<li><p>
toArray()
该函数用于将集合转换为数组, 需要关注的是, 在转化过程中, 集合的
结构可能被修改(多线程), 即元素被添加或删除.<br  />
该函数的实现也cover了这种情况. 从下面代码可以看到, 
</p>
<ol class="org-ol">
<li>在每次for循环开始都会调用hasNext()判断是已经到结尾(即期间有元素被删除). 
如果是, 则直接调用Array的copyOf()函数把返回临时数组的一个copy, 该临时数组
用于存储已经遍历过的元素.</li>
<li>遍历完之后, 还会再次调用hasNext()判断是否有新元素, 如果有, 则调用finishToArray()
函数继续对集合进行变量, 并分配一个更大的数组, 知道集合变量完或者达到数组上限.</li>
</ol>
<div class="org-src-container">

<pre class="src src-java"><span style="color: #F0DFAF; font-weight: bold;">public</span> <span style="color: #7CB8BB;">Object</span>[] <span style="color: #93E0E3;">toArray</span>() {
    <span style="color: #5F7F5F;">// </span><span style="color: #7F9F7F;">Estimate size of array; be prepared to see more or fewer elements</span>
    <span style="color: #7CB8BB;">Object</span>[] <span style="color: #DFAF8F;">r</span> = <span style="color: #F0DFAF; font-weight: bold;">new</span> <span style="color: #7CB8BB;">Object</span>[size()];
    <span style="color: #7CB8BB;">Iterator</span>&lt;<span style="color: #7CB8BB;">E</span>&gt; <span style="color: #DFAF8F;">it</span> = iterator();
    <span style="color: #F0DFAF; font-weight: bold;">for</span> (<span style="color: #7CB8BB;">int</span> <span style="color: #DFAF8F;">i</span> = 0; i &lt; r.<span style="color: #7CB8BB;">length</span>; i++) {
        <span style="color: #F0DFAF; font-weight: bold;">if</span> (<span style="color: #F0DFAF; font-weight: bold;">!</span> it.hasNext()) <span style="color: #5F7F5F;">// </span><span style="color: #7F9F7F;">fewer elements than expected</span>
            <span style="color: #F0DFAF; font-weight: bold;">return</span> Arrays.copyOf(r, i);
        r[i] = it.next();
    }
    <span style="color: #F0DFAF; font-weight: bold;">return</span> it.hasNext() ? finishToArray(r, it) : r;
}
</pre>
</div></li>
<li>toArray(T[] a)
如果a的size足够能容下集合元素, 则存入a中并返回a, 否则存入一个新分配的数组并返回.</li>
<li>remove(): 实现方式与contains()相同, 也是通过iterator进行操作.</li>
<li>containsAll()/addAll()/removeAll()<br  />
实现方式基本相同, 都是遍历参数集合, 然后基于参数中的每个元素
对集合进行操作.</li>
<li>retainAll(c). 只保留c和该集合的"交集"元素.</li>
<li><p>
clear(): 反复调用iterator的hasNext(), next(), remove()函数删除所有元素.
</p>
<div class="org-src-container">

<pre class="src src-java"><span style="color: #F0DFAF; font-weight: bold;">public</span> <span style="color: #7CB8BB;">void</span> <span style="color: #93E0E3;">clear</span>() {
    <span style="color: #7CB8BB;">Iterator</span>&lt;<span style="color: #7CB8BB;">E</span>&gt; <span style="color: #DFAF8F;">it</span> = iterator();
    <span style="color: #F0DFAF; font-weight: bold;">while</span> (it.hasNext()) {
        it.next();
        it.remove();
    }
}
</pre>
</div></li>
</ol>
</div>
</div>
<div id="outline-container-orgheadline7" class="outline-2">
<h2 id="orgheadline7">AbstractList</h2>
<div class="outline-text-2" id="text-orgheadline7">
<p>
该类是<a href="#orgheadline6">AbstractCollection</a>的一个子类并实现了<a href="#orgheadline4">List</a>接口, 该类实现了
List相关的一些共同操作. 包括:
</p>
<ol class="org-ol">
<li><p>
indexOf(o):寻找元素位置. 该函数的实现使用了previousIndex()函数, 因为
调用next()之后, iterator会移动到下一位, 所以需要调用这个函数才能获取
到"命中元素"的位置.
</p>
<div class="org-src-container">

<pre class="src src-java"><span style="color: #F0DFAF; font-weight: bold;">public</span> <span style="color: #7CB8BB;">int</span> <span style="color: #93E0E3;">indexOf</span>(<span style="color: #7CB8BB;">Object</span> <span style="color: #DFAF8F;">o</span>) {
    <span style="color: #7CB8BB;">ListIterator</span>&lt;<span style="color: #7CB8BB;">E</span>&gt; <span style="color: #DFAF8F;">it</span> = listIterator();
    <span style="color: #F0DFAF; font-weight: bold;">if</span> (o==<span style="color: #BFEBBF;">null</span>) {
        <span style="color: #F0DFAF; font-weight: bold;">while</span> (it.hasNext())
            <span style="color: #F0DFAF; font-weight: bold;">if</span> (it.next()==<span style="color: #BFEBBF;">null</span>)
                <span style="color: #F0DFAF; font-weight: bold;">return</span> it.previousIndex();
    } <span style="color: #F0DFAF; font-weight: bold;">else</span> {
        <span style="color: #F0DFAF; font-weight: bold;">while</span> (it.hasNext())
            <span style="color: #F0DFAF; font-weight: bold;">if</span> (o.equals(it.next()))
                <span style="color: #F0DFAF; font-weight: bold;">return</span> it.previousIndex();
    }
    <span style="color: #F0DFAF; font-weight: bold;">return</span> -1;
}
</pre>
</div></li>
<li>lastIndexOf(o): 实现方式与indexOf()相同, 只是遍历顺序相反.</li>
</ol>
</div>

<div id="outline-container-orgheadline8" class="outline-3">
<h3 id="orgheadline8">Itr</h3>
<div class="outline-text-3" id="text-orgheadline8">
<p>
该类是AbstractList的一个内部类, 在List的层级结构中, 是第一次具体实现
一个Iterator. 可以看下该类是如何具体实现<a href="#orgheadline1">Iterator</a>的API的.
</p>
<ol class="org-ol">
<li><p>
hasNext():判断当前的光标是否等于size()函数. 如果等于, 表示到达尾部, 返回false.
</p>
<div class="org-src-container">

<pre class="src src-java"><span style="color: #F0DFAF; font-weight: bold;">public</span> <span style="color: #7CB8BB;">boolean</span> <span style="color: #93E0E3;">hasNext</span>() {
    <span style="color: #F0DFAF; font-weight: bold;">return</span> cursor != size();
}
</pre>
</div></li>
<li><p>
next():返回下一个元素. 由于光标一开始是指向第一个元素(index=0), 
所以每次调用该函数, 返回的都是当前光标位置的元素, 然后再把光标
移动一个位置. 同时有一个成员变量 lastRet 用于记录这次返回值的位置.
</p>
<div class="org-src-container">

<pre class="src src-java">   <span style="color: #F0DFAF; font-weight: bold;">public</span> <span style="color: #7CB8BB;">E</span> <span style="color: #93E0E3;">next</span>() {
    checkForComodification();
    <span style="color: #F0DFAF; font-weight: bold;">try</span> {
        <span style="color: #7CB8BB;">int</span> <span style="color: #DFAF8F;">i</span> = cursor;
        <span style="color: #7CB8BB;">E</span> <span style="color: #DFAF8F;">next</span> = get(i);
        lastRet = i;
        cursor = i + 1;
        <span style="color: #F0DFAF; font-weight: bold;">return</span> next;
    } <span style="color: #F0DFAF; font-weight: bold;">catch</span> (<span style="color: #7CB8BB;">IndexOutOfBoundsException</span> <span style="color: #DFAF8F;">e</span>) {
        checkForComodification();
        <span style="color: #F0DFAF; font-weight: bold;">throw</span> <span style="color: #F0DFAF; font-weight: bold;">new</span> <span style="color: #7CB8BB;">NoSuchElementException</span>();
    }
}
</pre>
</div>

<p>
在函数的开始调用了 <code>checkForComodification()</code> 函数, 该函数用于
判断是否有其他线程操作了该iterator所属的集合.它的实现原理是:
Iterator有一个成员变量expectedModcount, 其值等于集合的变量modCount, 
每次集合被修改(添加/删除), modCount的值都会发生变化. 所以如果发现
expectedModcount的值与该值不相等了, 说明"集合"被其他线程修改了. 
在AbstractList中就会抛异常.
</p>
<div class="org-src-container">

<pre class="src src-java"><span style="color: #F0DFAF; font-weight: bold;">final</span> <span style="color: #7CB8BB;">void</span> <span style="color: #93E0E3;">checkForComodification</span>() {
     <span style="color: #F0DFAF; font-weight: bold;">if</span> (modCount != expectedModCount)
         <span style="color: #F0DFAF; font-weight: bold;">throw</span> <span style="color: #F0DFAF; font-weight: bold;">new</span> <span style="color: #7CB8BB;">ConcurrentModificationException</span>();
 }
</pre>
</div></li>
<li>remove():
如果当前光标没有指向list区间, 则抛异常. 否则调用 <a href="#orgheadline7">AbstractList</a>的remove()函数.
然后将缓存光标 lastRet 置位-1. 并重新赋值 expectedModcount(因为AbstractList的
remove()函数可能会修改modCount的值).</li>
</ol>
</div>
</div>
<div id="outline-container-orgheadline9" class="outline-3">
<h3 id="orgheadline9">ListItr</h3>
<div class="outline-text-3" id="text-orgheadline9">
<p>
该类是<a href="#orgheadline8">Itr</a>的子类并实现了<a href="#orgheadline5">ListIterator</a>接口. 主要是实现了ListIterator"从后向前"的遍历方法.
</p>
<ol class="org-ol">
<li>构造函数ListItr(index):
直接将光标至于index的位置.</li>
<li>hasPrevious():判断当前光标是否为0, 如果是返回false.</li>
<li><p>
previous(): 返回当前光标的前一个元素. 这里与next()不同, 
next()是先返回当前光标的值, 移动光标. previous()是返回
当前光标前面的值, 并移动光标. 
</p>
<div class="org-src-container">

<pre class="src src-java"><span style="color: #F0DFAF; font-weight: bold;">public</span> <span style="color: #7CB8BB;">E</span> <span style="color: #93E0E3;">previous</span>() {
    checkForComodification();
    <span style="color: #F0DFAF; font-weight: bold;">try</span> {
        <span style="color: #7CB8BB;">int</span> <span style="color: #DFAF8F;">i</span> = cursor - 1;
        <span style="color: #7CB8BB;">E</span> <span style="color: #DFAF8F;">previous</span> = get(i);
        lastRet = cursor = i;
        <span style="color: #F0DFAF; font-weight: bold;">return</span> previous;
    } <span style="color: #F0DFAF; font-weight: bold;">catch</span> (<span style="color: #7CB8BB;">IndexOutOfBoundsException</span> <span style="color: #DFAF8F;">e</span>) {
        checkForComodification();
        <span style="color: #F0DFAF; font-weight: bold;">throw</span> <span style="color: #F0DFAF; font-weight: bold;">new</span> <span style="color: #7CB8BB;">NoSuchElementException</span>();
    }
}
</pre>
</div></li>
<li>nextIndex(): 返回当前光标.</li>
<li>previousIndex(): 返回当前光标减1.</li>
</ol>
</div>
</div>
<div id="outline-container-orgheadline10" class="outline-3">
<h3 id="orgheadline10">SubList</h3>
<div class="outline-text-3" id="text-orgheadline10">
<p>
该类是AbstractList的子类,是"子队列"概念的代码实现. 代表了某个
队列的一部分. 在其实现中, 其内容存储在原列表的底层存储中. 该类
只维护了一些"列表"状态, 来表示子对类. 任何对该类的队列的修改都会
影响到原列表, 反之亦然. 通过下面的几个函数可以看出对该类的增删其实调用的
都是原来队列的方法.
</p>
<div class="org-src-container">

<pre class="src src-java"><span style="color: #93E0E3;">SubList</span>(<span style="color: #7CB8BB;">AbstractList</span>&lt;<span style="color: #7CB8BB;">E</span>&gt; <span style="color: #DFAF8F;">list</span>, <span style="color: #7CB8BB;">int</span> <span style="color: #DFAF8F;">fromIndex</span>, <span style="color: #7CB8BB;">int</span> <span style="color: #DFAF8F;">toIndex</span>) {
    <span style="color: #F0DFAF; font-weight: bold;">if</span> (fromIndex &lt; 0)
        <span style="color: #F0DFAF; font-weight: bold;">throw</span> <span style="color: #F0DFAF; font-weight: bold;">new</span> <span style="color: #7CB8BB;">IndexOutOfBoundsException</span>(<span style="color: #CC9393;">"fromIndex = "</span> + fromIndex);
    <span style="color: #F0DFAF; font-weight: bold;">if</span> (toIndex &gt; list.size())
        <span style="color: #F0DFAF; font-weight: bold;">throw</span> <span style="color: #F0DFAF; font-weight: bold;">new</span> <span style="color: #7CB8BB;">IndexOutOfBoundsException</span>(<span style="color: #CC9393;">"toIndex = "</span> + toIndex);
    <span style="color: #F0DFAF; font-weight: bold;">if</span> (fromIndex &gt; toIndex)
        <span style="color: #F0DFAF; font-weight: bold;">throw</span> <span style="color: #F0DFAF; font-weight: bold;">new</span> <span style="color: #7CB8BB;">IllegalArgumentException</span>(<span style="color: #CC9393;">"fromIndex("</span> + fromIndex +
                                           <span style="color: #CC9393;">") &gt; toIndex("</span> + toIndex + <span style="color: #CC9393;">")"</span>);
    l = list;
    offset = fromIndex;
    size = toIndex - fromIndex;
    <span style="color: #F0DFAF; font-weight: bold;">this</span>.modCount = l.modCount;
}

<span style="color: #F0DFAF; font-weight: bold;">public</span> <span style="color: #7CB8BB;">E</span> <span style="color: #93E0E3;">set</span>(<span style="color: #7CB8BB;">int</span> <span style="color: #DFAF8F;">index</span>, <span style="color: #7CB8BB;">E</span> <span style="color: #DFAF8F;">element</span>) {
    rangeCheck(index);
    checkForComodification();
    <span style="color: #F0DFAF; font-weight: bold;">return</span> l.set(index+offset, element);
}

<span style="color: #F0DFAF; font-weight: bold;">public</span> <span style="color: #7CB8BB;">E</span> <span style="color: #93E0E3;">get</span>(<span style="color: #7CB8BB;">int</span> <span style="color: #DFAF8F;">index</span>) {
    rangeCheck(index);
    checkForComodification();
    <span style="color: #F0DFAF; font-weight: bold;">return</span> l.get(index+offset);
}

<span style="color: #F0DFAF; font-weight: bold;">public</span> <span style="color: #7CB8BB;">void</span> <span style="color: #93E0E3;">add</span>(<span style="color: #7CB8BB;">int</span> <span style="color: #DFAF8F;">index</span>, <span style="color: #7CB8BB;">E</span> <span style="color: #DFAF8F;">element</span>) {
    rangeCheckForAdd(index);
    checkForComodification();
    l.add(index+offset, element);
    <span style="color: #F0DFAF; font-weight: bold;">this</span>.modCount = l.modCount;
    size++;
}

<span style="color: #F0DFAF; font-weight: bold;">public</span> <span style="color: #7CB8BB;">E</span> <span style="color: #93E0E3;">remove</span>(<span style="color: #7CB8BB;">int</span> <span style="color: #DFAF8F;">index</span>) {
    rangeCheck(index);
    checkForComodification();
    <span style="color: #7CB8BB;">E</span> <span style="color: #DFAF8F;">result</span> = l.remove(index+offset);
    <span style="color: #F0DFAF; font-weight: bold;">this</span>.modCount = l.modCount;
    size--;
    <span style="color: #F0DFAF; font-weight: bold;">return</span> result;
}
</pre>
</div>
</div>
</div>
<div id="outline-container-orgheadline11" class="outline-3">
<h3 id="orgheadline11">RandomAccessSubList</h3>
<div class="outline-text-3" id="text-orgheadline11">
<p>
该类是<a href="#orgheadline10">SubList</a>的一个子类, 但是实现了RandomAccess接口(空接口),
表明其具有RandomAccess的属性. 该类的所有操作几乎都是使用<a href="#orgheadline10">SubList</a>的操作. 
</p>

<p>
在AbstractList的subList()函数实现中, 会判断当前List是否为RandomAccess,
如果是, 则会返回一个 RandomAccessSubList 实例, 否则返回一个 SubList 实例. 
</p>
<div class="org-src-container">

<pre class="src src-java"><span style="color: #F0DFAF; font-weight: bold;">public</span> <span style="color: #7CB8BB;">List</span>&lt;<span style="color: #7CB8BB;">E</span>&gt; <span style="color: #93E0E3;">subList</span>(<span style="color: #7CB8BB;">int</span> <span style="color: #DFAF8F;">fromIndex</span>, <span style="color: #7CB8BB;">int</span> <span style="color: #DFAF8F;">toIndex</span>) {
    <span style="color: #F0DFAF; font-weight: bold;">return</span> (<span style="color: #F0DFAF; font-weight: bold;">this</span> <span style="color: #F0DFAF; font-weight: bold;">instanceof</span> RandomAccess ?
            <span style="color: #F0DFAF; font-weight: bold;">new</span> <span style="color: #7CB8BB;">RandomAccessSubList</span>&lt;&gt;(<span style="color: #F0DFAF; font-weight: bold;">this</span>, fromIndex, toIndex) :
            <span style="color: #F0DFAF; font-weight: bold;">new</span> <span style="color: #7CB8BB;">SubList</span>&lt;&gt;(<span style="color: #F0DFAF; font-weight: bold;">this</span>, fromIndex, toIndex));
}
</pre>
</div>
</div>
</div>
</div>
<div id="outline-container-orgheadline12" class="outline-2">
<h2 id="orgheadline12">ArrayList</h2>
<div class="outline-text-2" id="text-orgheadline12">
<p>
介绍了这么多之后, 终于来到了ArrayList的实现, 该类直接继承
自<a href="#orgheadline7">AbstractList</a>, 并实现了 <a href="#orgheadline4">List</a> 和 RandomAccess 接口.
</p>
<div class="org-src-container">

<pre class="src src-java"><span style="color: #F0DFAF; font-weight: bold;">public</span> <span style="color: #F0DFAF; font-weight: bold;">class</span> <span style="color: #7CB8BB;">ArrayList</span>&lt;<span style="color: #7CB8BB;">E</span>&gt; <span style="color: #F0DFAF; font-weight: bold;">extends</span> <span style="color: #7CB8BB;">AbstractList</span>&lt;<span style="color: #7CB8BB;">E</span>&gt;
        <span style="color: #F0DFAF; font-weight: bold;">implements</span> <span style="color: #7CB8BB;">List</span>&lt;<span style="color: #7CB8BB;">E</span>&gt;, <span style="color: #7CB8BB;">RandomAccess</span>, <span style="color: #7CB8BB;">Cloneable</span>, <span style="color: #BFEBBF;">java</span>.<span style="color: #BFEBBF;">io</span>.<span style="color: #7CB8BB;">Serializable</span>
{
</pre>
</div>

<p>
这里主要介绍其底层数据存储的实现及与LinkedList不同的API:
</p>
<ol class="org-ol">
<li>ArrayList的元素都存放在底层Object数组elementData中.</li>
<li>int变量size存放元素数量.</li>
<li>get(index): 获取元素, 直接访问数组对应位置, O(1).</li>
<li>set(index, e): 更新元素, 同上, O(1).</li>
<li>add(index, e): index位置插入元素, 这里会做两步:
<ul class="org-ul">
<li>如果数组已满, 分配新数组, <b>这样会做一次整个数组的copy</b>.</li>
<li>插入新元素, 此时会将index后的内容做整体移动.</li>
</ul></li>
<li>remove(index): 对index后的内容做整体前移动作.</li>
<li><p>
batchRemove(c, flag): 批量删除, flag是一个boolean变量, 
其含义是: 如果为true, 保留c和该list的交集, 而删除其他元素.
如果为false, 则删除交集.
</p>
<div class="org-src-container">

<pre class="src src-java"><span style="color: #F0DFAF; font-weight: bold;">private</span> <span style="color: #7CB8BB;">boolean</span> <span style="color: #93E0E3;">batchRemove</span>(<span style="color: #7CB8BB;">Collection</span>&lt;?&gt; <span style="color: #DFAF8F;">c</span>, <span style="color: #7CB8BB;">boolean</span> <span style="color: #DFAF8F;">complement</span>) {
    <span style="color: #F0DFAF; font-weight: bold;">final</span> <span style="color: #7CB8BB;">Object</span>[] <span style="color: #DFAF8F;">elementData</span> = <span style="color: #F0DFAF; font-weight: bold;">this</span>.elementData;
    <span style="color: #7CB8BB;">int</span> <span style="color: #DFAF8F;">r</span> = 0, <span style="color: #DFAF8F;">w</span> = 0;
    <span style="color: #7CB8BB;">boolean</span> <span style="color: #DFAF8F;">modified</span> = <span style="color: #BFEBBF;">false</span>;
    <span style="color: #F0DFAF; font-weight: bold;">try</span> {
        <span style="color: #F0DFAF; font-weight: bold;">for</span> (; r &lt; <span style="color: #7CB8BB;">size</span>; r++)
            <span style="color: #F0DFAF; font-weight: bold;">if</span> (c.contains(elementData[r]) == complement)
                elementData[w++] = elementData[r];
    } <span style="color: #F0DFAF; font-weight: bold;">finally</span> {
        <span style="color: #5F7F5F;">// </span><span style="color: #7F9F7F;">Preserve behavioral compatibility with AbstractCollection,</span>
        <span style="color: #5F7F5F;">// </span><span style="color: #7F9F7F;">even if c.contains() throws.</span>
        <span style="color: #F0DFAF; font-weight: bold;">if</span> (r != size) {
            System.arraycopy(elementData, r,
                             elementData, w,
                             size - r);
            w += size - r;
        }
        <span style="color: #F0DFAF; font-weight: bold;">if</span> (w != size) {
            <span style="color: #5F7F5F;">// </span><span style="color: #7F9F7F;">clear to let GC do its work</span>
            <span style="color: #F0DFAF; font-weight: bold;">for</span> (<span style="color: #7CB8BB;">int</span> <span style="color: #DFAF8F;">i</span> = w; i &lt; <span style="color: #7CB8BB;">size</span>; i++)
                elementData[i] = <span style="color: #BFEBBF;">null</span>;
            modCount += size - w;
            size = w;
            modified = <span style="color: #BFEBBF;">true</span>;
        }
    }
    <span style="color: #F0DFAF; font-weight: bold;">return</span> modified;
}
</pre>
</div></li>
</ol>

<p>
所以对于ArrayList的所有的插入/删除动作, 都会涉及到底层数组的
"移动", 这个移动最终是调用 <code>System.arraycopy()</code> 函数实现的.
所以插入/删除的效率直接与该函数的实现有关. 
</p>

<p>
ArryaList的其他实现, 例如 Iterator 和 ListIterator, 基本与
<a href="#orgheadline7">AbstractList</a>大同小异.
</p>
</div>
</div>
<div id="outline-container-orgheadline13" class="outline-2">
<h2 id="orgheadline13">AbstractSequentialList</h2>
<div class="outline-text-2" id="text-orgheadline13">
<p>
在介绍LinkedList之前, 先看一下它的父类, 该类是<a href="#orgheadline7">AbstractList</a>的
子类, 但是它具有"顺序"的属性, 这是相对于ArrayList的RandomAccess属性而言. 
官方文档中对该属性是这样解释的. 
</p>
<div class="org-src-container">

<pre class="src src-java">* This <span style="color: #F0DFAF; font-weight: bold;">class</span> is the opposite of <span style="color: #7CB8BB;">the</span> &lt;<span style="color: #7CB8BB;">tt</span>&gt;AbstractList&lt;/tt&gt; <span style="color: #F0DFAF; font-weight: bold;">class</span> in the sense
* that it <span style="color: #F0DFAF; font-weight: bold;">implements</span> <span style="color: #7CB8BB;">the</span> <span style="color: #CC9393;">"random access"</span> methods (&lt;<span style="color: #7CB8BB;">tt</span>&gt;get(<span style="color: #7CB8BB;">int</span> <span style="color: #DFAF8F;">index</span>)&lt;/tt&gt;,
* &lt;<span style="color: #7CB8BB;">tt</span>&gt;set(<span style="color: #7CB8BB;">int</span> <span style="color: #DFAF8F;">index</span>, <span style="color: #7CB8BB;">E</span> <span style="color: #DFAF8F;">element</span>)&lt;/tt&gt;, &lt;<span style="color: #7CB8BB;">tt</span>&gt;add(<span style="color: #7CB8BB;">int</span> <span style="color: #DFAF8F;">index</span>, <span style="color: #7CB8BB;">E</span> <span style="color: #DFAF8F;">element</span>)&lt;/tt&gt; and
* &lt;<span style="color: #7CB8BB;">tt</span>&gt;remove(<span style="color: #7CB8BB;">int</span> <span style="color: #DFAF8F;">index</span>)&lt;/tt&gt;) on top of the list<span style="color: #D0BF8F; font-weight: bold;">'</span><span style="color: #CC9393;">s list iterator, instead of</span>
<span style="color: #CC9393;">* the other way around.&lt;p&gt;</span>
</pre>
</div>

<p>
上面这段文字解释了在该类中通过index "插入/删除" 元素的实现方法.
都是通过其ListIterator实现的. (想想在<a href="#orgheadline12">ArrayList</a>中,这些方法都是直接
操作数组). 可以看下几个相关的API代码.
</p>
<div class="org-src-container">

<pre class="src src-java"><span style="color: #F0DFAF; font-weight: bold;">public</span> <span style="color: #7CB8BB;">void</span> <span style="color: #93E0E3;">add</span>(<span style="color: #7CB8BB;">int</span> <span style="color: #DFAF8F;">index</span>, <span style="color: #7CB8BB;">E</span> <span style="color: #DFAF8F;">element</span>) {
    <span style="color: #F0DFAF; font-weight: bold;">try</span> {
        listIterator(index).add(element);
    } <span style="color: #F0DFAF; font-weight: bold;">catch</span> (<span style="color: #7CB8BB;">NoSuchElementException</span> <span style="color: #DFAF8F;">exc</span>) {
        <span style="color: #F0DFAF; font-weight: bold;">throw</span> <span style="color: #F0DFAF; font-weight: bold;">new</span> <span style="color: #7CB8BB;">IndexOutOfBoundsException</span>(<span style="color: #CC9393;">"Index: "</span>+index);
    }
}
<span style="color: #F0DFAF; font-weight: bold;">public</span> <span style="color: #7CB8BB;">E</span> <span style="color: #93E0E3;">remove</span>(<span style="color: #7CB8BB;">int</span> <span style="color: #DFAF8F;">index</span>) {
    <span style="color: #F0DFAF; font-weight: bold;">try</span> {
        <span style="color: #7CB8BB;">ListIterator</span>&lt;<span style="color: #7CB8BB;">E</span>&gt; <span style="color: #DFAF8F;">e</span> = listIterator(index);
        <span style="color: #7CB8BB;">E</span> <span style="color: #DFAF8F;">outCast</span> = e.next();
        e.remove();
        <span style="color: #F0DFAF; font-weight: bold;">return</span> outCast;
    } <span style="color: #F0DFAF; font-weight: bold;">catch</span> (<span style="color: #7CB8BB;">NoSuchElementException</span> <span style="color: #DFAF8F;">exc</span>) {
        <span style="color: #F0DFAF; font-weight: bold;">throw</span> <span style="color: #F0DFAF; font-weight: bold;">new</span> <span style="color: #7CB8BB;">IndexOutOfBoundsException</span>(<span style="color: #CC9393;">"Index: "</span>+index);
    }
}
</pre>
</div>

<p>
另外, 该类的 iterator() 和 listIterator() 函数返回的都是
ListIterator实例.
</p>
</div>
</div>
<div id="outline-container-orgheadline14" class="outline-2">
<h2 id="orgheadline14">Deque</h2>
<div class="outline-text-2" id="text-orgheadline14">
<p>
双端队列, 支持头部和尾部的插入和删除动作. 
Deque接口提供了这些操作的相应API.
</p>
</div>
</div>
<div id="outline-container-orgheadline15" class="outline-2">
<h2 id="orgheadline15">LinkedList</h2>
<div class="outline-text-2" id="text-orgheadline15">
<p>
继承自<a href="#orgheadline13">AbstractSequentialList</a>, 并实现了 <a href="#orgheadline4">List</a> 和 <a href="#orgheadline14">Deque</a> 接口.
</p>

<p>
不过与<a href="#orgheadline13">AbstractSequentialList</a>不同的是, LinkedList的插入删除并
没有使用ListIterator, 而是直接操作链表. 下面是一些核心API:
</p>
<ol class="org-ol">
<li><p>
unlink(e): 删除元素, "几乎"所有删除API的底层实现. 
与<a href="#orgheadline12">ArrayList</a>不同的是, 它没有设计到"一片内存"区域的移动, 所以
效率上要比ArrayList高.
</p>
<div class="org-src-container">

<pre class="src src-java"><span style="color: #7CB8BB;">E</span> <span style="color: #93E0E3;">unlink</span>(<span style="color: #7CB8BB;">Node</span>&lt;<span style="color: #7CB8BB;">E</span>&gt; <span style="color: #DFAF8F;">x</span>) {
    <span style="color: #5F7F5F;">// </span><span style="color: #7F9F7F;">assert x != null;</span>
    <span style="color: #F0DFAF; font-weight: bold;">final</span> <span style="color: #7CB8BB;">E</span> <span style="color: #DFAF8F;">element</span> = x.item;
    <span style="color: #F0DFAF; font-weight: bold;">final</span> <span style="color: #7CB8BB;">Node</span>&lt;<span style="color: #7CB8BB;">E</span>&gt; <span style="color: #DFAF8F;">next</span> = x.next;
    <span style="color: #F0DFAF; font-weight: bold;">final</span> <span style="color: #7CB8BB;">Node</span>&lt;<span style="color: #7CB8BB;">E</span>&gt; <span style="color: #DFAF8F;">prev</span> = x.prev;

    <span style="color: #F0DFAF; font-weight: bold;">if</span> (prev == <span style="color: #BFEBBF;">null</span>) {
        first = next;
    } <span style="color: #F0DFAF; font-weight: bold;">else</span> {
        prev.next = next;
        x.prev = <span style="color: #BFEBBF;">null</span>;
    }

    <span style="color: #F0DFAF; font-weight: bold;">if</span> (next == <span style="color: #BFEBBF;">null</span>) {
        last = prev;
    } <span style="color: #F0DFAF; font-weight: bold;">else</span> {
        next.prev = prev;
        x.next = <span style="color: #BFEBBF;">null</span>;
    }

    x.item = <span style="color: #BFEBBF;">null</span>;
    size--;
    modCount++;
    <span style="color: #F0DFAF; font-weight: bold;">return</span> element;
}
</pre>
</div></li>
<li>linkBefore(e, node): 插入元素,实现原理同unlink().</li>
<li><p>
node(index): 获取index位置的node, "几乎" 所有遍历类的底层实现.
这需要遍历链表, 不过因为LinkedList是双向列表, 
所以该函数的实现上也有点技巧: 即如果index &gt; size/2, 则从队列
尾部向前寻找, 否则从队列头部向后寻找.
</p>
<div class="org-src-container">

<pre class="src src-java"><span style="color: #7CB8BB;">Node</span>&lt;<span style="color: #7CB8BB;">E</span>&gt; <span style="color: #93E0E3;">node</span>(<span style="color: #7CB8BB;">int</span> <span style="color: #DFAF8F;">index</span>) {
    <span style="color: #5F7F5F;">// </span><span style="color: #7F9F7F;">assert isElementIndex(index);</span>

    <span style="color: #F0DFAF; font-weight: bold;">if</span> (index &lt; (size &gt;&gt; 1)) {
        <span style="color: #7CB8BB;">Node</span>&lt;<span style="color: #7CB8BB;">E</span>&gt; <span style="color: #DFAF8F;">x</span> = first;
        <span style="color: #F0DFAF; font-weight: bold;">for</span> (<span style="color: #7CB8BB;">int</span> <span style="color: #DFAF8F;">i</span> = 0; i &lt; <span style="color: #7CB8BB;">index</span>; i++)
            x = x.next;
        <span style="color: #F0DFAF; font-weight: bold;">return</span> x;
    } <span style="color: #F0DFAF; font-weight: bold;">else</span> {
        <span style="color: #7CB8BB;">Node</span>&lt;<span style="color: #7CB8BB;">E</span>&gt; <span style="color: #DFAF8F;">x</span> = last;
        <span style="color: #F0DFAF; font-weight: bold;">for</span> (<span style="color: #7CB8BB;">int</span> <span style="color: #DFAF8F;">i</span> = size - 1; i &gt; index; i--)
            x = x.prev;
        <span style="color: #F0DFAF; font-weight: bold;">return</span> x;
    }
}
</pre>
</div></li>
</ol>

<p>
这三个函数基本就是LinkedList的核心原理. 
</p>
</div>
<div id="outline-container-orgheadline16" class="outline-3">
<h3 id="orgheadline16">Node</h3>
<div class="outline-text-3" id="text-orgheadline16">
<p>
LinkedList是使用"链表"这种数据结构来存储数据, 所以其内部定义了一个
Node类用来表示链表节点. Node类的实现很简单.
</p>
<div class="org-src-container">

<pre class="src src-java"><span style="color: #F0DFAF; font-weight: bold;">private</span> <span style="color: #F0DFAF; font-weight: bold;">static</span> <span style="color: #F0DFAF; font-weight: bold;">class</span> <span style="color: #7CB8BB;">Node</span>&lt;<span style="color: #7CB8BB;">E</span>&gt; {
    <span style="color: #7CB8BB;">E</span> <span style="color: #DFAF8F;">item</span>;
    <span style="color: #7CB8BB;">Node</span>&lt;<span style="color: #7CB8BB;">E</span>&gt; <span style="color: #DFAF8F;">next</span>;
    <span style="color: #7CB8BB;">Node</span>&lt;<span style="color: #7CB8BB;">E</span>&gt; <span style="color: #DFAF8F;">prev</span>;

    <span style="color: #93E0E3;">Node</span>(<span style="color: #7CB8BB;">Node</span>&lt;<span style="color: #7CB8BB;">E</span>&gt; <span style="color: #DFAF8F;">prev</span>, <span style="color: #7CB8BB;">E</span> <span style="color: #DFAF8F;">element</span>, <span style="color: #7CB8BB;">Node</span>&lt;<span style="color: #7CB8BB;">E</span>&gt; <span style="color: #DFAF8F;">next</span>) {
        <span style="color: #F0DFAF; font-weight: bold;">this</span>.item = element;
        <span style="color: #F0DFAF; font-weight: bold;">this</span>.next = next;
        <span style="color: #F0DFAF; font-weight: bold;">this</span>.prev = prev;
    }
}
</pre>
</div>
</div>
</div>
</div>
<div id="outline-container-orgheadline17" class="outline-2">
<h2 id="orgheadline17">SynchronizedList</h2>
<div class="outline-text-2" id="text-orgheadline17">
<p>
由于List类不是线程安全的. 多线程可以同时修改list的内容. 
所以为了解决这个问题, Collections类提供了一个 
<code>snchronizedList()</code> 函数用于将 <a href="#orgheadline4">List</a> 转化为一个 "同步" list.
其基本原理类似于adapter模式, 实现了一个新的list, 被提供了
同步功能. 看下部分源码:
</p>
<div class="org-src-container">

<pre class="src src-java"><span style="color: #F0DFAF; font-weight: bold;">public</span> <span style="color: #F0DFAF; font-weight: bold;">static</span> &lt;<span style="color: #7CB8BB;">T</span>&gt; <span style="color: #7CB8BB;">List</span>&lt;<span style="color: #7CB8BB;">T</span>&gt; <span style="color: #93E0E3;">synchronizedList</span>(<span style="color: #7CB8BB;">List</span>&lt;<span style="color: #7CB8BB;">T</span>&gt; <span style="color: #DFAF8F;">list</span>) {
    <span style="color: #F0DFAF; font-weight: bold;">return</span> (list <span style="color: #F0DFAF; font-weight: bold;">instanceof</span> RandomAccess ?
            <span style="color: #F0DFAF; font-weight: bold;">new</span> <span style="color: #7CB8BB;">SynchronizedRandomAccessList</span>&lt;&gt;(list) :
            <span style="color: #F0DFAF; font-weight: bold;">new</span> <span style="color: #7CB8BB;">SynchronizedList</span>&lt;&gt;(list));
}

<span style="color: #F0DFAF; font-weight: bold;">static</span> <span style="color: #F0DFAF; font-weight: bold;">class</span> <span style="color: #7CB8BB;">SynchronizedList</span>&lt;<span style="color: #7CB8BB;">E</span>&gt;
    <span style="color: #F0DFAF; font-weight: bold;">extends</span> <span style="color: #7CB8BB;">SynchronizedCollection</span>&lt;<span style="color: #7CB8BB;">E</span>&gt;
    <span style="color: #F0DFAF; font-weight: bold;">implements</span> <span style="color: #7CB8BB;">List</span>&lt;<span style="color: #7CB8BB;">E</span>&gt; {
    <span style="color: #F0DFAF; font-weight: bold;">private</span> <span style="color: #F0DFAF; font-weight: bold;">static</span> <span style="color: #F0DFAF; font-weight: bold;">final</span> <span style="color: #7CB8BB;">long</span> <span style="color: #DFAF8F;">serialVersionUID</span> = -7754090372962971524L;

    <span style="color: #F0DFAF; font-weight: bold;">final</span> <span style="color: #7CB8BB;">List</span>&lt;<span style="color: #7CB8BB;">E</span>&gt; <span style="color: #DFAF8F;">list</span>;

    <span style="color: #93E0E3;">SynchronizedList</span>(<span style="color: #7CB8BB;">List</span>&lt;<span style="color: #7CB8BB;">E</span>&gt; <span style="color: #DFAF8F;">list</span>) {
        <span style="color: #F0DFAF; font-weight: bold;">super</span>(list);
        <span style="color: #F0DFAF; font-weight: bold;">this</span>.list = list;
    }
    <span style="color: #93E0E3;">SynchronizedList</span>(<span style="color: #7CB8BB;">List</span>&lt;<span style="color: #7CB8BB;">E</span>&gt; <span style="color: #DFAF8F;">list</span>, <span style="color: #7CB8BB;">Object</span> <span style="color: #DFAF8F;">mutex</span>) {
        <span style="color: #F0DFAF; font-weight: bold;">super</span>(list, mutex);
        <span style="color: #F0DFAF; font-weight: bold;">this</span>.list = list;
    }

    <span style="color: #F0DFAF; font-weight: bold;">public</span> <span style="color: #7CB8BB;">boolean</span> <span style="color: #93E0E3;">equals</span>(<span style="color: #7CB8BB;">Object</span> <span style="color: #DFAF8F;">o</span>) {
        <span style="color: #F0DFAF; font-weight: bold;">if</span> (<span style="color: #F0DFAF; font-weight: bold;">this</span> == o)
            <span style="color: #F0DFAF; font-weight: bold;">return</span> <span style="color: #BFEBBF;">true</span>;
        <span style="color: #F0DFAF; font-weight: bold;">synchronized</span> (mutex) {<span style="color: #F0DFAF; font-weight: bold;">return</span> list.equals(o);}
    }
    <span style="color: #F0DFAF; font-weight: bold;">public</span> <span style="color: #7CB8BB;">int</span> <span style="color: #93E0E3;">hashCode</span>() {
        <span style="color: #F0DFAF; font-weight: bold;">synchronized</span> (mutex) {<span style="color: #F0DFAF; font-weight: bold;">return</span> list.hashCode();}
    }

    <span style="color: #F0DFAF; font-weight: bold;">public</span> <span style="color: #7CB8BB;">E</span> <span style="color: #93E0E3;">get</span>(<span style="color: #7CB8BB;">int</span> <span style="color: #DFAF8F;">index</span>) {
        <span style="color: #F0DFAF; font-weight: bold;">synchronized</span> (mutex) {<span style="color: #F0DFAF; font-weight: bold;">return</span> list.get(index);}
    }
    <span style="color: #F0DFAF; font-weight: bold;">public</span> <span style="color: #7CB8BB;">E</span> <span style="color: #93E0E3;">set</span>(<span style="color: #7CB8BB;">int</span> <span style="color: #DFAF8F;">index</span>, <span style="color: #7CB8BB;">E</span> <span style="color: #DFAF8F;">element</span>) {
        <span style="color: #F0DFAF; font-weight: bold;">synchronized</span> (mutex) {<span style="color: #F0DFAF; font-weight: bold;">return</span> list.set(index, element);}
    }
    <span style="color: #F0DFAF; font-weight: bold;">public</span> <span style="color: #7CB8BB;">void</span> <span style="color: #93E0E3;">add</span>(<span style="color: #7CB8BB;">int</span> <span style="color: #DFAF8F;">index</span>, <span style="color: #7CB8BB;">E</span> <span style="color: #DFAF8F;">element</span>) {
        <span style="color: #F0DFAF; font-weight: bold;">synchronized</span> (mutex) {list.add(index, element);}
    }
    <span style="color: #F0DFAF; font-weight: bold;">public</span> <span style="color: #7CB8BB;">E</span> <span style="color: #93E0E3;">remove</span>(<span style="color: #7CB8BB;">int</span> <span style="color: #DFAF8F;">index</span>) {
        <span style="color: #F0DFAF; font-weight: bold;">synchronized</span> (mutex) {<span style="color: #F0DFAF; font-weight: bold;">return</span> list.remove(index);}
    }
</pre>
</div>
</div>
</div>
</div>
<div id="postamble" class="status">
<p class="postamble">Created At <span class="timestamp-wrapper"><span class="timestamp">&lt;2016-06-08 Wed&gt;</span></span> by Luis Xu. Email: <a href="mailto:xuzhengchaojob@gmail.com">xuzhengchaojob@gmail.com</a></p>
</div>
</body>
</html>
