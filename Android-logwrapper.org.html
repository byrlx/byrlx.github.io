<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01//EN">
<!-- Created by htmlize-1.43 in css mode. -->
<html>
  <head>
    <title>Android-logwrapper.org</title>
    <style type="text/css">
    <!--
      body {
        color: #DCDCCC;
        background-color: #3F3F3F;
      }
      .org-block {
        /* org-block */
        color: #009acd;
      }
      .org-block-begin-line {
        /* org-block-begin-line */
        color: #7F9F7F;
      }
      .org-block-end-line {
        /* org-block-end-line */
        color: #7F9F7F;
      }
      .org-document-info {
        /* org-document-info */
        color: #afeeee;
      }
      .org-document-info-keyword {
        /* org-document-info-keyword */
        color: #b3b3b3;
      }
      .org-document-title {
        /* org-document-title */
        color: #afeeee;
        font-weight: bold;
      }
      .org-level-1 {
        /* org-level-1 */
        color: #DFAF8F;
        font-size: 130%;
        text-decoration: overline;
      }
      .org-meta-line {
        /* org-meta-line */
        color: #7F9F7F;
      }

      a {
        color: inherit;
        background-color: inherit;
        font: inherit;
        text-decoration: inherit;
      }
      a:hover {
        text-decoration: underline;
      }
    -->
    </style>
  </head>
  <body>
    <pre>
<span class="org-meta-line">#+OPTIONS: ^:nil</span>
<span class="org-meta-line">#+OPTIONS: toc:t H:2</span>
<span class="org-document-info-keyword">#+AUTHOR:</span> <span class="org-document-info">Zhengchao Xu
</span><span class="org-document-info-keyword">#+EMAIL:</span> <span class="org-document-info">xuzhengchaojob@gmail.com
</span><span class="org-document-info-keyword">#+TITLE:</span> <span class="org-document-title">Android logwrapper
</span>
&#20005;&#26684;&#26469;&#35762;&#65292;logwrapper&#24182;&#19981;&#23646;&#20110;&#20043;&#21069;&#20889;&#30340;Android&#30340;Log&#20307;&#31995;&#65288;
[logger](../Android-logger)&#12289;
[liblog](../Android-liblog)&#12289;
[logcat](../Android-logcat)
&#65289;&#65292;&#20294;&#26159;&#21602;&#65292;&#23427;&#22810;&#22810;&#23569;&#23569;&#21448;&#19982;&#36825;&#22871;&#20307;&#31995;&#26377;&#20123;&#20851;&#31995;&#65292;&#25152;&#20197;&#23558;&#20854;&#31216;&#20043;&#20026;&#8220;&#22806;&#20256;&#8221;&#12290;

&#20160;&#20040;&#26159;logwrapper&#65311;&#22914;&#26524;&#20320;&#20889;&#20102;&#19968;&#20010;android&#31243;&#24207;&#65292;&#20351;&#29992;&#20102;&#19968;&#20123;&#26631;&#20934;&#36755;&#20986;&#20989;&#25968;&#65288;printf&#65289;&#65292;
&#20294;&#26159;&#26377;&#26102;&#20505;&#20320;&#26080;&#27861;&#30475;&#21040;&#36825;&#20123;&#36755;&#20986;&#65288;&#20363;&#22914;&#20320;&#20889;&#20102;&#19968;&#20010;native&#24320;&#26426;&#21551;&#21160;&#31243;&#24207;&#65292;
&#37027;&#20320;&#24212;&#35813;&#27809;&#21150;&#27861;&#22312;adb shell&#20013;&#30475;&#21040;&#20320;&#30340;&#36755;&#20986;&#21543;&#65289;&#12290;
&#37027;&#20040;&#20351;&#29992;logwrapper&#21487;&#20197;&#23558;&#20320;&#30340;&#31243;&#24207;&#30340;&#26631;&#20934;&#36755;&#20986;&#37325;&#23450;&#21521;&#21040;android log&#25110;kernel log&#20013;&#65292;
&#23601;&#20687;&#26159;&#20320;&#35843;&#29992;&#20102;&#36825;&#20123;log&#20989;&#25968;(ALOGI&#25110;printk&#65289;&#19968;&#26679;&#12290;
                
&#20363;&#22914;&#65292;&#20320;&#22312;adb shell&#20013;&#36755;&#20837;&#8216;logwrapper ls&#8217;&#65292;
&#32456;&#31471;&#19978;&#19981;&#20250;&#26174;&#31034;&#20219;&#20309;&#20869;&#23481;&#65292;ls&#30340;&#36755;&#20986;&#34987;&#37325;&#23450;&#21521;&#21040;&#20102;logger&#20013;&#65292;
&#36890;&#36807;logcat&#21629;&#20196;&#25226;logger&#30340;&#20869;&#23481;&#25235;&#21040;&#25991;&#20214;&#20013;&#65292;&#21487;&#20197;&#30475;&#21040;ls&#30340;&#36755;&#20986;&#12290;
&#22914;&#19979;&#22270;&#12290;

&#20351;&#29992;logwrapper&#21518;&#65292;ls&#30340;&#32467;&#26524;&#27809;&#26377;&#36755;&#20986;&#21040;&#26631;&#20934;&#36755;&#20986;&#12290;
![ls with logwrapper]({{root_url}}/public/img/ls.png "lslogwrapper")

&#22312;logcat&#25235;&#30340;log&#20013;&#21457;&#29616;&#20102;&#19978;&#38754;ls&#21629;&#20196;&#30340;&#32467;&#26524;&#12290;
![logcat with logwrapper]({{root_url}}/public/img/logwrapper.png "logwrapper")

<span class="org-level-1">* clogwrapper &#20195;&#30721;</span>

logwrapper&#30340;&#20195;&#30721;&#20301;&#20110; system/core/logwrapper&#30446;&#24405;&#12290;&#22312;&#26368;&#26032;&#30340;4.4.2_r1&#29256;&#26412;&#20013;&#65292;&#35813;&#27169;&#22359;&#22686;&#21152;&#21040;&#20102;&#19977;&#20010;&#28304;&#25991;&#20214;&#65292;
&#65288;&#21407;&#26469;&#21482;&#26377;logwrapper.c&#36825;&#25903;&#25991;&#20214;&#65289;&#12290;&#39318;&#20808;&#30475;&#19968;&#19979;&#35813;&#27169;&#22359;&#30340;makefile&#25991;&#20214;Android.mk&#12290;

<span class="org-block-begin-line">#+BEGIN_EXAMPLE
</span><span class="org-block">
        LOCAL_PATH:= $(call my-dir)
        
        include $(CLEAR_VARS)
        
        # ========================================================
        # Static library
        # ========================================================
        include $(CLEAR_VARS)
        LOCAL_MODULE := liblogwrap
        LOCAL_SRC_FILES := logwrap.c
        LOCAL_SHARED_LIBRARIES := libcutils liblog
        LOCAL_EXPORT_C_INCLUDE_DIRS := $(LOCAL_PATH)/include
        LOCAL_C_INCLUDES := $(LOCAL_PATH)/include
        include $(BUILD_STATIC_LIBRARY)
        
        # ========================================================
        # Shared library
        # ========================================================
        include $(CLEAR_VARS)
        LOCAL_MODULE := liblogwrap
        LOCAL_SHARED_LIBRARIES := libcutils liblog
        LOCAL_WHOLE_STATIC_LIBRARIES := liblogwrap
        LOCAL_EXPORT_C_INCLUDE_DIRS := $(LOCAL_PATH)/include
        LOCAL_C_INCLUDES := $(LOCAL_PATH)/include
        include $(BUILD_SHARED_LIBRARY)
        
        # ========================================================
        # Executable
        # ========================================================
        include $(CLEAR_VARS)
        LOCAL_SRC_FILES:= logwrapper.c
        LOCAL_MODULE := logwrapper
        LOCAL_STATIC_LIBRARIES := liblog liblogwrap libcutils
        include $(BUILD_EXECUTABLE)

</span><span class="org-block-end-line">#+END_EXAMPLE
</span>&#20174;Android&#21487;&#20197;&#30475;&#20986;&#65292;&#22312;&#32534;&#35793;&#26102;&#65292;&#20808;&#23558;logwrap.c&#25991;&#20214;&#32534;&#35793;&#25104;&#19968;&#20010;&#21160;&#24577;&#24211;liblogwrap&#65292;
&#28982;&#21518;&#20877;&#23558;&#35813;&#21160;&#24577;&#24211;&#32534;&#35793;&#25104;&#38745;&#24577;&#24211;liblogwrap&#65292;&#26368;&#21518;&#23558;logwrapper.c&#32534;&#35793;&#25104;&#19968;&#20010;
&#21487;&#25191;&#34892;shell&#21629;&#20196;logwrapper&#12290;
        
&#26082;&#28982;&#19978;&#38754;&#30340;&#20363;&#23376;&#20013;&#26377;&#29992;&#21040;logwrapper&#36825;&#20010;&#21629;&#20196;&#65292;&#37027;&#20808;&#20174;&#20854;&#28304;&#20195;&#30721;&#30475;&#36215;&#12290;&#35813;&#25991;&#20214;&#30340;&#20195;&#30721;&#21482;&#26377;&#19981;&#21040;100&#34892;&#65292;&#20027;&#35201;&#30340;&#24037;&#20316;&#36824;&#26159;&#22312;logwrap.c&#20013;&#23436;&#25104;&#12290;&#20808;&#30475;&#19968;&#19979;main&#20989;&#25968;&#12290;
<span class="org-block-begin-line">#+BEGIN_EXAMPLE
</span><span class="org-block">
        int main(int argc, char* argv[]) {
                ....

            while ((ch = getopt(argc, argv, "adk")) != -1) {
                switch (ch) {
                    case 'a':
                        abbreviated = true;
                        break;
                    case 'd':
                        seg_fault_on_exit = 1;
                        break;
                    case 'k':
                        log_target = LOG_KLOG;
                        klog_set_level(6);
                        break;
                    case '?':
                    default:
                      usage();
                }
            }
            argc -= optind;
            argv += optind;
        
            if (argc &lt; 1) {
                usage();
            }
        
            rc = android_fork_execvp_ext(argc, &amp;argv[0], &amp;status, true,
                                         log_target, abbreviated, NULL);

                ....

        }

</span><span class="org-block-end-line">#+END_EXAMPLE   
</span>&#39318;&#20808;&#36890;&#36807;getopt()&#20989;&#25968;&#33719;&#21462;&#21629;&#20196;&#34892;&#36873;&#39033;&#65292;
&#19981;&#21516;&#30340;&#36873;&#39033;&#20250;&#35774;&#32622;&#19981;&#21516;&#30340;&#21464;&#37327;&#12290;&#30446;&#21069;logwrapper&#25903;&#25345;&#19977;&#20010;&#21629;&#20196;&#34892;&#36873;&#39033;&#65306;
-a&#65292;&#21387;&#32553;logging&#65292;&#35813;&#36873;&#39033;&#21482;&#20445;&#30041;&#8216;&#21629;&#20196;&#8217;&#36755;&#20986;&#30340;&#21069;4K&#21644;&#21518;4K&#20869;&#23481;&#12290;
-d&#65292;&#8216;&#21629;&#20196;&#8217;&#23436;&#25104;&#21518;&#65292;logwrapper&#20250;SIGSEGV&#12290;
-k&#65292;&#23558;&#8216;&#21629;&#20196;&#8217;&#36755;&#20986;&#20889;&#21040;kernel log&#65288;&#40664;&#35748;&#26159;&#20889;&#36947;Android Log&#65289;&#12290;
&#35835;&#23436;&#21629;&#20196;&#34892;&#36873;&#39033;&#21518;&#65292;&#25509;&#19979;&#26469;&#35843;&#29992;android_fork_execvp_ext()&#20989;&#25968;&#65292;&#36825;&#26159;logwrapper&#24037;&#20316;&#30340;&#26680;&#24515;&#20989;&#25968;&#12290;&#35813;&#20989;&#25968;&#30340;&#23454;&#29616;&#22312;logwrap.c&#20013;&#12290;
<span class="org-block-begin-line">#+BEGIN_EXAMPLE
</span><span class="org-block">
        // int android_fork_execvp_ext(int argc, char* argv[], int *status, bool ignore_int_quit,
        int log_target, bool abbreviated, char *file_path) {

        ...

    rc = pthread_mutex_lock(&amp;fd_mutex);
    if (rc) {
        ERROR("failed to lock signal_fd mutex\n");
        goto err_lock;
    }

    /* Use ptty instead of socketpair so that STDOUT is not buffered */
    parent_ptty = open("/dev/ptmx", O_RDWR);
    if (parent_ptty &lt; 0) {
        ERROR("Cannot create parent ptty\n");
        rc = -1;
        goto err_open;
    }

    if (grantpt(parent_ptty) || unlockpt(parent_ptty) ||
            ((child_devname = (char*)ptsname(parent_ptty)) == 0)) {
        ERROR("Problem with /dev/ptmx\n");
        rc = -1;
        goto err_ptty;
    }

    child_ptty = open(child_devname, O_RDWR);
    if (child_ptty &lt; 0) {
        ERROR("Cannot open child_ptty\n");
        rc = -1;
        goto err_child_ptty;
    }

</span><span class="org-block-end-line">#+END_EXAMPLE
</span>
&#31243;&#24207;&#30340;&#26368;&#24320;&#22987;&#20250;&#23581;&#35797;&#21435;&#25343;fd_mutex&#36825;&#20010;&#38145;&#65292;&#30446;&#21069;&#36824;&#19981;&#28165;&#26970;&#36825;&#20040;&#20570;&#30340;&#21407;&#22240;&#12290;

&#25509;&#19979;&#26469;&#20250;&#25171;&#24320;/dev/ptmx&#36825;&#20010;&#35774;&#22791;&#33410;&#28857;&#12290;&#24182;&#36890;&#36807;grantpt()&#12289;unlockpt()&#12289;ptsname()
&#36825;&#19977;&#20010;&#20989;&#25968;&#24471;&#21040;&#23545;/dev/ptmx&#36827;&#34892;&#30456;&#20851;&#25805;&#20316;&#12290;&#26368;&#21518;&#25171;&#24320;&#20174;&#35774;&#22791;&#12290;

&#8220;&#20266;&#32456;&#31471;&#20027;&#35774;&#22791;/dev/ptmx&#26159;&#19968;&#20010;&#27969;&#30340;&#22686;&#27542;&#35774;&#22791;&#12290;&#36825;&#24847;&#21619;&#30528;&#24403;&#25105;&#20204;&#25171;&#24320;&#35813;&#22686;&#27542;&#35774;&#22791;&#65292;
&#20854;open&#20363;&#31243;&#33258;&#21160;&#20915;&#23450;&#31532;&#19968;&#20010;&#26410;&#34987;&#20351;&#29992;&#30340;&#20266;&#32456;&#31471;&#20027;&#35774;&#22791;&#24182;&#25171;&#24320;&#36825;&#20010;&#35774;&#22791;&#12290;
&#21516;&#26102;&#65292;&#25171;&#24320;&#36825;&#20010;&#20027;&#35774;&#22791;&#20250;&#33258;&#21160;&#38145;&#23450;&#23545;&#24212;&#30340;&#20174;&#35774;&#22791;&#12290;
grantpt&#20989;&#25968;&#29992;&#26469;&#25913;&#21464;&#20174;&#35774;&#22791;&#30340;&#26435;&#38480;&#12290;&#25191;&#34892;&#22914;&#19979;&#25805;&#20316;&#65306;
&#65288;a&#65289;&#23558;&#20174;&#35774;&#22791;&#30340;&#25152;&#26377;&#26435;&#25913;&#20026;&#26377;&#25928;&#29992;&#25143;ID&#65307;&#65288;b&#65289;&#23558;&#32452;&#25152;&#26377;&#26435;&#25913;&#20026;&#32452;tty&#65307;
&#65288;c&#65289;&#23558;&#26435;&#38480;&#25913;&#20026;&#21482;&#20801;&#35768;user-read&#65292;user-write&#21644;group-write&#12290;
&#20989;&#25968;unlockpt&#29992;&#26469;&#28165;&#38500;&#20174;&#35774;&#22791;&#30340;&#20869;&#37096;&#38145;&#12290;&#22312;&#25171;&#24320;&#20174;&#35774;&#22791;&#21069;&#25105;&#20204;&#24517;&#39035;&#20570;&#36825;&#20214;&#20107;&#24773;&#12290;
&#36890;&#36807;&#35843;&#29992;ptsname&#26469;&#24471;&#21040;&#20174;&#35774;&#22791;&#30340;&#21517;&#31216;&#12290;&#36825;&#20010;&#21517;&#31216;&#30340;&#26684;&#24335;&#26159;/dev/pts/NNN&#12290;&#8221;

&#19978;&#38754;&#30340;&#20869;&#23481;&#26159;&#20174;&#30456;&#20851;&#36164;&#26009;&#20013;&#25688;&#21462;&#30340;&#23545;&#36825;&#19977;&#20010;&#20989;&#25968;&#30340;&#35299;&#37322;&#65292;
&#38024;&#23545;logwrapper&#36825;&#20010;&#31243;&#24207;&#65292;&#25105;&#30340;&#29702;&#35299;&#23601;&#26159;&#65292;logwrapper&#31243;&#24207;&#20351;&#29992;&#19968;&#20010;&#20027;&#35774;&#22791;&#65292;
&#28982;&#21518;&#23427;&#25191;&#34892;&#30340;&#8216;&#21629;&#20196;&#8217;&#20351;&#29992;&#19968;&#20010;&#20174;&#35774;&#22791;&#65292;&#21017;&#8216;&#21629;&#20196;&#8217;&#30340;&#36755;&#20986;&#23601;&#20250;&#36879;&#36807;&#20174;&#35774;&#22791;&#21453;&#26144;&#32473;&#20027;&#35774;&#22791;&#12290;
logwrapper&#31243;&#24207;&#20877;&#25226;&#23427;&#20889;&#21040;&#30456;&#20851;&#25991;&#20214;&#20013;&#12290;
<span class="org-block-begin-line">#+BEGIN_EXAMPLE
</span><span class="org-block">
    pid = fork();
    if (pid &lt; 0) {
        close(child_ptty);
        ERROR("Failed to fork\n");
        rc = -1;
        goto err_fork;
    } else if (pid == 0) {
        pthread_mutex_unlock(&amp;fd_mutex);
        pthread_sigmask(SIG_SETMASK, &amp;oldset, NULL);
        close(parent_ptty);

        // redirect stdout and stderr
        dup2(child_ptty, 1);
        dup2(child_ptty, 2);
        close(child_ptty);

        child(argc, argv);
    } else {
        close(child_ptty);
        if (ignore_int_quit) {
            struct sigaction ignact;

            memset(&amp;ignact, 0, sizeof(ignact));
            ignact.sa_handler = SIG_IGN;
            sigaction(SIGINT, &amp;ignact, &amp;intact);
            sigaction(SIGQUIT, &amp;ignact, &amp;quitact);
        }

        rc = parent(argv[0], parent_ptty, pid, status, log_target,
                    abbreviated, file_path);
    }

</span><span class="org-block-end-line">#+END_EXAMPLE
</span>&#25509;&#30528;&#36890;&#36807;fork()&#20986;&#19968;&#20010;&#26032;&#30340;&#36827;&#31243;&#26469;&#25191;&#34892;&#8216;&#21629;&#20196;&#8217;&#31243;&#24207;&#65292;
&#29238;&#36827;&#31243;&#21644;&#23376;&#36827;&#31243;&#20998;&#21035;&#25191;&#34892;parent&#21644;child&#20989;&#25968;&#65292;&#22312;&#23376;&#36827;&#31243;&#25191;&#34892;child&#20989;&#25968;&#20043;&#21069;&#65292;
&#20250;&#20808;&#23558;&#20854;stdout&#21644;stderr&#37325;&#23450;&#21521;&#21040;&#20174;&#35774;&#22791;&#19978;&#12290;&#36825;&#26679;&#29238;&#36827;&#31243;&#23601;&#21487;&#20197;&#25509;&#21463;&#8217;&#21629;&#20196;&#8216;&#30340;&#36755;&#20986;&#20102;&#12290;

&#20808;&#26469;&#30475;&#19979;child()&#20989;&#25968;&#30340;&#23454;&#29616;&#12290;&#35813;&#20989;&#25968;&#30340;&#31243;&#24207;&#24456;&#31616;&#21333;&#65292;&#23601;&#26159;&#36890;&#36807;execvp()&#25191;&#34892;&#8216;&#21629;&#20196;&#8217;&#12290;
<span class="org-block-begin-line">#+BEGIN_EXAMPLE
</span><span class="org-block">
        static void child(int argc, char* argv[]) {
            // create null terminated argv_child array
            char* argv_child[argc + 1];
            memcpy(argv_child, argv, argc * sizeof(char *));
            argv_child[argc] = NULL;
        
            if (execvp(argv_child[0], argv_child)) {
                FATAL_CHILD("executing %s failed: %s\n", argv_child[0],
                        strerror(errno));
            }
        }

</span><span class="org-block-end-line">#+END_EXAMPLE   
</span>parent()&#23454;&#29616;&#23601;&#27604;&#36739;&#22797;&#26434;&#19968;&#20123;&#12290;
<span class="org-block-begin-line">#+BEGIN_EXAMPLE
</span><span class="org-block">
        // static int parent(const char *tag, int parent_read, pid_t pid,
        //     int *chld_sts, int log_target, bool abbreviated, char *file_path) {

        ...
        
    struct pollfd poll_fds[] = {
        [0] = {
            .fd = parent_read,
            .events = POLLIN,
        },
    };
    struct log_info log_info;
        
    log_info.btag = basename(tag);
    if (!log_info.btag) {
        log_info.btag = (char*) tag;
    }

    if (abbreviated &amp;&amp; (log_target == LOG_NONE)) {
        abbreviated = 0;
    }
    if (abbreviated) {
        init_abbr_buf(&amp;log_info.a_buf);
    }

    if (log_target &amp; LOG_KLOG) {
        snprintf(log_info.klog_fmt, sizeof(log_info.klog_fmt),
                 "&lt;6&gt;%.*s: %%s", MAX_KLOG_TAG, log_info.btag);
    }

    if ((log_target &amp; LOG_FILE) &amp;&amp; !file_path) {
        /* No file_path specified, clear the LOG_FILE bit */
        log_target &amp;= ~LOG_FILE;
    }

    if (log_target &amp; LOG_FILE) {
        fd = open(file_path, O_WRONLY | O_CREAT, 0664);
        if (fd &lt; 0) {
            ERROR("Cannot log to file %s\n", file_path);
            log_target &amp;= ~LOG_FILE;
        } else {
            lseek(fd, 0, SEEK_END);
            log_info.fp = fdopen(fd, "a");
        }
    }

    log_info.log_target = log_target;
    log_info.abbreviated = abbreviated;

    while (!found_child) {
        if (TEMP_FAILURE_RETRY(poll(poll_fds, ARRAY_SIZE(poll_fds), -1)) &lt; 0) {
            ERROR("poll failed\n");
            rc = -1;
            goto err_poll;
        }

        if (poll_fds[0].revents &amp; POLLIN) {
            sz = read(parent_read, &amp;buffer[b], sizeof(buffer) - 1 - b);

            sz += b;
            // Log one line at a time
            for (b = 0; b &lt; sz; b++) {
                if (buffer[b] == '\r') {
                    if (abbreviated) {
                        buffer[b] = '\n';
                    } else {
                        buffer[b] = '\0';
                    }
                } else if (buffer[b] == '\n') {
                    buffer[b] = '\0';
                    log_line(&amp;log_info, &amp;buffer[a], b - a);
                    a = b + 1;
                }
            }

            if (a == 0 &amp;&amp; b == sizeof(buffer) - 1) {
                // buffer is full, flush
                buffer[b] = '\0';
                log_line(&amp;log_info, &amp;buffer[a], b - a);
                b = 0;
            } else if (a != b) {
                // Keep left-overs
                b -= a;
                memmove(buffer, &amp;buffer[a], b);
                a = 0;
            } else {
                a = 0;
                b = 0;
            }
        }

        if (poll_fds[0].revents &amp; POLLHUP) {
            int ret;

            ret = waitpid(pid, &amp;status, WNOHANG);
            if (ret &lt; 0) {
                rc = errno;
                ALOG(LOG_ERROR, "logwrap", "waitpid failed with %s\n", strerror(errno));
                goto err_waitpid;
            }
            if (ret &gt; 0) {
                found_child = true;
            }
        }
    }

</span><span class="org-block-end-line">#+END_EXAMPLE
</span>parent()&#20989;&#25968;&#30340;&#20027;&#20307;&#26159;&#19968;&#20010;while()&#24490;&#29615;&#65292;&#24403;&#20027;&#35774;&#22791;&#20013;&#26377;&#25968;&#25454;&#21487;&#35835;&#26102;&#65292;&#23558;&#20854;&#35835;&#20986;&#65292;
&#24182;&#35843;&#29992;log_line()&#20889;&#20837;&#30456;&#24212;&#30340;log&#25991;&#20214;&#12290;
<span class="org-block-begin-line">#+BEGIN_EXAMPLE
</span><span class="org-block">
        /* Log directly to the specified log */
        static void do_log_line(struct log_info *log_info, char *line) {
            if (log_info-&gt;log_target &amp; LOG_KLOG) {
                klog_write(6, log_info-&gt;klog_fmt, line);
            }
            if (log_info-&gt;log_target &amp; LOG_ALOG) {
                ALOG(LOG_INFO, log_info-&gt;btag, "%s", line);
            }
            if (log_info-&gt;log_target &amp; LOG_FILE) {
                fprintf(log_info-&gt;fp, "%s\n", line);
            }
        }
        
        /* Log to either the abbreviated buf, or directly to the specified log
         * via do_log_line() above.
         */
        static void log_line(struct log_info *log_info, char *line, int len) {
            if (log_info-&gt;abbreviated) {
                add_line_to_abbr_buf(&amp;log_info-&gt;a_buf, line, len);
            } else {
                do_log_line(log_info, line);
            }
        }
        
        static void add_line_to_abbr_buf(struct abbr_buf *a_buf, char *linebuf, int linelen) {
            if (!a_buf-&gt;beginning_buf_full) {
                a_buf-&gt;beginning_buf_full =
                    add_line_to_linear_buf(&amp;a_buf-&gt;b_buf, linebuf, linelen);
            }
            if (a_buf-&gt;beginning_buf_full) {
                add_line_to_circular_buf(&amp;a_buf-&gt;e_buf, linebuf, linelen);
            }
        }
        
</span><span class="org-block-end-line">#+END_EXAMPLE
</span>&#22914;&#26524;abbreviated&#27809;&#26377;&#34987;&#35774;&#32622;&#65292;&#21017;&#36890;&#36807;do_log_line()&#30452;&#25509;&#25226;log&#20889;&#20837;&#30456;&#24212;&#20301;&#32622;&#12290;
&#21542;&#21017;&#35843;&#29992;add_line_to_abbr_buf()&#65292;&#25226;log&#20889;&#20837;&#21040;log_info&#32467;&#26500;&#20307;&#30340;buf&#20013;&#12290;

<span class="org-block-begin-line">#+BEGIN_EXAMPLE
</span><span class="org-block">
    if (chld_sts != NULL) {
        *chld_sts = status;
    } else {
      if (WIFEXITED(status))
        rc = WEXITSTATUS(status);
      else
        rc = -ECHILD;
    }

    // Flush remaining data
    if (a != b) {
      buffer[b] = '\0';
      log_line(&amp;log_info, &amp;buffer[a], b - a);
    }

    /* All the output has been processed, time to dump the abbreviated output */
    if (abbreviated) {
        print_abbr_buf(&amp;log_info);
    }

    if (WIFEXITED(status)) {
      if (WEXITSTATUS(status)) {
        snprintf(tmpbuf, sizeof(tmpbuf),
                 "%s terminated by exit(%d)\n", log_info.btag, WEXITSTATUS(status));
        do_log_line(&amp;log_info, tmpbuf);
      }
    } else {
      if (WIFSIGNALED(status)) {
        snprintf(tmpbuf, sizeof(tmpbuf),
                       "%s terminated by signal %d\n", log_info.btag, WTERMSIG(status));
        do_log_line(&amp;log_info, tmpbuf);
      } else if (WIFSTOPPED(status)) {
        snprintf(tmpbuf, sizeof(tmpbuf),
                       "%s stopped by signal %d\n", log_info.btag, WSTOPSIG(status));
        do_log_line(&amp;log_info, tmpbuf);
      }
    }

err_waitpid:
err_poll:
    if (log_target &amp; LOG_FILE) {
        fclose(log_info.fp); /* Also closes underlying fd */
    }
    if (abbreviated) {
        free_abbr_buf(&amp;log_info.a_buf);
    }
    return rc;

</span><span class="org-block-end-line">#+END_EXAMPLE
</span></pre>
  </body>
</html>
